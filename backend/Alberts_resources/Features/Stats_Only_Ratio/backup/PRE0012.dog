Brewing Java: A Tutorial^0.0^0.0^0.0^0.0^0.0^0.041666666666666664^4.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Brewing Java: A Tutorial^0.0^0.0^0.0^0.0^0.0^0.041666666666666664^4.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Copyright 1995-1998, 2000-2002, 2004-2006 Elliotte Rusty Harold^0.0^0.0^0.25^0.0^0.0^0.0^4.0^0.0^text
 elharo@metalab.unc.edu^0.0^0.0^1.0^0.0^0.0^0.0^4.0^0.0^text
 Last-modified: 2005/07/19^0.0^0.0^0.0^0.0^0.0^0.10714285714285714^2.0^0.5^text
 URL: http://www.cafeaulait.org/javatutorial.html^0.0^0.0^1.0^0.0^0.0^0.0392156862745098^7.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
This tutorial has grown into a book called ^0.0^0.0^0.0^0.125^0.0^0.0^8.0^0.375^text
The Java Developer's Resource^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.25^text
, available now from Prentice Hall. It's now out of print, but the ^0.0^0.0^0.0^0.0^0.0^0.0^12.0^0.5833333333333334^text
examples^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 and ^0.5^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
exercises^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 from that book are also online here and may be of use. For more details about the JDR including the plans for a second edition see the ^0.25^0.0^0.037037037037037035^0.07407407407407407^0.0^0.0^27.0^0.5925925925925926^text
JDR^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 page.^1.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
June 3, 2006^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Minor corrections on array dimensions^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.2^text
July 19, 2005^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Improve naming conventions in examples ^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.2^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
June 26, 2004^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Fix a typo and make some efforts (incomplete) toward well-formedness ^0.0^0.0^0.09090909090909091^0.0^0.02702702702702703^0.0^11.0^0.45454545454545453^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
January 2, 2002^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Fix a typo and URLs ^0.0^0.0^0.2^0.0^0.0^0.0^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
February 8, 2001^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Minor bug fix ^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
January 6, 2001^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Some minor changes about = and := ^0.0^0.0^0.0^0.0^0.0^0.02702702702702703^5.0^0.6^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
May 23, 2000^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Fixed a few typos. ^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
April 23, 2000^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Fixed a few bugs. ^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
September 7, 1998^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Fixed a few typos ^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
June 23, 1998^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Very minor corrections and updates ^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
April 8, 1997^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 This tutorial covers Java 1.0. I've also posted ^0.0^0.0^0.0^0.14285714285714285^0.0^0.0^7.0^0.14285714285714285^text
several hundred pages of lecture notes^0.0^0.0^0.0^0.0^0.0^0.0^6.0^0.5^text
 from an Introduction to Java Programming course I'm teaching at Polytechnic University. These notes cover Java 1.1 extensively, and cover many more topics than are discussed here.^0.0^0.0^0.0^0.0^0.0^0.0^26.0^0.4230769230769231^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
March 3, 1997^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 I've fixed a number of typos.^0.0^0.0^0.0^0.0^0.0^0.0^6.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
November 13, 1996^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 I've improved the treatment of recursion, expanded and updated the installation and getting started instructions, fixed a bug in the Mondrian programs, and cleaned up some other parts. ^0.0^0.0^0.0^0.0^0.0^0.0^28.0^0.42857142857142855^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
September 20, 1996^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 I fixed a bug in the Arg method of the complex class. Arguments in all quadrants are now handled properly. I've also fixed a few other minor bugs in various programs. ^0.0^0.0^0.03225806451612903^0.03225806451612903^0.0^0.0^31.0^0.45161290322580644^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
March 26, 1996^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The RAM config program, typewriter applet, Bozo sort algorithm and Java doodle applet are finally included.^0.0^0.0^0.1875^0.0625^0.0^0.0^16.0^0.1875^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
March 25, 1996^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 I recently completed my first book which grew out of this tutorial. It should be out in a few months. This file is mostly just a rough draft for some sections of that book. The book will be much improved over the very rough material you see here. If you don't like this page, you may still like the book. If you do like this page, you should love the book.^0.0^0.0^0.0^0.1267605633802817^0.0^0.0^71.0^0.49295774647887325^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
I'm now left in something of a quandary. How should I best update this tutorial? On the one hand it would be easiest to just slap the 400 pages I wrote for the book onto the web. However that would make my publisher very unhappy. On the other hand I don't feel like duplicating all my work for the book.^0.0^0.0^0.0^0.06779661016949153^0.0^0.003236245954692557^59.0^0.4915254237288136^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
What I've decided to do is to try and clean this tutorial up by fixing the various mistakes, but not to add much new material to it. For instance the last fix to the ComplexNumber class broke multiplication. It is now working again. I've also fixed a lot of other random mistakes. Finally you'll notice that almost all the unwritten sections have been deleted. At this point if something's in the table of contents, then it's probably actually here. ^0.125^0.0^0.012658227848101266^0.11392405063291139^0.0^0.0^79.0^0.5189873417721519^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Don't despair, though. I'm going to be writing a series of shorter articles on various topics that I either didn't cover in the book, or don't think I covered as well as I could have. Planned topics include^0.0^0.0^0.0^0.05263157894736842^0.0^0.0^38.0^0.42105263157894735^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Why Java is different from C++ ^0.0^0.0^0.0^0.0^0.0^0.03125^6.0^0.5^text
An Introduction to classes through complex numbers ^0.0^0.0^0.0^0.0^0.0^0.0^7.0^0.42857142857142855^text
Linked lists ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
Sparse arrays ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
Working with Strings ^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
Java Tokens ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
Java Data types ^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
Bitwise operators ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
Calling Native Code ^0.0^0.0^0.0^0.3333333333333333^0.0^0.0^3.0^0.0^text
Inf, NaN and all that: IEEE 754 arithmetic ^0.0^0.0^0.14285714285714285^0.0^0.0^0.022727272727272728^7.0^0.42857142857142855^text
Images and the Mandelbrot Set ^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Furthermore the book includes a substantial number of exercises. However it does not include answers. I am going to be posting those^0.0^0.0^0.0^0.0^0.0^0.0^22.0^0.45454545454545453^text
 exercises here^1.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
 along with detailed explanations and answers. In this way I hope to fill out some more topics than I would have time to do in a straight tutorial fashion.^0.3333333333333333^0.0^0.0^0.06896551724137931^0.0^0.0^29.0^0.4827586206896552^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Finally I will be putting most of the ^0.0^0.0^0.0^0.125^0.0^0.0^8.0^0.625^text
source code from the book ^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.4^text
online as well. This will provide a series of useful examples.^0.0^0.0^0.0^0.09090909090909091^0.0^0.0^11.0^0.45454545454545453^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Thus there will be a lot more new tutorial here. However this tutorial is mostly complete. There's certainly more it could cover, but I just decided I didn't want to write the same book twice.^0.0^0.0^0.0^0.05714285714285714^0.0^0.0^35.0^0.5142857142857142^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
February 7, 1996^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Fixed some errors in the ComplexNumber class. DivideBy now works and toString() gives more aesthetic results when the imaginary part of a number is negative. ^0.0^0.0^0.12^0.04^0.0125^0.0^25.0^0.48^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
January 25, 1996^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Polished up some of the EventTutor applets. Lesson of the day: You have to add your components to your layout.^0.0^0.0^0.1^0.0^0.0^0.009009009009009009^20.0^0.6^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
January 24, 1996^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Finished the Middle Third Applet. Lesson of the day: Casting is ^0.0^0.0^0.09090909090909091^0.0^0.0^0.015384615384615385^11.0^0.45454545454545453^text
not^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
 the same as rounding.^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.75^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
January 18, 1996^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Fixed assorted long standing errors. ^0.0^0.0^0.0^0.2^0.0^0.0^5.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
January 16, 1996^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.5^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Substantially improved Complex number class and examples. ^0.0^0.0^0.0^0.14285714285714285^0.0^0.0^7.0^0.14285714285714285^text
Almost all code and most text is now beta compliant ^0.0^0.0^0.0^0.0^0.0^0.0^10.0^0.6^text
Added change history. ^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.5^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
This is a Java tutorial in progress. A ^0.0^0.0^0.0^0.125^0.0^0.0^8.0^0.5^text
Java FAQ list^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.0^text
 is being developed as simultaneously as time permits.^0.5^0.0^0.0^0.0^0.0^0.0^8.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Yes, I plan to split this file into smaller chunks that are easier for browsers to digest. However right now this is an early development version of this material, and ease of writing and maintenance leads me to want to keep this file in one piece. When the outline settles down I will break it up. ^0.16666666666666666^0.0^0.0^0.10714285714285714^0.0^0.0^56.0^0.44642857142857145^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
It isn't all here yet, but I hope to fill this out quickly. The chapter on basic Java syntax is reaching completion. I will update this as time permits. If you find any mistakes, please do inform me.^0.0^0.0^0.0^0.10526315789473684^0.0^0.0^38.0^0.47368421052631576^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Comments you might have on the structure, organization or contents of this document are appreciated. Although a lot remains to be fleshed out, the basic structure is as follows:^0.0^0.0^0.0^0.034482758620689655^0.0^0.005555555555555556^29.0^0.5172413793103449^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Part 1 is a brief introduction to what Java is, why it's cool and what you need to use it.^0.0^0.0^0.0^0.0^0.0^0.0^19.0^0.6842105263157895^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Part 2 is a tutorial introduction to Java that just covers what you need to know to start programming command line applications in Java. This is an introduction to the basic syntax of the language. It skims over many details and completely omits little used features like bit-shift operators. This section is fairly complete.^0.0^0.0^0.0^0.037037037037037035^0.0^0.0^54.0^0.3888888888888889^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Part 3 covers the basics of writing applets in Java.^0.0^0.0^0.1111111111111111^0.0^0.0^0.0^9.0^0.4444444444444444^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Part 4 introduces you to objects and classes.^0.0^0.0^0.0^0.0^0.0^0.0^7.0^0.5714285714285714^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Table of Contents^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Part 1: Why Java's Cool^0.0^0.0^0.0^0.0^0.0^0.043478260869565216^4.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Installing Java^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Windows Installation Instructions^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Unix Installation Instructions^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Running Your First Applet^0.0^0.0^0.25^0.0^0.0^0.0^4.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Applets in Netscape^0.0^0.0^0.6666666666666666^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Part 2:The Syntax^0.0^0.0^0.0^0.0^0.0^0.058823529411764705^3.0^0.6666666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Hello World: The Application^0.0^0.0^0.0^0.0^0.0^0.03571428571428571^4.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Examining Hello World^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Braces and Blocks^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Comments^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Data and Variables^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Command Line Arguments^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
If^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Else^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Variables and Arithmetic Expressions^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Classes and Objects: A First Look^0.0^0.0^0.0^0.0^0.0^0.030303030303030304^6.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Interfaces^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
FahrToCelsius^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Floating Point Variables^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The For Statement^0.0^0.0^0.0^0.3333333333333333^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Assignment, Increment and Decrement Operators^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.2^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Methods^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Recursive Methods^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Arrays^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Creating Arrays^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Counting Digits^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Two Dimensional Arrays^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Multidimensional Arrays^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Unbalanced Arrays^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Searching^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Sorting^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Catching Exceptions^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
File I/O and Streams^0.0^0.0^0.0^0.0^0.0^0.05^5.0^0.2^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Interactively communicating with the user^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Reading Numbers^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Reading Formatted Data^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Writing a text file^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Reading a text file^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Summing Up^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Part 3: Applets^0.0^0.0^0.5^0.0^0.0^0.06666666666666667^2.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Hello World: The Applet^0.0^0.0^0.25^0.0^0.0^0.043478260869565216^4.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Examining the Hello World Applet^0.0^0.0^0.2^0.0^0.0^0.0^5.0^0.2^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The APPLET HTML Tag^0.0^0.0^0.5^0.0^0.0^0.0^4.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Passing Parameters to Applets^0.0^0.0^0.25^0.0^0.0^0.0^4.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Events and Applets^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Event Tutor Applet^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Making a List^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The Events^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Drawing Text^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Drawing Graphics: Lines, Circles, Rectangles and Colors^0.0^0.0^0.0^0.0^0.0^0.01818181818181818^7.0^0.14285714285714285^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Drawing Rectangles^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Drawing Lines^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Taking Action: Threads^0.0^0.0^0.0^0.0^0.0^0.045454545454545456^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Bozo Sort^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Interaction: Mouse and Keyboard Input^0.0^0.0^0.0^0.0^0.0^0.02702702702702703^5.0^0.2^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Mouse Input: Java Doodle^0.0^0.0^0.0^0.0^0.0^0.041666666666666664^4.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Keyboard Input: TypeWriter^0.0^0.0^0.0^0.0^0.0^0.038461538461538464^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Part 4: Objects, Classes, Methods, and Interfaces^0.0^0.0^0.0^0.0^0.0^0.02^6.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
What is Object Oriented Programming?^0.0^0.0^0.0^0.0^0.0^0.027777777777777776^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The History of Programming^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Classes and Objects^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Methods^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Some Advocacy^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
A Non-Trivial Examples: Complex Numbers^0.0^0.0^0.0^0.0^0.0^0.02564102564102564^6.0^0.16666666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
toString Methods^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Polymorphism^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Scope: Calling the Complex Class From External Classes^0.0^0.0^0.0^0.125^0.0^0.018518518518518517^8.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The Mandelbrot Set^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Acknowledgements^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Part 1: Why Java's Cool^0.0^0.0^0.0^0.0^0.0^0.043478260869565216^4.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Java has caused more excitement than any development on the Internet since Mosaic. Everyone, it seems, is talking about it. Unfortunately very few people seem to know anything about it. This tutorial is designed to change that.^0.0^0.0^0.0^0.02702702702702703^0.0^0.0^37.0^0.6216216216216216^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
People are excited about Java because of what it lets them do. Java was the first way to include inline sound and animation in a web page. Java also lets users interact with a web page. Instead of just reading it and perhaps filling out a form, users can now play games, calculate spreadsheets, chat in realtime, get continuously updated data and much, much more.^0.0^0.0^0.015384615384615385^0.015384615384615385^0.0^0.0^65.0^0.46153846153846156^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Here are just a few of the many things Java can do for a web page:^0.0^0.0^0.0^0.125^0.0^0.015151515151515152^16.0^0.5625^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Inline sounds that play in realtime whenever a user loads a page ^0.0^0.0^0.08333333333333333^0.0^0.0^0.0^12.0^0.4166666666666667^text
Music that plays in the background on a page ^0.0^0.0^0.0^0.0^0.0^0.0^9.0^0.5555555555555556^text
Cartoon style animations ^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
Realtime video ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
Multiplayer interactive games ^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 However Java is more than just a web browser with special features. All of these features can be integrated into browsers in other ways. Although HotJava was the first browser to include inline sound and animation, Microsoft's Internet Explorer 2.0 and Netscape Navigator 2.0 support these features in several different ways. What makes Java special?^0.0^0.0^0.05660377358490566^0.0^0.0^0.002785515320334262^53.0^0.4716981132075472^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Java is a programming language for distributed applications. It doesn't just allow you to add new types of content to your pages like Netscape and Internet Explorer do. Rather it lets you add both the content and the code necessary to interact with that content. You no longer need to wait for the next release of a browser that supports your preferred image format or special game protocol. With Java you send browsers both the content and the program necessary to view this content at the same time!^0.0^0.0^0.011363636363636364^0.056818181818181816^0.0^0.0019267822736030828^88.0^0.4431818181818182^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Let's think about what this means for a minute. Previously you had to wait for all the companies that make the web browsers your readers use to update their browsers before you could use a new content type. Then you had to hope that all your readers actually did update their browsers. Java compatibility is a feature that any browser can implement and by so doing implement every feature!^0.8^0.0^0.0^0.057971014492753624^0.0^0.0024875621890547263^69.0^0.4927536231884058^text
 ^0.6666666666666666^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
For instance let's say you want to use EPS files on your Web site. Previously you had to wait until at least one web browser implemented EPS support. Now you don't wait. Instead you can write your own code to view EPS files and send it to any client that requests your page at the same time they request the EPS file.^0.6666666666666666^0.0^0.06451612903225806^0.03225806451612903^0.0^0.0^62.0^0.46774193548387094^text
 ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Or suppose you want people to be able to search your electronic card catalog. However the card catalog database exists on a mainframe system that doesn't speak HTTP. Before Java you could hope that some browser implemented your proprietary card catalog protocol; (fat chance) or you could try to program some intermediate cgi-bin on a UNIX box that can speak HTTP and talk to the card catalog, not an easy task. With Java when a client wants to talk to your card catalog you can send them the code they need to do so. You don't have to try to force things through an httpd server on port 80 that were never meant to go through it.^1.0^0.0^0.03418803418803419^0.03418803418803419^0.004622496147919877^0.0^117.0^0.49572649572649574^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
If that were all Java was, it would still be more interesting than a ^0.0^0.0^0.0^0.07142857142857142^0.0^0.0^14.0^0.7857142857142857^text
<marquee>^0.0^0.0^0.0^0.0^0.0^0.2222222222222222^1.0^0.0^text
 or ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
<frame>^0.0^0.0^0.0^0.0^0.0^0.2857142857142857^1.0^0.0^text
 tag in some new browser beta. But there's a lot more. Java is platform independent. A Java program can run equally well on any architecture that has a Java enabled browser. With the release of Netscape Navigator 2.0 that includes Windows 95, Windows NT, the MacOS, Sun Solaris, Sun OS 4.1.3, SGI IRIX, OSF/1, HP-UX with more to come. But wait. There's more!^0.16666666666666666^0.0^0.09836065573770492^0.01639344262295082^0.0^0.005449591280653951^61.0^0.4262295081967213^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Java isn't just for web sites. Java is a programming language that lets you do almost anything you can do with a traditional programming langauge like Fortran or C++. However Java has learned from the mistakes of its predecessors. It is considerably cleaner and easier to use than those languages.^0.0^0.0^0.0^0.06^0.0^0.003289473684210526^50.0^0.48^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
As a language Java is^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.6^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Simple ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 Java has the bare bones functionality needed to implement its rich feature set. It does not add lots of syntactic sugar or unnecessary features.^0.0^0.0^0.0^0.0^0.0^0.0^24.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Object-Oriented ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 Almost everything in Java is either a class, a method or an object. Only the most basic primitive operations and data types (int, for, while, etc.) are at a sub-object level.^0.0^0.0^0.0^0.125^0.011299435028248588^0.0^32.0^0.53125^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Platform Independent ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 Java programs are compiled to a byte code format that can be read and run by interpreters on many platforms including Windows 95, Windows NT, and Solaris 2.3 and later.^0.0^0.0^0.03571428571428571^0.03571428571428571^0.0^0.0^28.0^0.42857142857142855^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Safe ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 Java code can be executed in an environment that prohibits it from introducing viruses, deleting or modifying files, or otherwise performing data destroying and computer crashing operations.^0.0^0.0^0.0^0.0^0.0^0.0^27.0^0.4444444444444444^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
High Performance ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 Java can be compiled on the fly with a Just-In-Time compiler (JIT) to code that rivals C++ in speed.^0.6666666666666666^0.0^0.047619047619047616^0.0^0.01904761904761905^0.009523809523809525^21.0^0.47619047619047616^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Multi-Threaded ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 Java is inherently multi-threaded. A single Java program can have many different things processing independently and continuously.^0.0^0.0^0.0^0.0^0.0^0.0^18.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Installing Java^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
As of this writing Java is not a fully developed commercial product. Versions of Java at varying stages of completion are available from Sun for Windows 95 and Windows NT for X86, Solaris 2.3 to 2.5, and MacOS 7.5. At the present time there are no versions of Java available for MIPS, Alpha or PowerPC based NT, Windows 3.1, or the Amiga.^0.0^0.0^0.07017543859649122^0.07017543859649122^0.0^0.0^57.0^0.38596491228070173^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^1.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Borland^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 is also working a Java development environment to be released in the first half of 1996. Various third-party efforts are under way to port Java to other platforms including the Amiga, Windows 3.1, OS/2 and others.^0.2^0.0^0.02857142857142857^0.0^0.0^0.0045662100456621^35.0^0.5142857142857142^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The basic Java environment consists of a web browser that can play Java applets, a Java compiler to turn to Java source code into byte code, and a Java interpreter to run Java programs. These are the three key components of a Java environment. You'll also need a text editor like Brief or BBEdit. Other tools like a debugger, a visual development environment, documentation and a class browser are also nice but aren't absolutely necessary.^0.0^0.0^0.02666666666666667^0.02666666666666667^0.0^0.0^75.0^0.41333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Note that it isn't necessary to get all three of these from the same source. For instance ^0.0^0.0^0.0^0.058823529411764705^0.0^0.0^17.0^0.7058823529411765^text
Netscape^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 is committed to providing a Java-enabled web browser. However it will only provide a Java compiler with the next version of its server products.^0.25^0.0^0.0^0.0^0.0^0.0^25.0^0.52^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Sun has made the Java Developers Kit available for its supported platforms. It includes an applet viewer that will let you view and test your applets. The JDK also includes the javac compiler, the java interpreter, the javaprof profiler, the javah header file generator (for integrating C into your Java code), the Java debugger and limited documentation. However most of the documentation for the API and the class library is on Sun's web site. ^0.0^0.0^0.0945945945945946^0.05405405405405406^0.004395604395604396^0.0^74.0^0.40540540540540543^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
You can ftp the programs from the following sites:^0.0^0.0^0.0^0.0^0.0^0.02^9.0^0.5555555555555556^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
USA ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
ftp://ftp.javasoft.com/pub/^0.0^0.0^0.2^0.0^0.0^0.07407407407407407^5.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
ftp://www.blackdown.org/pub/Java/pub/^0.0^0.0^0.42857142857142855^0.0^0.0^0.10810810810810811^7.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
ftp://ftp.science.wayne.edu/pub/java/^0.0^0.0^0.14285714285714285^0.0^0.0^0.08108108108108109^7.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
ftp://metalab.unc.edu/pub/languages/^0.0^0.0^0.5^0.0^0.0^0.08333333333333333^6.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
ftp://java.dnx.com/pub/^0.0^0.0^0.2^0.0^0.0^0.08695652173913043^5.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Germany: ^0.0^0.0^0.0^0.0^0.0^0.1111111111111111^1.0^0.0^text
ftp://sunsite.informatik.rwth-aachen.de/pub/mirror/java.sun.com/JDK-beta-win32-x86.exe^0.0^0.0^0.4375^0.0^0.0^0.046511627906976744^16.0^0.0625^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Korea: ^0.0^0.0^0.0^0.0^0.0^0.14285714285714285^1.0^0.0^text
ftp://ftp.kaist.ac.kr/pub/java/e^0.0^0.0^0.125^0.0^0.0^0.09375^8.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
China: ^0.0^0.0^0.0^0.0^0.0^0.14285714285714285^1.0^0.0^text
ftp://math01.math.ac.cn/pub/sunsite^0.0^0.0^0.42857142857142855^0.0^0.0^0.05714285714285714^7.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Japan: ^0.0^0.0^0.0^0.0^0.0^0.14285714285714285^1.0^0.0^text
ftp://ftp.glocom.ac.jp/mirror/java.sun.com/^0.0^0.0^0.2222222222222222^0.0^0.0^0.06976744186046512^9.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Sweden: ^0.0^0.0^0.0^0.0^0.0^0.125^1.0^0.0^text
ftp://ftp.luth.se/pub/infosystems/www/hotjava/pub/^0.0^0.0^0.4444444444444444^0.0^0.0^0.12^9.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Singapore: ^0.0^0.0^0.0^0.0^0.0^0.09090909090909091^1.0^0.0^text
ftp://ftp.iss.nus.sg/pub/java/^0.0^0.0^0.2857142857142857^0.0^0.0^0.1^7.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
United Kingdom: ^0.0^0.0^0.0^0.0^0.0^0.0625^2.0^0.0^text
ftp://sunsite.doc.ic.ac.uk/packages/java/^0.0^0.0^0.125^0.0^0.0^0.07317073170731707^8.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Macintosh Installation Instructions^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The file you get will be a self-extracting archive called something like JDK-1_0_2-MacOS.sea.bin. If you use Fetch or Anarchie to download it will be automatically converted into the self-extracting JDK-1_0_2-MacOS.sea. Double-click it to extract it and the double-click the resulting installer JDK-1_0_2-MacOS. It will prompt you for a location to put it on your hard disk. Put it wherever is convenient.^0.0^0.0^0.13513513513513514^0.05405405405405406^0.0^0.0^74.0^0.4594594594594595^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
It may be helpful to make aliases of the Applet Viewer, the Java Compiler and the Java Runner and put them on your desktop for ease of dragging and dropping later, especially if you have a large monitor.^0.0^0.0^0.02631578947368421^0.05263157894736842^0.0^0.0^38.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Windows Installation Instructions^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The Windows X86 release is a self extracting archive. You will need about six megabytes of free disk space to install the JDK. Execute the file by double-clicking on it in the File Manager or by selecting Run... from the Program Manager's File menu and typing the path to the file. This will unpack the archive. The full path is unimportant, but for simplicity's sake I am going to assume you installed it from the root of your C: drive. If this is the case the files will live in C:\java. If you unpacked it somewhere else just replace C:\ by the full path to the java directory in what follows.^0.0^0.0^0.017699115044247787^0.07079646017699115^0.0^0.0049261083743842365^113.0^0.4690265486725664^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
You will need to add C:\java\bin directory to your PATH environment variable^0.0^0.0^0.0^0.0^0.0^0.012987012987012988^14.0^0.35714285714285715^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
In addition to the java files, the archive includes two common DLL's: ^0.0^0.0^0.07692307692307693^0.0^0.0^0.014084507042253521^13.0^0.38461538461538464^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
MSVCRT20.DLL ^0.0^0.0^1.0^0.0^0.0^0.0^2.0^0.0^text
MFC30.DLL ^0.0^0.0^1.0^0.0^0.0^0.0^2.0^0.0^text
 These two files will be installed in your java directory. If you do not already have copies of these two files on your system, (There's a very good chance you do, probably in your system directory.) copy them into the C:\java\bin directory. If you do have these two files already, just delete these extra copies. ^0.0^0.0^0.0^0.08771929824561403^0.006211180124223602^0.003105590062111801^57.0^0.5263157894736842^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Unix Installation Instructions^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
If you're on a shared system at a university or an Internet service provider, there's a good chance Java is already installed. Ask your local support staff how to access it. Otherwise follow these instructions.^0.0^0.0^0.0^0.02857142857142857^0.0^0.0^35.0^0.4857142857142857^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 The Unix release is a compressed tar file. You will need about nine megabytes of disk space to uncompress and untar the JDK. Double that would be very helpful. You do this with the commands:^0.25^0.0^0.08571428571428572^0.08571428571428572^0.0^0.005154639175257732^35.0^0.5142857142857142^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
% uncompress JDK-1_0_2-solaris2-sparc.tar.Z % tar xvf JDK-1_0_2-solaris2-sparc.tar ^0.0^0.0^0.5714285714285714^0.0^0.0^0.023529411764705882^14.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The exact file name may be a little different if you?re retrieving the release for a different platform such as Irix or if the version is different. You can untar it in your home directory, or, if you have root privileges, in some convenient place like /usr/local where all users can have access to the files. However root privileges are not necessary to install or run Java. Untarring the file creates all necessary directories and sub-directories. The exact path is unimportant, but for simplicity's sake this book assumes it?s installed it in /usr/local. If a sysop already installed it, this is probably where it lives. (Under Solaris it's also possible the sysop put it into /opt.) If this is the case the files live in /usr/local/java. If you unpacked it somewhere else, just replace /usr/local by the full path to the java directory in what follows. If you installed it in your home directory, you can use ~/java and ~/hotjava instead of a full path.^0.0^0.0^0.06358381502890173^0.08092485549132948^0.0020597322348094747^0.010298661174047374^173.0^0.4682080924855491^text
 You now need to add /usr/local/java/bin directory to your PATH environment variable. You use one of the following commands depending on your shell.^0.0^0.0^0.038461538461538464^0.0^0.0^0.026490066225165563^26.0^0.4230769230769231^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
csh, tcsh: ^0.0^0.0^1.0^0.0^0.0^0.07692307692307693^2.0^0.0^text
	% set path=($PATH /usr/local/java/bin) ^4.0^0.0^0.2857142857142857^0.0^0.04878048780487805^0.14634146341463414^7.0^0.0^text
sh: ^0.0^0.0^0.0^0.0^0.0^0.16666666666666666^1.0^0.0^text
	% PATH=($PATH /usr/local/java/bin); export $PATH ^4.0^0.0^0.375^0.0^0.058823529411764705^0.11764705882352941^8.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
You should also add these lines to the end of your .profile and .cshrc files so you won't have to do this every time you login. Now you're ready to run some applets.^0.0^0.0^0.09090909090909091^0.06060606060606061^0.0^0.0^33.0^0.5757575757575758^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Running Your First Applet^0.0^0.0^0.25^0.0^0.0^0.0^4.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Unix Instructions^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Start the Applet Viewer by doing the following: ^0.0^0.0^0.125^0.0^0.0^0.020833333333333332^8.0^0.375^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^4.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
	Open a command line prompt, and cd to one of the directories in /usr/local/java/demo, for example ^4.0^0.0^0.05263157894736842^0.05263157894736842^0.0^0.04^19.0^0.3684210526315789^text
% cd /usr/local/java/demo/TicTacToe ^0.0^0.0^0.3333333333333333^0.0^0.0^0.15789473684210525^6.0^0.0^text
	^8.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
	Run the appletviewer on the html file: ^4.0^0.0^0.2857142857142857^0.0^0.0^0.024390243902439025^7.0^0.42857142857142855^text
% appletviewer example1.html ^0.0^0.0^1.0^0.0^0.0^0.034482758620689655^3.0^0.0^text
 ^4.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
	Play Tic-Tac-Toe! The algorithm was deliberately broken so it is possible to win. ^4.0^0.0^0.06666666666666667^0.0^0.0^0.011494252873563218^15.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Macintosh Instructions^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^4.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Start the Applet Viewer by double-clicking it. ^4.5^0.0^0.125^0.125^0.0^0.0^8.0^0.375^text
 Select Open... from the File menu and navigate into the java folder, then the Sample Applets folder, then the TicTacToe folder. ^4.5^0.0^0.09523809523809523^0.0^0.0^0.0^21.0^0.42857142857142855^text
 Select the file example1.html and click on the Open button. Alternately you can drag and drop this file onto the Applet Viewer. ^0.0^0.0^0.13043478260869565^0.043478260869565216^0.0^0.0^23.0^0.391304347826087^text
 Play Tic-Tac-Toe! The algorithm was deliberately broken so it is possible to win. ^0.5^0.0^0.06666666666666667^0.0^0.0^0.011764705882352941^15.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Windows Instructions^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 Start the Applet Viewer by doing the following: ^0.0^0.0^0.125^0.0^0.0^0.02^8.0^0.375^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^4.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
	Open a DOS window, and cd to one of the directories in C:\JAVA\DEMO, for example ^4.0^0.0^0.0^0.058823529411764705^0.0^0.012048192771084338^17.0^0.4117647058823529^text
C:< cd C:\JAVA\DEMO\TicTacToe ^0.0^0.0^0.16666666666666666^0.0^0.0^0.03125^6.0^0.0^text
	^8.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
	Run the appletviewer on the html file: ^4.0^0.0^0.2857142857142857^0.0^0.0^0.024390243902439025^7.0^0.42857142857142855^text
C:< appletviewer example1.htm ^0.0^0.0^0.75^0.0^0.0^0.0^4.0^0.0^text
 ^4.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
	Play Tic-Tac-Toe! The algorithm was deliberately broken so it is possible to win. ^4.0^0.0^0.06666666666666667^0.0^0.0^0.011764705882352941^15.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Hot Tip: Getting Rid of that Annoying License Dialog Box^0.0^0.0^0.0^0.0^0.0^0.017857142857142856^10.0^0.2^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Do you know the annoying dialog box I'm talking about? I bet you do. It's the one that comes up every time you launch the applet viewer to make you agree to Sun's license. Do you want to get rid of it? If so make a directory called ^0.0^0.0^0.020833333333333332^0.08333333333333333^0.0^0.008333333333333333^48.0^0.4583333333333333^text
.hotjava^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 in your java/bin directory. You won't see it again.^0.5^0.0^0.0^0.0^0.0^0.018518518518518517^10.0^0.6^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Applets in Netscape^0.0^0.0^0.6666666666666666^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Netscape 3.0 will run Java applets on most platforms except Windows 3.1. Netscape has a ^0.0^0.0^0.23076923076923078^0.0^0.0^0.0^13.0^0.46153846153846156^text
Java Demo Page^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 with links to various applets that will mostly run. However do not be surprised if an applet fails to work properly in Netscape.^0.3333333333333333^0.0^0.13043478260869565^0.08695652173913043^0.0^0.0^23.0^0.4782608695652174^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Part 2:The Syntax^0.0^0.0^0.0^0.0^0.0^0.058823529411764705^3.0^0.6666666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Hello World: The Application^0.0^0.0^0.0^0.0^0.0^0.03571428571428571^4.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
At least since the first edition of ^0.0^0.0^0.0^0.0^0.0^0.0^7.0^0.8571428571428571^text
Kernighan^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 and ^0.5^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
Ritchie's^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^1.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The C Programming Language^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.25^text
 it's been customary to begin programming tutorials and classes with the "Hello World" program, a program that prints the string "Hello World" to the display. Being heavily influenced by Kernighan and Ritchie and not ones to defy tradition we begin similarly.^0.16666666666666666^0.0^0.0^0.0^0.0^0.0^41.0^0.43902439024390244^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The following is the Hello World Application as written in Java. Type it into a text file or copy it out of your web browser, and save it as a file named ^0.0^0.0^0.0^0.0^0.0^0.0^32.0^0.5^text
HelloWorld.java^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class HelloWorld { public static void main (String args[]) { System.out.println("Hello World!"); } }^1.1111111111111112^0.0^0.23076923076923078^0.3076923076923077^0.09016393442622951^0.00819672131147541^13.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
To compile this program make sure you're in the same directory HelloWorld.java is in and type ^0.0^0.0^0.058823529411764705^0.058823529411764705^0.0^0.0^17.0^0.47058823529411764^text
javac HelloWorld.java^0.0^0.0^0.6666666666666666^0.0^0.0^0.0^3.0^0.0^text
 at the command prompt. ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
Hello World^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 is very close to the simplest program imaginable. Although it doesn't teach very much from a programming standpoint, it gives you a chance to learn the mechanics of writing and compiling code. If you're like me your first effort won't compile, especially if you typed it in from scratch rather than copying and pasting. Here are a few common mistakes: ^0.16666666666666666^0.0^0.0^0.03333333333333333^0.0^0.002777777777777778^60.0^0.5333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Did you put a semicolon after ^1.0^0.0^0.0^0.0^0.0^0.0^6.0^0.6666666666666666^text
System.out.println("Hello World")^0.0^0.0^0.2^0.0^0.06060606060606061^0.0^5.0^0.0^text
? ^0.0^0.0^0.0^0.0^0.0^0.3333333333333333^0.0^0.0^text
 Did you include the closing bracket? ^0.5^0.0^0.0^0.0^0.0^0.02564102564102564^6.0^0.3333333333333333^text
 Did you type everything exactly as it appears here? In particular did you use the same capitalization? Java is case sensitive. ^0.3333333333333333^0.0^0.0^0.047619047619047616^0.0^0.015384615384615385^21.0^0.47619047619047616^text
class^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 is not the same as ^1.0^0.0^0.0^0.0^0.0^0.0^5.0^1.0^text
Class^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 for example. ^0.0^0.0^0.0^0.5^0.0^0.0^2.0^0.0^text
Were you in the same directory as HelloWorld.java when you typed javac HelloWorld.java? ^0.0^0.0^0.2^0.0^0.0^0.010752688172043012^15.0^0.5333333333333333^text
Once your program has compiled successfully, the compiler places the executable output in a file called HelloWorld.class in the same directory as the source code file. You can then run the program by typing ^0.0^0.0^0.02857142857142857^0.02857142857142857^0.0^0.0^35.0^0.4857142857142857^text
java HelloWorld^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
 at the command prompt. As you probably guessed the program responds by printing ^0.0^0.0^0.0^0.0^0.0^0.0^13.0^0.46153846153846156^text
Hello World!^0.0^0.0^0.0^0.0^0.0^0.08333333333333333^2.0^0.0^text
 on your screen.^1.0^0.0^0.0^0.0^0.0^0.0^3.0^0.6666666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Congratulations! You've just written your first Java program!^0.0^0.0^0.0^0.0^0.0^0.03225806451612903^8.0^0.375^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Examining Hello World^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Hello World^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 is very close to the simplest program imaginable. Nonetheless there's quite a lot going on in it. Let's investigate it, line by line.^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^23.0^0.4782608695652174^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
For now the initial ^0.0^0.0^0.0^0.25^0.0^0.0^4.0^0.5^text
class^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 statement may be thought of as defining the program name, in this case HelloWorld. The compiler actually got the name for the class file from the ^0.5^0.0^0.038461538461538464^0.15384615384615385^0.0^0.0^26.0^0.5^text
class HelloWorld^0.0^0.0^0.5^0.5^0.0^0.0^2.0^0.0^text
 statement in the source code, not from the name of the source code file. If there is more than one class in a file, then the Java compiler will store each one in a separate .class file. For reasons we'll see later it's advisable to give the source code file the same name as the main class in the file plus the .java extension.^0.0^0.0^0.0^0.078125^0.0^0.0^64.0^0.5625^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The initial ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
class^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 statement is actually quite a bit more than that since this "program" can be called not just from the command line but also by other parts of the same or different programs. We'll see more in the section on classes and methods below.^0.2^0.0^0.0^0.023255813953488372^0.0^0.0^43.0^0.627906976744186^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The HelloWorld class contains one ^0.0^0.0^0.2^0.2^0.0^0.0^5.0^0.4^text
method^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
, the main method. As in C the main method is where an application begins executing. The method is declared ^0.0^0.0^0.0^0.0^0.0^0.0^19.0^0.47368421052631576^text
public^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 meaning that the method can be called from anywhere. It is declared ^0.5^0.0^0.0^0.0^0.0^0.0^12.0^0.6666666666666666^text
static^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 meaning that all instances of this class share this one method. (If that last sentence was about as intelligible as Linear B, don't worry. We'll come back to it later.) It is declared ^0.0^0.0^0.0^0.15151515151515152^0.010362694300518135^0.0^33.0^0.48484848484848486^text
void^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 which means, as in C, that this method does not return a value. Finally we pass any command line arguments to the method in an array of Strings called ^0.25^0.0^0.0^0.10344827586206896^0.0^0.0^29.0^0.4482758620689655^text
args^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
. In this simple program there aren't any command line arguments though.^0.0^0.0^0.0^0.09090909090909091^0.0^0.0^11.0^0.45454545454545453^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Finally when the main method is called it does exactly one thing: print "Hello World" to the standard output, generally a terminal monitor or console window of some sort. This is accomplished by the ^0.0^0.0^0.0^0.058823529411764705^0.0^0.004901960784313725^34.0^0.4117647058823529^text
System.out.println^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.0^text
 method. To be more precise this is accomplished by calling the ^0.5^0.0^0.0^0.09090909090909091^0.0^0.0^11.0^0.5454545454545454^text
println()^0.0^0.0^1.0^0.0^0.2222222222222222^0.0^1.0^0.0^text
 method of the static ^0.5^0.0^0.0^0.25^0.0^0.0^4.0^0.5^text
out^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 field belonging to the ^0.5^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
System^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 class; but for now we'll just treat this as one method. ^0.5^0.0^0.0^0.2727272727272727^0.017241379310344827^0.0^11.0^0.45454545454545453^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
One final note: unlike the ^0.0^0.0^0.0^0.2^0.0^0.037037037037037035^5.0^0.4^text
printf^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 function in C the ^0.5^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
System.out.println^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.0^text
 method ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
does^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 append a newline at the end of its output. There's no need to include a ^0.5^0.0^0.0^0.0^0.0^0.0^15.0^0.6^text
\n^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 at the end of each string to break a line. ^1.0^0.0^0.0^0.1^0.0^0.0^10.0^0.6^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Exercises^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
What happens if you change the name of the source code file, e.g. HelloEarth.java instead of HelloWorld.java? ^0.0^0.0^0.1^0.05^0.0^0.009009009009009009^20.0^0.35^text
What happens if you keep the name of the source code file the same (HelloWorld.java) but change the class's name, e.g. class HelloEarth? ^0.0^0.0^0.08^0.12^0.014285714285714285^0.007142857142857143^25.0^0.48^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Braces and Blocks^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Let's investigate the Hello World program a little more closely. In Java a source code file is broken up into parts separated by opening and closing braces, i.e. the { and } characters. Everything between { and } is a ^0.0^0.0^0.0^0.0^0.017937219730941704^0.0^37.0^0.4594594594594595^text
block^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 and exists more or less independently of everything outside of the braces. ^0.5^0.0^0.0^0.0^0.0^0.0^12.0^0.6666666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Blocks are important both syntactically and logically. Without the braces the code wouldn't compile. The compiler would have trouble figuring out where one method or class ended and the next one began. Similarly it would be very difficult for someone else reading your code to understand what was going on. For that matter it would be very difficult for you, yourself to understand what was going on. The braces are used to group related statements together. In the broadest sense everything between matching braces is executed as one statement (though depending not necessarily everything inside the braces is executed every time).^0.1^0.0^0.0^0.04950495049504951^0.0030911901081916537^0.0^101.0^0.5445544554455446^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Blocks can be hierarchical. One block can contain one or more subsidiary blocks. In this case we have one outer block that defines the HelloWorld class. Within the HelloWorld block we have a method block called "main".^0.0^0.0^0.05405405405405406^0.08108108108108109^0.0^0.0^37.0^0.4864864864864865^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
In this tutorial we help to identify different blocks with indentation. Every time we enter a new block we indent our source code by two spaces. When we leave a block we deindent by two spaces. This is a common convention in many programming languages. However it is not part of the language. The code would produce identical output if we didn't indent it. In fact I'm sure you'll find a few examples here where I haven't followed convention precisely. Indentation makes the code easier to read and understand, but it does not change its meaning.^0.0^0.0^0.010416666666666666^0.041666666666666664^0.0^0.0^96.0^0.4895833333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Comments^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Comments can appear anywhere in a source file. Comments are identical to those in C and C++. Everything between ^0.0^0.0^0.0^0.0^0.0^0.008695652173913044^19.0^0.5789473684210527^text
/*^0.0^0.5^0.0^0.0^0.0^0.0^0.0^0.0^text
 and ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
*/^0.0^0.5^0.0^0.0^0.0^0.0^0.0^0.0^text
 is ignored by the compiler and everything on a line after two consecutive slashes is also thrown away. Therefore the following program is, as far as the compiler is concerned, identical to the first one:^0.25^0.0^0.0^0.0^0.0^0.004784688995215311^35.0^0.6285714285714286^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
// This is the Hello World program in Java class HelloWorld { public static void main (String args[]) { /* Now let's print the line Hello World */ System.out.println("Hello World"); } }^2.4^2.0^0.10714285714285714^0.17857142857142858^0.049773755656108594^0.0^28.0^0.17857142857142858^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Data and Variables^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Methods are only half of a Java class. The other half is data. Consider the following generalization of the HelloWorld program:^0.0^0.0^0.047619047619047616^0.047619047619047616^0.0^0.007751937984496124^21.0^0.47619047619047616^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
// This is the Hello Rusty program in Java class HelloRusty { public static void main (String args[]) { // You may feel free to replace "Rusty" with your own name String name = "Rusty"; /* Now let's say hello */ System.out.print("Hello "); System.out.println(name); } }^3.2857142857142856^3.0^0.07142857142857142^0.11904761904761904^0.045180722891566265^0.0030120481927710845^42.0^0.30952380952380953^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Here, rather than saying hello to a rather generic world, we allow Java to say hello to a specific individual. We do this by creating a ^0.0^0.0^0.0^0.07692307692307693^0.0^0.0^26.0^0.5^text
String variable^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 called "name" and storing the value "Rusty" in it. (You may, of course, have replaced Rusty with your own name.) Then we print out "Hello ". Notice that we've switched here from ^0.0^0.0^0.0^0.0^0.010810810810810811^0.0^31.0^0.6129032258064516^text
System.out.println^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.0^text
 method to the similar ^1.0^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
System.out.print^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 method. ^0.5^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
System.out.print^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 is just like ^1.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
System.out.println^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.0^text
 except that it doesn't break the line after it's finished. Therefore when we reach the next line of code, the cursor is still located on the same line as the word "Hello" and we're ready to print out the name.^0.3333333333333333^0.0^0.0^0.025^0.0^0.0^40.0^0.625^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Command Line Arguments^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Our Hello program still isn't very general. We can't change the name we say hello to without editing and recompiling the source code. This may be fine for the programmers, but what if the secretaries want their computers to say Hello to them? (I know. This is a little far-fetched but bear with me. I'm making a point.)^0.0^0.0^0.0^0.06779661016949153^0.0061162079510703364^0.0030581039755351682^59.0^0.4745762711864407^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
What we need is a way to change the name at ^0.0^0.0^0.0^0.0^0.0^0.0^11.0^0.7272727272727273^text
runtime^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 rather than at compile time. (Runtime is when we type ^0.5^0.0^0.0^0.0^0.017857142857142856^0.0^10.0^0.6^text
java HelloRusty^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
. Compile time is when we type ^0.0^0.0^0.0^0.0^0.0^0.0^6.0^0.5^text
javac HelloRusty.java^0.0^0.0^0.6666666666666666^0.0^0.0^0.0^3.0^0.0^text
). To do this we'll make use of ^0.0^0.0^0.0^0.2857142857142857^0.029411764705882353^0.0^7.0^0.42857142857142855^text
command-line arguments^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
. They allow us to type something like ^0.0^0.0^0.0^0.0^0.0^0.0^7.0^0.5714285714285714^text
Java Hello Gloria^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 and have the program respond with "Hello Gloria". Here's the code:^1.0^0.0^0.0^0.0^0.0^0.014925373134328358^11.0^0.5454545454545454^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
// This is the Hello program in Java class Hello { public static void main (String args[]) { /* Now let's say hello */ System.out.print("Hello "); System.out.println(args[0]); } }^2.5454545454545454^2.0^0.1111111111111111^0.18518518518518517^0.07272727272727272^0.0^27.0^0.14814814814814814^text
 Compile this program in the javahtml directory as usual and then type ^0.0^0.0^0.08333333333333333^0.08333333333333333^0.0^0.0^12.0^0.4166666666666667^text
java Hello Gloria^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
This isn't very hard is it? In fact we've even gotten rid of the name variable from the HelloRusty program. We're using ^0.0^0.0^0.045454545454545456^0.045454545454545456^0.0^0.008130081300813009^22.0^0.5909090909090909^text
args[0]^0.0^0.0^1.0^0.0^0.2857142857142857^0.0^1.0^0.0^text
 instead. ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
args^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 is what is known as an ^1.0^0.0^0.0^0.0^0.0^0.0^6.0^0.8333333333333334^text
array^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
. An array stores a series of values. The values can be Strings as in this example, numbers, objects or any other kind of Java data type. ^0.0^0.0^0.0^0.038461538461538464^0.0^0.0^26.0^0.46153846153846156^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
args^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 is a special array that holds the command line arguments. ^1.0^0.0^0.0^0.0^0.0^0.0^10.0^0.4^text
args[0]^0.0^0.0^1.0^0.0^0.2857142857142857^0.0^1.0^0.0^text
 holds the first command line argument. ^1.0^0.0^0.0^0.0^0.0^0.0^6.0^0.3333333333333333^text
args[1]^0.0^0.0^1.0^0.0^0.2857142857142857^0.0^1.0^0.0^text
 holds the second command line argument, ^1.0^0.0^0.0^0.0^0.0^0.0^6.0^0.16666666666666666^text
args[2]^0.0^0.0^1.0^0.0^0.2857142857142857^0.0^1.0^0.0^text
 holds the third command line argument and so on.^1.0^0.0^0.0^0.0^0.0^0.0^9.0^0.5555555555555556^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
At this point almost everyone reading this is probably saying "Whoa, that can't be right." However why you're saying depends on your background.^0.0^0.0^0.0^0.08695652173913043^0.0^0.0^23.0^0.4782608695652174^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
If you've never programmed before or if you've programmed only in Pascal or Fortran, you're probably wondering why the first element of the array is at position 0, the second at position 1, the third at position 2 instead of the clearly more sensible element 1 being the first element in the array, element 2 being the second and so on. All I can tell you is that this is a holdover from C where this convention almost made sense.^0.0^0.0^0.0^0.05333333333333334^0.0^0.0^75.0^0.6^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
On the other hand if you're used to C you're probably upset because ^0.0^0.0^0.0^0.07692307692307693^0.0^0.0^13.0^0.5384615384615384^text
args[0]^0.0^0.0^1.0^0.0^0.2857142857142857^0.0^1.0^0.0^text
 is the first command line argument instead of the command name. The problem is that in Java it's not always clear what the command name is. For instance in the above example is it java or Hello? On some systems where Java runs there may not even be a command line, the Mac for example.^0.16666666666666666^0.0^0.0^0.03636363636363636^0.0^0.0033444816053511705^55.0^0.6^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Now you should experiment with this program a little. What happens if instead of typing ^0.0^0.0^0.0^0.13333333333333333^0.0^0.0^15.0^0.4666666666666667^text
java Hello Gloria^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 you type ^1.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
java Hello Gloria and Beth^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.2^text
? What if you leave out the name entirely, i.e. ^0.0^0.0^0.0^0.1^0.0^0.02^10.0^0.4^text
java Hello^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
?^0.0^0.0^0.0^0.0^0.0^1.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
That was interesting wasn't it? You should have seen something very close to^0.0^0.0^0.0^0.0^0.0^0.012987012987012988^13.0^0.7692307692307693^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException at Hello.main(C:\javahtml\Hello.java:7)^1.0^0.0^0.14285714285714285^0.0^0.01818181818181818^0.01818181818181818^14.0^0.14285714285714285^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
What happened was that since we didn't give Hello any command line arguments there wasn't anything in ^0.0^0.0^0.0^0.0^0.0^0.0^17.0^0.6470588235294118^text
args[0]^0.0^0.0^1.0^0.0^0.2857142857142857^0.0^1.0^0.0^text
. Therefore Java kicked back this not too friendly error message about an "ArrayIndexOutOfBoundsException." That's a mouthful. We'll see one way to fix it in the next section.^0.0^0.0^0.037037037037037035^0.037037037037037035^0.0^0.0^27.0^0.5925925925925926^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
If^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
All but the most trivial computer programs need to make decisions. They need to test some condition and operate differently based on that condition. This is quite common in real life. For instance you stick your hand out the window to ^0.0^0.0^0.0^0.04878048780487805^0.0^0.0^41.0^0.43902439024390244^text
test^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 if it's raining. If it is raining then you take an umbrella with you. If it isn't raining then you don't.^0.0^0.0^0.0^0.13636363636363635^0.0^0.0^22.0^0.5909090909090909^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
All programming languages have some form of an ^0.0^0.0^0.0^0.0^0.0^0.0^8.0^0.625^text
if^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 statement that allows you to test conditions. In the previous code we should have tested whether there actually were command line arguments before we tried to use them.^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^28.0^0.5357142857142857^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
All arrays have lengths and we can access that length by referencing the variable ^0.0^0.0^0.0^0.0^0.0^0.0^14.0^0.5714285714285714^text
arrayname.length^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
. (Experienced Java programmers will note that this means that the array is an object which contains a public member variable called length.) We test the length of the ^0.0^0.0^0.0^0.07142857142857142^0.011363636363636364^0.0^28.0^0.42857142857142855^text
args^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 array as follows:^1.0^0.0^0.0^0.0^0.0^0.05555555555555555^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
// This is the Hello program in Java class Hello { public static void main (String args[]) { /* Now let's say hello */ System.out.print("Hello "); if (args.length > 0) { System.out.println(args[0]); } } }^3.230769230769231^2.0^0.13333333333333333^0.2^0.07662835249042145^0.0038314176245210726^30.0^0.13333333333333333^text
 Compile and run this program and toss different inputs at it. You should note that there's no longer an ArrayIndexOutOfBoundsException if you don't give it any command line arguments at all.^0.0^0.0^0.03225806451612903^0.0967741935483871^0.0^0.0^31.0^0.5161290322580645^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
What we did was wrap the ^0.0^0.0^0.0^0.0^0.0^0.0^6.0^0.6666666666666666^text
System.out.println(args[0])^0.0^0.0^0.5^0.0^0.14814814814814814^0.0^4.0^0.0^text
 statement in a conditional test, ^0.5^0.0^0.0^0.0^0.0^0.0^5.0^0.4^text
if (args.length > 0) { }^0.0^0.0^0.3333333333333333^0.3333333333333333^0.16666666666666666^0.041666666666666664^3.0^0.0^text
. The code inside the braces, ^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.4^text
System.out.println(args[0])^0.0^0.0^0.5^0.0^0.14814814814814814^0.0^4.0^0.0^text
, now gets executed if and only if the length of the args array is greater than zero. In Java numerical greater than and lesser than tests are done with the > and < characters respectively. We can test for a number being less than or equal to and greater than or equal to with <= and >= respectively.^0.0^0.0^0.018518518518518517^0.05555555555555555^0.0^0.013029315960912053^54.0^0.5740740740740741^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Testing for equality is a little trickier. We would expect to test if two numbers were equal by using the = sign. However we've already used the = sign to set the value of a variable. Therefore we need a new symbol to test for equality. Java borrows C's double equals sign, ==, to test for equality.^0.0^0.0^0.0^0.1111111111111111^0.0^0.009771986970684038^54.0^0.4074074074074074^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
It's not uncommon for even experienced programmers to write == when they mean = or vice versa. In fact this is a very common cause of errors in C programs. Fortunately in Java, you are not allowed to use == and = in the same places. Therefore the compiler can catch your mistake and make you fix it before you run the program.^0.0^0.0^0.0^0.05084745762711865^0.0^0.012048192771084338^59.0^0.5423728813559322^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
All conditional statements in Java require boolean values, and that's what the ==, <, >, <=, and >= operators all return. A boolean is a value that is either true or false. Unlike in C booleans are not the same as ints, and ints and booleans cannot be cast back and forth. If you need to set a boolean variable in a Java program, you have to use the constants ^0.0^0.0^0.06153846153846154^0.07692307692307693^0.0^0.01358695652173913^65.0^0.5538461538461539^text
true^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 and ^0.5^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
false^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
. ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
false^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 is not 0 and ^0.5^0.0^0.0^0.0^0.0^0.0^3.0^1.0^text
true^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 is not non-zero as in C. Boolean values are no more integers than are strings.^0.5^0.0^0.0^0.0625^0.0^0.0^16.0^0.5625^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Experienced programmers may note that there was an alternative method to deal with the ArrayIndexOutOFBoundsException involving ^0.0^0.0^0.0625^0.0^0.0^0.0^16.0^0.5^text
try^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 and ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
catch^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 statements. We'll return to that soon.^0.5^0.0^0.0^0.16666666666666666^0.0^0.0^6.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Else^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
You may have noticed a minor ^0.0^0.0^0.0^0.0^0.0^0.0^6.0^0.6666666666666666^text
cosmetic bug^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 in the previous program. A cosmetic bug is one that doesn't crash the program or system, or produce incorrect results, but just looks a little annoying. Cosmetic bugs are acceptable in quick hacks you'll only use once but not in finished code.^0.16666666666666666^0.0^0.0^0.0^0.0^0.0^42.0^0.4523809523809524^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The cosmetic bug here was that if we didn't include any command line arguments, although the program didn't crash, it still didn't say Hello. The problem was that we only used ^0.0^0.0^0.0^0.03225806451612903^0.0^0.0^31.0^0.4838709677419355^text
System.out.print^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 and not ^0.5^0.0^0.0^0.0^0.0^0.0^2.0^1.0^text
System.out.println^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.0^text
. There was never any end of line character. It was like we typed in what we wanted to say, but never hit the return key.^0.0^0.0^0.0^0.04^0.0^0.0^25.0^0.6^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
We could fix this by putting a ^0.0^0.0^0.0^0.14285714285714285^0.0^0.0^7.0^0.5714285714285714^text
System.out.println("");^0.0^0.0^0.3333333333333333^0.0^0.13043478260869565^0.0^3.0^0.0^text
 line at the end of the main method, but then we'd have one too many end-of-lines if the user did type in a name. We could add an additional if statement like so:^0.25^0.0^0.0^0.05714285714285714^0.0^0.006024096385542169^35.0^0.5714285714285714^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
// This is the Hello program in Java class Hello { public static void main (String args[]) { /* Now let's say hello */ System.out.print("Hello "); if (args.length > 0) { System.out.println(args[0]); } if (args.length <= 0) { System.out.println("whoever you are"); } } }^3.875^2.0^0.15384615384615385^0.1794871794871795^0.07736389684813753^0.0057306590257879654^39.0^0.1794871794871795^text
 This corrects the bug, but the code is hard to read and maintain. It's very easy to miss a possible case. For instance we might well have tested to see if ^0.0^0.0^0.0^0.12903225806451613^0.0^0.0^31.0^0.5161290322580645^text
args.length^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
 were less than zero and left out the more important case that ^0.5^0.0^0.0^0.08333333333333333^0.0^0.0^12.0^0.5833333333333334^text
args.length^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
 equals zero. What we need is an ^0.5^0.0^0.0^0.0^0.0^0.0^7.0^0.5714285714285714^text
else^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 statement that will catch any result other than the one we hope for, and luckily Java provides exactly that. Here's the right solution:^0.25^0.0^0.0^0.08695652173913043^0.0^0.007142857142857143^23.0^0.5217391304347826^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
// This is the Hello program in Java class Hello { public static void main (String args[]) { /* Now let's say hello */ System.out.print("Hello "); if (args.length > 0) { System.out.println(args[0]); } else { System.out.println("whoever you are"); } } }^3.875^2.0^0.13513513513513514^0.1891891891891892^0.07530120481927711^0.0030120481927710845^37.0^0.1891891891891892^text
 Now that Hello at least doesn't crash with an ArrayIndexOutOfBoundsException we're still not done. ^0.0^0.0^0.07142857142857142^0.0^0.0^0.0^14.0^0.7142857142857143^text
java Hello^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 works and ^1.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
Java Hello Rusty^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 works, but if we type ^0.0^0.0^0.0^0.2^0.0^0.0^5.0^0.4^text
java Hello Elliotte Rusty Harold^0.0^0.0^0.2^0.0^0.0^0.0^5.0^0.0^text
, Java still only prints ^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
Hello Elliotte^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
. Let's fix that. ^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
We're not just limited to two cases though. We can combine an ^0.0^0.0^0.0^0.0^0.0^0.0^12.0^0.6666666666666666^text
else^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 and an ^1.0^0.0^0.0^0.0^0.0^0.0^2.0^1.0^text
if^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 to make an ^0.5^0.0^0.0^0.0^0.0^0.0^3.0^0.6666666666666666^text
else if^0.0^0.0^0.0^1.0^0.0^0.0^2.0^0.0^text
 and use this to test a whole range of mutually exclusive possibilities. For instance here's a version of the Hello program that handles up to four names on the command line:^0.25^0.0^0.0^0.06451612903225806^0.0^0.005649717514124294^31.0^0.4838709677419355^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
// This is the Hello program in Java class Hello { public static void main (String args[]) { /* Now let's say hello */ System.out.print("Hello "); if (args.length == 0) { System.out.print("whoever you are"); } else if (args.length == 1) { System.out.println(args[0]); } else if (args.length == 2) { System.out.print(args[0]); System.out.print(" "); System.out.print(args[1]); } else if (args.length == 3) { System.out.print(args[0]); System.out.print(" "); System.out.print(args[1]); System.out.print(" "); System.out.print(args[2]); } else if (args.length == 4) { System.out.print(args[0]); System.out.print(" "); System.out.print(args[1]); System.out.print(" "); System.out.print(args[2]); System.out.print(" "); System.out.print(args[3]); } else { System.out.print(args[0]); System.out.print(" "); System.out.print(args[1]); System.out.print(" "); System.out.print(args[2]); System.out.print(" "); System.out.print(args[3]); System.out.print(" and all the rest!"); } System.out.println(); } }^6.270833333333333^2.0^0.15492957746478872^0.1056338028169014^0.10190615835777127^0.004398826979472141^142.0^0.07042253521126761^text
 You can see that this gets mighty complicated mighty quickly. Once again no experienced Java programmer would write code like this. One of the things that makes this solution so unwieldy is that I've used a different print statement for every single variable. However Java makes it very easy to print multiple items at once. Instead of including just one thing in the print method's arguments we put multiple items in there separated by + signs. These items can include variables like ^0.0^0.0^0.0^0.04938271604938271^0.0^0.002028397565922921^81.0^0.41975308641975306^text
args[0]^0.0^0.0^1.0^0.0^0.2857142857142857^0.0^1.0^0.0^text
 and constant strings like ^1.0^0.0^0.0^0.0^0.0^0.0^4.0^0.25^text
" and all the rest!"^0.0^0.0^0.0^0.0^0.0^0.05^4.0^0.75^text
. For example the last else block could have been written as^0.0^0.0^0.0^0.18181818181818182^0.0^0.0^11.0^0.5454545454545454^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
else { System.out.print(args[0] + " " + args[1] + " " + args[2] + " " + args[3] + " and all the rest!"); }^0.6666666666666666^0.0^0.3333333333333333^0.08333333333333333^0.11818181818181818^0.07272727272727272^12.0^0.25^text
 This syntax is simpler to read and write but would still be unwieldy once the number of command line arguments grew past ten or so. In the next section we'll see how to handle over two billion command line arguments in a much simpler fashion.^0.0^0.0^0.0^0.022222222222222223^0.0^0.0^45.0^0.5555555555555556^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Exercises^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Rework the entire program to use no more than one print method in each block.^0.0^0.0^0.0^0.0^0.0^0.0^15.0^0.5333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
A truly elegant solution to this problem relies on statements that haven't been introduced yet, notably ^0.0^0.0^0.0^0.0625^0.0^0.0^16.0^0.4375^text
for^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
. However there is a more elegant and space efficient solution that accomplishes everything we did above, does not use the + operator, and uses only ^0.0^0.0^0.0^0.0^0.0^0.006578947368421052^24.0^0.5833333333333334^text
if^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
's and a single ^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.6666666666666666^text
else^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
. No ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
else if^0.0^0.0^0.0^1.0^0.0^0.0^2.0^0.0^text
's are needed. Can you find it?^0.0^0.0^0.0^0.0^0.0^0.03125^6.0^0.8333333333333334^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Variables and Arithmetic Expressions^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.25^text
 We'll begin this section by finding a more elegant way to handle multiple command line arguments of an undetermined number. Toward this end we introduce the concept of a loop. A loop is a section of code that is executed repeatedly until a stopping condition is met. A typical loop may look like:^0.0^0.0^0.0^0.03773584905660377^0.0^0.0032679738562091504^53.0^0.4339622641509434^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
while there's more data { Read a Line of Data Do Something with the Data }^1.0^0.0^0.0^0.14285714285714285^0.024691358024691357^0.0^14.0^0.5^text
 This isn't working code but it does give you an idea of a very typical loop. We have a test condition (Is there more data?) and something we want to do with if the condition is met. (Read a Line of Data and Do Something with the Data.) ^0.0^0.0^0.0^0.08333333333333333^0.016597510373443983^0.004149377593360996^48.0^0.5833333333333334^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
There are many different kinds of loops in Java including ^0.0^0.0^0.0^0.0^0.0^0.0^10.0^0.5^text
while^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
, ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
for^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
, and ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
do while^0.0^0.0^0.0^1.0^0.0^0.0^2.0^0.0^text
 loops. They differ primarily in the stopping conditions used.^0.5^0.0^0.0^0.0^0.0^0.0^9.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
For^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loops typically iterate a fixed number of times and then exit. ^1.0^0.0^0.0^0.0^0.0^0.0^11.0^0.36363636363636365^text
While^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loops iterate continuously until a particular condition is met. You usually do not know in advance how many times a ^0.5^0.0^0.0^0.05^0.0^0.0^20.0^0.45^text
while^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loop will loop. ^1.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
In this case we want to write a loop that will print each of the command line arguments in succession, starting with the first one. We don't know in advance how many arguments there will be, but we can easily find this out before the loop starts using the ^0.0^0.0^0.0^0.08163265306122448^0.0^0.0^49.0^0.5714285714285714^text
args.length^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
. Therefore we will write this with a ^0.0^0.0^0.0^0.14285714285714285^0.0^0.0^7.0^0.7142857142857143^text
for^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loop. Here's the code:^1.0^0.0^0.0^0.0^0.0^0.041666666666666664^4.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
// This is the Hello program in Java class Hello { public static void main (String args[]) { int i; /* Now let's say hello */ System.out.print("Hello "); for (i=0; i < args.length; i = i+1) { System.out.print(args[i]); System.out.print(" "); } System.out.println(); } }^3.8823529411764706^2.0^0.09302325581395349^0.16279069767441862^0.08169014084507042^0.011267605633802818^43.0^0.09302325581395349^text
 We begin the code by declaring our variables. In this case we have exactly one variable, the integer ^0.0^0.0^0.0^0.1111111111111111^0.0^0.0^18.0^0.5^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Then we begin the program by saying "Hello" just like before. ^0.0^0.0^0.0^0.0^0.0^0.0^11.0^0.45454545454545453^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Next comes the ^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.6666666666666666^text
for^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loop. The loop begins by initializing the counter variable ^0.5^0.0^0.0^0.0^0.0^0.0^9.0^0.3333333333333333^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 to be zero. This happens exactly once at the beginning of the loop. Programming tradition that dates back to Fortran insists that loop indices be named ^0.5^0.0^0.0^0.038461538461538464^0.0^0.0^26.0^0.46153846153846156^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
, ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
j^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
, ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
k^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
, ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
l^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
, ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
m^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 and ^0.5^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
n^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 in that order. This is purely a convention and not a feature of the Java language. However anyone who reads your code will expect you to follow this convention. If you choose to violate the convention, try to give your loop variables mnemonic names like ^0.2^0.0^0.0^0.08888888888888889^0.0^0.0^45.0^0.4888888888888889^text
counter^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 or ^0.5^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
loop_index^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Next is the test condition. In this case we test that ^0.0^0.0^0.0^0.18181818181818182^0.0^0.0^11.0^0.5454545454545454^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 is less than the number of arguments. When ^0.5^0.0^0.0^0.0^0.0^0.0^8.0^0.75^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 becomes equal to the number of arguments, (^0.5^0.0^0.0^0.0^0.022222222222222223^0.0^7.0^0.5714285714285714^text
args.length^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
) we exit the loop and go to the first statement after the loop's closing brace. You might think that we should test for ^0.0^0.0^0.0^0.043478260869565216^0.008064516129032258^0.0^23.0^0.6086956521739131^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 being less than or equal to the number of arguments; but remember that we began counting at zero, not one.^0.3333333333333333^0.0^0.0^0.0^0.009174311926605505^0.0^20.0^0.65^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Finally we have the increment step, ^0.0^0.0^0.0^0.16666666666666666^0.0^0.0^6.0^0.5^text
i=i+1^0.0^0.0^0.0^0.0^0.0^0.4^2.0^0.0^text
. This is executed at the end of each iteration of the loop. Without this we'd continue to loop forever since ^0.0^0.0^0.0^0.15^0.0^0.0^20.0^0.55^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 would always be less than ^0.5^0.0^0.0^0.0^0.0^0.0^5.0^1.0^text
args.length^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
. (unless, of course, ^0.0^0.0^0.0^0.0^0.043478260869565216^0.0^3.0^0.3333333333333333^text
args.length^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
 were less than or equal to zero. When would this happen?).^0.5^0.0^0.0^0.09090909090909091^0.01639344262295082^0.01639344262295082^11.0^0.6363636363636364^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Sidebar: Why Algebra teachers hate Basic and aren't that fond of C^0.0^0.0^0.0^0.0^0.0^0.014925373134328358^12.0^0.4166666666666667^text
 The statement ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
i=i+1^0.0^0.0^0.0^0.0^0.0^0.4^2.0^0.0^text
 drives algebra teachers up the wall. It's an invalid assertion. There isn't a number in the world for which the statement i=i+1 is true. In fact if you subtract i from both sides of that equation you get the patently false statement that ^0.16666666666666666^0.0^0.0^0.045454545454545456^0.0^0.00816326530612245^44.0^0.5^text
0=1^0.0^0.0^0.0^0.0^0.0^0.2^0.0^0.0^text
. The trick here is that the symbol = does not imply equality. That is reserved for the double equals sign, ==. In almost all programming languages including Java a single equals sign is the assignment operator. ^0.0^0.0^0.0^0.058823529411764705^0.0^0.009174311926605505^34.0^0.4411764705882353^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The notable exceptions are Pascal (and the Pascal derivatives Modula-2, Modula-3 and Oberon), Ada, and Eiffel where ^0.0^0.0^0.0^0.0^0.01680672268907563^0.0^17.0^0.4117647058823529^text
=^0.0^0.0^0.0^0.0^0.0^1.0^0.0^0.0^text
 does in fact mean equality and where ^0.5^0.0^0.0^0.0^0.0^0.0^7.0^0.42857142857142855^text
:= ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
is the assignment operator. Math teachers are very fond of their equal sign and don't like to see it abused. This is one reason why Pascal is still the most popular language for teaching programming, especially in schools where the Computer Science department is composed mainly of math professors.^0.0^0.0^0.0^0.061224489795918366^0.0^0.0^49.0^0.46938775510204084^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Needless to say math professors hate languages like Basic where, depending on context, = can mean either assignment or equality.^0.0^0.0^0.0^0.0^0.0^0.007692307692307693^19.0^0.3157894736842105^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Exercises^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
What happens now if we don't give the Hello program any command line arguments? We aren't testing the number of command line arguments anymore so why isn't an ArrayIndexOutOfBoundsException thrown?^0.0^0.0^0.03333333333333333^0.06666666666666667^0.0^0.010050251256281407^30.0^0.4666666666666667^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
For math whizzes only: I lied. In certain interpretations of certain number systems the statement ^0.0^0.0^0.0^0.06666666666666667^0.0^0.01020408163265306^15.0^0.26666666666666666^text
i = i + 1^0.0^0.0^0.0^0.0^0.0^0.2222222222222222^2.0^0.0^text
 does have a valid solution for ^1.0^0.0^0.0^0.16666666666666666^0.0^0.0^6.0^0.3333333333333333^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
. What is it?^0.0^0.0^0.0^0.0^0.0^0.07692307692307693^3.0^1.0^text
 ^0.5^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Classes and Objects: A First Look^0.0^0.0^0.0^0.0^0.0^0.030303030303030304^6.0^0.5^text
 Classes are the single most important feature of Java. Everything in Java is either a class, a part of a class, or describes how a class behaves. Although classes will be covered in great detail in section four, they are so fundamental to an understanding of Java programs that a brief introduction is going to be given here.^0.0^0.0^0.0^0.05172413793103448^0.0^0.0^58.0^0.603448275862069^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
All the action in Java programs takes place inside class blocks, in this case the HelloWorld class. In Java almost everything of interest is either a class itself or belongs to a class. Methods are defined inside the classes they belong to. This may be a little confusing to C++ programmers who are used to defining all but the simplest methods outside the class block, but this approach is really more sensible. C++ takes the road it does primarily out of desire to be compatible with C, not out of good object-oriented design. Both syntactically and logically everything in Java happens inside a class.^0.0^0.0^0.009523809523809525^0.09523809523809523^0.0^0.0032258064516129032^105.0^0.45714285714285713^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Even basic data primitives like integers often need to be incorporated into classes before you can do many useful things with them. The class is the fundamental unit of Java programs, not source code files like in C. For instance consider the following Java program:^0.0^0.0^0.0^0.06666666666666667^0.0^0.003663003663003663^45.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class HelloWorld { public static void main (String args[]) { System.out.println("Hello World"); } } class GoodbyeWorld { public static void main (String args[]) { System.out.println("Goodbye Cruel World!"); } }^0.8421052631578947^0.0^0.2222222222222222^0.2962962962962963^0.08695652173913043^0.003952569169960474^27.0^0.0^text
 Save this code in a single file called hellogoodbye.java in your javahtml directory, and compile it with the command ^0.0^0.0^0.1^0.05^0.0^0.0^20.0^0.4^text
javac hellogoodbye.java^0.0^0.0^0.6666666666666666^0.0^0.0^0.0^3.0^0.0^text
. Then list the contents of the directory. You will see that the compiler has produced two separate class files, HelloWorld.class and GoodbyeWorld.class. ^0.0^0.0^0.08333333333333333^0.125^0.0^0.0^24.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The second class is a completely independent program. Type ^0.0^0.0^0.0^0.1111111111111111^0.0^0.0^9.0^0.3333333333333333^text
java GoodbyeWorld^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
 and then type ^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.6666666666666666^text
java HelloWorld^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
. These programs run and execute independently of each other although they exist in the same source code file. Off the top of my head I can't think of why you might want two separate programs in the same file, but if you do the capability is there.^0.0^0.0^0.0^0.0425531914893617^0.0^0.0^47.0^0.5957446808510638^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
It's more likely that you'll want more than one class in the same file. In fact you'll see source code files with many classes and methods.^0.0^0.0^0.0^0.038461538461538464^0.0^0.0^26.0^0.6153846153846154^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
In fact there are a few statements that can, at least at first glance, appear outside a class. Import statements appear at the start of a file outside of any classes. However the compiler replaces them with the contents of the imported file which consists of, you guessed it, more classes.^0.0^0.0^0.0^0.0392156862745098^0.0^0.0^51.0^0.5882352941176471^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Interfaces^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Like we said, Java source is really just classes. Import statements are shorthand for many different classes; and comments aren't really there (as far as the compiler is concerned) in the first place. However there is one thing in Java source code that is neither a class nor a member of a class. That's an ^0.0^0.0^0.0^0.07272727272727272^0.009523809523809525^0.0^55.0^0.5272727272727272^text
interface^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
. We're not going to say much about interfaces yet since that's a subject for a more advanced chapter. However we will note that an interface defines methods that a class implements. In other words it declares what certain classes ^0.0^0.0^0.0^0.10256410256410256^0.0^0.0^39.0^0.5641025641025641^text
do^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
. However an interface itself ^0.0^0.0^0.0^0.25^0.0^0.0^4.0^0.75^text
does^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 nothing. All the ^0.5^0.0^0.0^0.0^0.0^0.0^3.0^1.0^text
action^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 at least, happens inside classes.^1.0^0.0^0.0^0.0^0.0^0.0^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
FahrToCelsius^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 Java is not just used for the World Wide Web. The next program demonstrates a classic use of computers that goes back to the earliest punch card machines. It's reminiscent of some of the very first useful programs I ever wrote. These were designed to quickly calculate several dozen numbers to keep me from having to do them by hand in physics lab. It's also borrowed directly from Kernighan and Ritchie.^0.0^0.0^0.0^0.028169014084507043^0.0^0.0^71.0^0.49295774647887325^text
 ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
// Print a Fahrenheit to Celsius table class FahrToCelsius { public static void main (String args[]) { int fahr, celsius; int lower, upper, step; lower = 0; // lower limit of temperature table upper = 300; // upper limit of temperature table step = 20; // step size fahr = lower; while (fahr <= upper) { // while loop begins here celsius = 5 * (fahr-32) / 9; System.out.print(fahr); System.out.print(" "); System.out.println(celsius); fahr = fahr + step; } // while loop ends here } // main ends here } //FahrToCelsius ends here ^1.6666666666666667^8.0^0.15492957746478872^0.1267605633802817^0.05073649754500818^0.016366612111292964^71.0^0.11267605633802817^text
 This program calculates the Celsius equivalent of Fahrenheit temperatures between zero and three hundred degrees. The first two lines of the main method ^0.0^0.0^0.0^0.043478260869565216^0.0^0.0^23.0^0.4782608695652174^text
declare^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 the variables we'll use. That is they specify the names and the types. For now we use only integers. In Java an ^0.3333333333333333^0.0^0.0^0.045454545454545456^0.0^0.0^22.0^0.5909090909090909^text
int^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 can have a value between -2,147,483,648 to 2,147,483,647. More types will be forthcoming. ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^11.0^0.7272727272727273^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Then we initialize the variables using statements like "^0.0^0.0^0.0^0.0^0.0^0.0^8.0^0.375^text
lower = 0^0.0^0.0^0.0^0.0^0.0^0.1111111111111111^1.0^0.0^text
". This sets ^0.0^0.0^0.0^0.5^0.0^0.0^2.0^0.0^text
lower^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
's initial value to 0. When used this way the equals sign is called the ^0.0^0.0^0.0^0.07692307692307693^0.0^0.0^13.0^0.38461538461538464^text
assignment operator^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
. ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
After establishing the initial values for all our variables we go into the loop which does the main work of our program. At the beginning of each iteration of the loop ^0.0^0.0^0.0^0.03225806451612903^0.0^0.0^31.0^0.5806451612903226^text
(fahr <= upper)^0.0^0.0^0.5^0.0^0.13333333333333333^0.06666666666666667^2.0^0.0^text
 checks to see if the value of ^0.5^0.0^0.0^0.14285714285714285^0.0^0.0^7.0^0.5714285714285714^text
fahr^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 is in fact less than or equal to the current value of ^0.0^0.0^0.0^0.0^0.0^0.0^12.0^0.6666666666666666^text
upper^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
. If it is then the computer executes the statements in the loop block (everything between "while loop begins here" and "while loop ends here".) Loops in Java are marked off by matching pairs of braces and may be nested. ^0.0^0.0^0.0^0.07692307692307693^0.008695652173913044^0.0^39.0^0.5384615384615384^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
celsius = 5 * (fahr-32) / 9;^0.0^0.0^0.5^0.0^0.10714285714285714^0.10714285714285714^2.0^0.0^text
 actually calculates the Celsius temperature given the fahrenheit temperature. The arithmetic operators here do exactly what you'd expect. * means multiplication. - is subtraction. / is division; and +, though not used in here, is addition. Precedence follows normal algebraic conventions, and can be rearranged through parentheses.^0.2^0.0^0.0^0.023255813953488372^0.002967359050445104^0.008902077151335312^43.0^0.4186046511627907^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Java contains an almost complete set of arithmetic operators. Like C it is missing an exponentiation operator. For exponentiation you need to use the pow methods in the java.lang.Math package.^0.0^0.0^0.0625^0.0625^0.0^0.0^32.0^0.34375^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Printing output is very similar to what you've seen before. We use ^0.0^0.0^0.0^0.0^0.0^0.0^12.0^0.5833333333333334^text
System.out.print(fahr)^0.0^0.0^0.25^0.0^0.09090909090909091^0.0^4.0^0.0^text
 to print the fahrenheit value, then ^0.5^0.0^0.0^0.0^0.0^0.0^6.0^0.5^text
System.out.print(" ")^0.0^0.0^0.0^0.0^0.09090909090909091^0.0^3.0^0.0^text
 to print a one-character string containing a space, and finally ^0.5^0.0^0.0^0.09090909090909091^0.0^0.0^11.0^0.45454545454545453^text
System.out.println(celsius);^0.0^0.0^0.25^0.0^0.10714285714285714^0.0^4.0^0.0^text
 the Celsius value.^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Finally we increment the value of ^0.0^0.0^0.0^0.16666666666666666^0.0^0.0^6.0^0.5^text
fahr^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 by ^0.5^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
step^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 to move on to the next value in the table. ^0.5^0.0^0.0^0.0^0.0^0.0^10.0^0.8^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Floating Point Variables^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
You may have noticed something a little funny about the above output. The numbers aren't exactly correct. Zero degrees Fahrenheit is actually -17.778 degrees Celsius, not -18 degrees Celsius as this program reports. The problem is that we used only integers here, not decimal numbers. In computer-speak decimal numbers are called "floating point numbers."^0.0^0.0^0.0^0.018867924528301886^0.0^0.0^53.0^0.4339622641509434^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Floating point numbers can represent a broader range of values than integers. For example you can write very large numbers like the speed of light (2.998E8 meters per second) and very small numbers like Plank's constant (6.63E-27 ) using the same number of digits. On the other hand you lose some precision that you probably didn't need for such large and small numbers anyway. ^0.0^0.0^0.031746031746031744^0.031746031746031744^0.010362694300518135^0.0^63.0^0.3968253968253968^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Some languages have a third kind of number called a fixed point number. This number has a set precision, for instance two decimal places, and is often useful in monetary calculations. Java has no fixed point data type.^0.0^0.0^0.0^0.05263157894736842^0.0^0.0^38.0^0.39473684210526316^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Using floating point numbers is no harder than using integers. We can make our Fahrenheit to Celsius program more accurate merely by changing all our ^0.0^0.0^0.0^0.0^0.0^0.0^25.0^0.44^text
int^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 variables into ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
double^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 variables.^1.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
// Print a more accurate Fahrenheit to Celsius table class FahrToCelsius { public static void main (String args[]) { double fahr, celsius; double lower, upper, step; lower = 0.0; // lower limit of temperature table upper = 300.0; // upper limit of temperature table step = 20.0; // step size fahr = lower; while (fahr <= upper) { // while loop begins here celsius = 5.0 * (fahr-32.0) / 9.0; System.out.print(fahr); System.out.print(" "); System.out.println(celsius); fahr = fahr + step; } // while loop ends here } // main ends here } //FahrToCelsius ends here ^2.68^8.0^0.1506849315068493^0.1232876712328767^0.046130952380952384^0.01488095238095238^73.0^0.1232876712328767^text
 I've made one further change to the Fahrenheit to Celsius program. All the integer constants in the program like ^0.0^0.0^0.0^0.0^0.0^0.0^19.0^0.5263157894736842^text
5^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 and ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
9^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 have become ^1.0^0.0^0.0^0.0^0.0^0.0^2.0^1.0^text
5.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 and ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
9.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 and so on. If a constant number includes a decimal point, then the compiler assumes it's a double precision floating point number. If it doesn't then the compiler assumes it's an integer. However when two numbers of different types such as integer and floating point are involved in a calculation ^0.0^0.0^0.0^0.06^0.0^0.0^50.0^0.48^text
on the right hand side of an equation^0.0^0.0^0.0^0.0^0.0^0.0^8.0^0.625^text
, the compiler ^0.5^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
promotes^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 the number of the weaker type to the stronger type before doing the calculation. ^1.0^0.0^0.0^0.0^0.0^0.0^14.0^0.5^text
 What makes one type of number stronger than another? It's the ability to represent a broader spectrum of numbers. Since a byte can only represent 256 numbers it's weaker than a short which can stand for 65,535 different numbers including all the numbers a byte can represent. Similarly an ^0.0^0.0^0.0^0.0851063829787234^0.0^0.003389830508474576^47.0^0.5106382978723404^text
int^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 is stronger than a ^1.0^0.0^0.0^0.0^0.0^0.0^4.0^0.75^text
short^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
. Floating point numbers are stronger than any integer type and doubles are the strongest type of all.^0.6666666666666666^0.0^0.0^0.0^0.0^0.0^17.0^0.47058823529411764^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Therefore we could have left all the small constants as integers and the program output would have been unchanged. However it is customary to put in decimal points to remind yourself and anyone else who may be unlucky enough to have to read your code, exactly what is going on.^0.0^0.0^0.0^0.02^0.0^0.0^50.0^0.66^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
This applies to calculations that take place on the right hand side of an equal sign. The left hand side of the equals sign is a different story. In fact it's so different that programmers have given the different sides of the equals sign special names. The left-hand side is called an ^0.0^0.0^0.0^0.018867924528301886^0.0^0.0^53.0^0.49056603773584906^text
lvalue^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 while the right hand side is called an ^1.0^0.0^0.0^0.125^0.0^0.0^8.0^0.5^text
rvalue^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
. ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
An rvalue is a calculated result and as specified above it takes on the strongest type of any number involved in the calculation. On the other hand the lvalue has a type that must be defined before it is used. That's what all those ^0.0^0.0^0.045454545454545456^0.0^0.0^0.0^44.0^0.6590909090909091^text
float fahr, celsius;^0.0^0.0^0.3333333333333333^0.3333333333333333^0.05^0.0^3.0^0.0^text
 statements are doing. Once the type of an lvalue is defined it never changes. Thus if we declare ^0.5^0.0^0.05555555555555555^0.05555555555555555^0.0^0.0^18.0^0.5555555555555556^text
fahr^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 to be an ^1.0^0.0^0.0^0.0^0.0^0.0^3.0^1.0^text
int^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
, then on the left hand side of an equals sign ^0.0^0.0^0.0^0.0^0.0^0.0^10.0^0.6^text
fahr^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 will always be an ^1.0^0.0^0.0^0.0^0.0^0.0^4.0^1.0^text
int^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
, never a ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^1.0^text
float^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 or a ^1.0^0.0^0.0^0.0^0.0^0.0^2.0^1.0^text
double^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 or a ^1.0^0.0^0.0^0.0^0.0^0.0^2.0^1.0^text
long^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
If you've been following along you may notice a problem here. What if the type on the left doesn't match the type on the right? e.g. what happens with code like the following?^0.0^0.0^0.0^0.058823529411764705^0.0^0.011111111111111112^34.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class FloatToInt { public static void main (String args[]) { int myInteger; myInteger = 9.7; } // main ends here } //FloatToInt ends here ^1.0909090909090908^2.0^0.29411764705882354^0.29411764705882354^0.060240963855421686^0.006024096385542169^17.0^0.11764705882352941^text
 Two things can happen. If, as above, we're trying to move a number into a weaker type of variable, the compiler generates an error. On the other hand if we're trying to move a weaker type into a stronger type then the compiler converts it to the stronger type. For instance the following code is legal:^0.0^0.0^0.0^0.05357142857142857^0.0^0.003205128205128205^56.0^0.5178571428571429^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class IntToFloat { public static void main (String args[]) { float myFloat; int myInteger; myInteger = 9; myFloat = myInteger; System.out.println(myFloat); } // main ends here } //IntToFloat ends here ^1.7142857142857142^2.0^0.4^0.24^0.06097560975609756^0.008130081300813009^25.0^0.08^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Exercises^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Have the FahrToCelsius program print a heading above the table. ^0.0^0.0^0.1^0.0^0.0^0.0^10.0^0.5^text
Write a similar program to convert Celsius to Fahrenheit. ^0.0^0.0^0.0^0.0^0.0^0.0^9.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The For Statement^0.0^0.0^0.0^0.3333333333333333^0.0^0.0^3.0^0.3333333333333333^text
 Java isn't as redundant as perl, but there's still almost always more than one way to write any given program. The following program produces identical output to the Fahrenheit to Celsius program in the preceding section. The main difference is the ^0.0^0.0^0.024390243902439025^0.0^0.0^0.0^41.0^0.5365853658536586^text
for^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loop instead of a ^1.0^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
while^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loop.^1.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
// Print a Fahrenheit to Celsius table class FahrToCelsius { public static void main (String args[]) { int fahr, celsius; int lower, upper, step; lower = 0; // lower limit of temperature table upper = 300; // upper limit of temperature table step = 20; // step size for (fahr=lower; fahr <= upper; fahr = fahr + step) { celsius = 5 * (fahr-32) / 9; System.out.println(fahr + " " + celsius); } // for loop ends here } // main ends here }^2.1904761904761907^6.0^0.1724137931034483^0.13793103448275862^0.04780114722753346^0.022944550669216062^58.0^0.10344827586206896^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 The only difference between this program and the previous one is that here we've used a ^0.0^0.0^0.0^0.0625^0.0^0.0^16.0^0.6875^text
for^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loop instead of a ^1.0^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
while^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loop. The ^1.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
for^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loop has identical syntax to C's ^1.0^0.0^0.0^0.0^0.0^0.0^6.0^0.3333333333333333^text
for^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loops. i.e. ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 for (initialization; test; increment) ^2.0^0.0^0.0^0.25^0.1^0.0^4.0^0.0^text
 The initialization, in this case setting the variable ^0.0^0.0^0.0^0.25^0.0^0.0^8.0^0.375^text
fahr^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 equal to the lower limit, happens the first time the loop is entered and only the first time. Then the first time and every time after that when control reaches the top of the loop a test is made. In our example the test is whether the variable ^0.2^0.0^0.0^0.0^0.0^0.0^48.0^0.6458333333333334^text
fahr^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 is less than or equal to the upper limit. If it is we execute the code in the loop one more time. If not we begin executing the code that follows the loop. Finally at the end of each loop the increment step is made. In this case we increase ^0.2^0.0^0.0^0.1^0.0^0.0^50.0^0.56^text
fahr^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 by ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
step^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
If that's unclear let's look at a simpler example:^0.0^0.0^0.0^0.1111111111111111^0.0^0.02^9.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Count to ten class CountToTen { public static void main (String args[]) { int i; for (i=1; i <=10; i = i + 1) { System.out.println(i); } System.out.println("All done!"); } }^1.7333333333333334^1.0^0.14814814814814814^0.2222222222222222^0.09375^0.022321428571428572^27.0^0.14814814814814814^text
 This program prints out the numbers from one to ten. It begins by setting the variable ^0.0^0.0^0.0^0.0625^0.0^0.0^16.0^0.5^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 to 1. Then it checks to see if one is in fact less than or equal to ten. Since one is less than ten, the program prints it. Finally it adds one to ^0.5^0.0^0.0^0.0625^0.0^0.0^32.0^0.75^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 and starts over. ^0.5^0.0^0.0^0.0^0.0^0.0^3.0^0.6666666666666666^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 is now 2. The program checks to see if 2 is less than 10. It is! so the program prints "2" and adds one to ^0.5^0.0^0.0^0.047619047619047616^0.0^0.009009009009009009^21.0^0.7142857142857143^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 again. ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 is now three. Once again the code checks to see that 3 is less than or equal to 10. This is getting rather boring rather quickly. Fortunately computers don't get bored, and very soon computer has counted to the point where ^0.0^0.0^0.0^0.05128205128205128^0.0^0.0^39.0^0.6410256410256411^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 is now ten. The computer prints "10" and adds one to ten. Now ^0.5^0.0^0.0^0.0^0.0^0.0^12.0^0.8333333333333334^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 is eleven. Eleven is not less than or equal to ten so the computer does not print it. Rather it moves to the next statement after the end of the for loop, ^0.3333333333333333^0.0^0.0^0.03125^0.0^0.0^32.0^0.75^text
System.out.println("All done!);^0.0^0.0^0.2^0.0^0.0967741935483871^0.03225806451612903^5.0^0.4^text
. The computer prints "All Done!" and the program ends.^0.0^0.0^0.0^0.0^0.0^0.017857142857142856^9.0^0.6666666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
For loops do not always work this smoothly. For instance consider the following program:^0.0^0.0^0.0^0.2857142857142857^0.0^0.011235955056179775^14.0^0.21428571428571427^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Count to ten?? class BuggyCountToTen { public static void main (String args[]) { int i; for (i=1; i <=10; i = i - 1) { System.out.println(i); } System.out.println("All done!"); } }^1.7333333333333334^1.0^0.14814814814814814^0.2222222222222222^0.09090909090909091^0.017316017316017316^27.0^0.14814814814814814^text
 This program counts backwards. There's nothing fundamentally wrong with a program counting backwards, but we're testing for ^0.0^0.0^0.0^0.11764705882352941^0.0^0.0^17.0^0.35294117647058826^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 being bigger than ten. Since ^1.0^0.0^0.0^0.0^0.0^0.0^5.0^0.8^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 is never going to be bigger than ten in this program, the program never stops. (That's not completely true. If you have a very fast machine or you wait long enough somewhere below negative two billion ^0.0^0.0^0.0^0.08333333333333333^0.0048543689320388345^0.0^36.0^0.5833333333333334^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 will suddenly become a very large positive number and the program will halt. This happens because of vagaries in computer arithmetic we'll discuss later. Nonetheless this is still almost certainly a bug. If you don't want to wait for that to happen just type ^0.16666666666666666^0.0^0.0^0.11363636363636363^0.0^0.0^44.0^0.45454545454545453^text
Control-C^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 to abort the program. This sort of behavior is referred to as an infinite loop and is a more common programming error than you might think.^0.0^0.0^0.0^0.038461538461538464^0.0^0.0^26.0^0.5384615384615384^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Assignment, Increment and Decrement Operators^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.2^text
 In reality almost nobody writes ^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.6^text
for^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loops like we did in the previous sections. They would almost certainly use the increment or decrement operators instead. There are two of these, ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^24.0^0.5416666666666666^text
++^0.0^0.0^0.0^0.0^0.0^0.5^0.0^0.0^text
 and ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
--^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 and they work like this.^1.0^0.0^0.0^0.2^0.0^0.0^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Count to ten class CountToTen { public static void main (String args[]) { int i; for (i=1; i <=10; i++) { System.out.println(i); } System.out.println("All done!"); } }^1.7142857142857142^1.0^0.15384615384615385^0.23076923076923078^0.09813084112149532^0.018691588785046728^26.0^0.15384615384615385^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Count to ten?? class BuggyCountToTen { public static void main (String args[]) { int i; for (i=1; i <=10; i--) { System.out.println(i); } System.out.println("All done!"); } }^1.8571428571428572^1.0^0.15384615384615385^0.23076923076923078^0.09417040358744394^0.013452914798206279^26.0^0.15384615384615385^text
 When we write ^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.6666666666666666^text
i++^0.0^0.0^0.0^0.0^0.0^0.3333333333333333^1.0^0.0^text
 we're using shorthand for ^1.0^0.0^0.0^0.25^0.0^0.0^4.0^0.25^text
i = i + 1^0.0^0.0^0.0^0.0^0.0^0.2^2.0^0.0^text
. When we say ^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.6666666666666666^text
i--^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 we're using shorthand for ^0.5^0.0^0.0^0.25^0.0^0.0^4.0^0.25^text
i = i - 1^0.0^0.0^0.0^0.0^0.0^0.1111111111111111^2.0^0.0^text
. Adding and subtracting one from a number are such common operations that these special ^0.0^0.0^0.0^0.0^0.0^0.0^14.0^0.5714285714285714^text
increment^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 and ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
decrement^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 operators have been added to the language. They also allow the compiler to be smarter about certain optimizations on some CPU architectures, but mainly they make code easier to write and read.^0.25^0.0^0.03125^0.0^0.0^0.0^32.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
However what do you do when you want to increment not by one but by two? or three? or fifteen? We could of course write ^0.0^0.0^0.0^0.08^0.0^0.024793388429752067^25.0^0.76^text
i = i + 15^0.0^0.0^0.0^0.0^0.0^0.18181818181818182^2.0^0.0^text
 but this happens frequently enough that there's another short hand for the general add and assign operation, ^0.3333333333333333^0.0^0.0^0.17647058823529413^0.0^0.0^17.0^0.4117647058823529^text
+=^0.0^0.0^0.0^0.0^0.0^0.5^0.0^0.0^text
. We would normally write this as ^0.0^0.0^0.0^0.16666666666666666^0.0^0.0^6.0^0.5^text
i += 15^0.0^0.0^0.0^0.0^0.0^0.125^1.0^0.0^text
. Thus if we wanted to count from 0 to 20 by two's we'd write:^0.0^0.0^0.0^0.08333333333333333^0.0^0.015625^12.0^0.6666666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class CountToTwentyByTwos { public static void main (String args[]) { int i; for (i=0; i <=20; i += 2) { System.out.println(i); } System.out.println("All done!"); } //main ends here }^2.0833333333333335^1.0^0.15384615384615385^0.23076923076923078^0.09292035398230089^0.017699115044247787^26.0^0.11538461538461539^text
 As you might guess there is a corresponding ^0.0^0.0^0.0^0.0^0.0^0.0^8.0^0.75^text
-=^0.0^0.0^0.0^0.0^0.0^0.5^0.0^0.0^text
 operator. If we wanted to count down from twenty to zero by twos we could write:^0.5^0.0^0.0^0.0625^0.0^0.012048192771084338^16.0^0.5625^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class CountToZeroByTwos { public static void main (String args[]) { int i; for (i=20; i >= 0; i -= 2) { System.out.println(i); } System.out.println("All done!"); } }^2.1666666666666665^0.0^0.17391304347826086^0.2608695652173913^0.10047846889952153^0.019138755980861243^23.0^0.08695652173913043^text
 You should note that we also had to change the initialization and test components of the ^0.0^0.0^0.0^0.0^0.0^0.0^16.0^0.6875^text
for^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loop to count down instead of up.^1.0^0.0^0.0^0.0^0.0^0.0^7.0^0.5714285714285714^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
There are also ^0.0^0.0^0.0^0.0^0.0^0.0^3.0^1.0^text
*=^0.0^0.0^0.0^0.0^0.0^0.5^0.0^0.0^text
 and ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
/=^0.0^0.0^0.0^0.0^0.0^0.5^0.0^0.0^text
 operators that multiply and divide by their right hand sides before assigning. In practice you almost never see these because of the speed at which variables making use of them go to either zero or Inf. If you don't believe me consider the following cautionary tale.^0.16666666666666666^0.0^0.021739130434782608^0.043478260869565216^0.0^0.0^46.0^0.5434782608695652^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Many centuries ago in India a very smart man is said to have invented the game of chess. This game greatly amused the king, and he became so enthralled with it that he offered to reward the inventor with anything he wished, up to half his kingdom and his daughter's hand in marriage.^0.0^0.0^0.0^0.018867924528301886^0.0^0.0^53.0^0.5471698113207547^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Now the inventor of the game of chess was quite intelligent and not a little greedy. Not being satisfied with merely half the kingdom, he asked the king for the following gift:^0.0^0.0^0.0^0.03125^0.0^0.00558659217877095^32.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
"Mighty King," he said, "I am but a humble man and would not know what to do with half of your kingdom. Let us merely calculate my prize as follows. Put onto the first square of the chessboard a single grain of wheat. Then onto the second square of the chessboard two grains, and onto the third square of the chessboard twice two grains, and so on until we have covered the board with wheat."^0.125^0.0^0.0^0.013333333333333334^0.0^0.0^75.0^0.5866666666666667^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Upon hearing this the king was greatly pleased for he felt he had gotten off rather cheaply. He rapidly agreed to the inventor's prize. He called for a bag of wheat to be brought to him, and when it arrived he began counting out wheat. However he soon used up the first bag and was not yet halfway across the board. He called for a second, and a third, and more and more, until finally he was forced to admit defeat and hand over his entire kingdom for lack of sufficient wheat with which to pay the inventor.^0.0^0.0^0.0^0.061224489795918366^0.0^0.0^98.0^0.5510204081632653^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
How much wheat did the king need? Let's try to calculate it. Although we won't use physical wheat, we will soon find ourselves in the same dire straits as the king. Remember that a chessboard has 64 squares.^0.25^0.0^0.0^0.02702702702702703^0.0^0.004739336492890996^37.0^0.5135135135135135^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class CountWheat { public static void main (String args[]) { int i, j, k; j = 1; k = 0; for (i=1; i <= 64; i++) { k += j; System.out.println(k); j *= 2; } System.out.println("All done!"); } }^2.526315789473684^0.0^0.13333333333333333^0.2^0.09433962264150944^0.03018867924528302^30.0^0.06666666666666667^text
 We can improve our results slightly (but only slightly) by changing our ints to longs like so:^0.0^0.0^0.058823529411764705^0.0^0.02040816326530612^0.01020408163265306^17.0^0.5294117647058824^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class CountWheat { public static void main (String args[]) { long i, j, k; j = 1; k = 0; for (i=1; i <= 64; i++) { k += j; System.out.println(k); j *= 2; } System.out.println("All done!"); } }^2.526315789473684^0.0^0.13333333333333333^0.2^0.09433962264150944^0.03018867924528302^30.0^0.06666666666666667^text
 A long is an integer type variable that can hold up to 9,223,372,036,854,775,807. However even that isn't enough to count how much wheat the king owed. Let's try using a double instead, the largest type of all. ^0.0^0.0^0.0^0.08333333333333333^0.0^0.0^36.0^0.5555555555555556^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class CountWheat { public static void main (String args[]) { int i; double j, k; j = 1.0; k = 0.0; for (i=1; i <= 64; i++) { k += j; System.out.println(k); j *= 2; } System.out.println("All done!"); } }^2.0^0.0^0.12903225806451613^0.22580645161290322^0.09701492537313433^0.029850746268656716^31.0^0.06451612903225806^text
 A double can hold a number as large as 1.79769313486231570e+308. That turns out to be large enough to count the king's debt which comes to 1.84467e+019 grains of wheat, give or take a few billion grains. That's a lot of wheat.^0.0^0.0^0.04878048780487805^0.024390243902439025^0.0^0.008658008658008658^41.0^0.5365853658536586^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Exercises^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Would a float be big enough to count how many grains of wheat the king owes?^0.0^0.0^0.0^0.0625^0.0^0.013157894736842105^16.0^0.5625^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Why isn't there a ** or a // operator? ^0.0^1.0^0.0^0.0^0.0^0.02564102564102564^7.0^0.8571428571428571^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Methods^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 All the programs we've written to date have been quite simple, well under fifty lines of code each. As programs grow in size it begins to make sense to break them into parts. Each part can perform a particular calculation and possibly return a value. This is especially useful when the calculation needs to be repeated at several different places in the program. It also helps to define a clearer picture of the flow of the program, much like an outline shows the flow of a book. ^0.0^0.0^0.0^0.034482758620689655^0.0^0.0^87.0^0.5172413793103449^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Each ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
calculation part^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
 of a program is called a method. Methods are logically the same as C's functions, Pascal's procedures and functions, and Fortran's functions and subroutines.^0.5^0.0^0.0^0.0^0.0^0.0^24.0^0.4583333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The above programs have already used a number of methods although these were all methods provided by the system. When we wrote ^0.0^0.0^0.0^0.0^0.0^0.0^22.0^0.6363636363636364^text
System.out.println("Hello World!");^0.0^0.0^0.2^0.0^0.08571428571428572^0.02857142857142857^5.0^0.0^text
 in the first program we were using the ^0.5^0.0^0.0^0.0^0.0^0.0^8.0^0.75^text
System.out.println()^0.0^0.0^0.3333333333333333^0.0^0.1^0.0^3.0^0.0^text
 method. (To be more precise we were using the ^0.3333333333333333^0.0^0.0^0.0^0.0196078431372549^0.0^9.0^0.6666666666666666^text
println()^0.0^0.0^1.0^0.0^0.2222222222222222^0.0^1.0^0.0^text
 method of the ^1.0^0.0^0.0^0.0^0.0^0.0^3.0^0.6666666666666666^text
out^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 member of the ^1.0^0.0^0.0^0.0^0.0^0.0^3.0^0.6666666666666666^text
System^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 class, but we'll talk more about that in Chapter 4.) The ^1.0^0.0^0.0^0.1^0.01694915254237288^0.0^10.0^0.7^text
System.out.println()^0.0^0.0^0.3333333333333333^0.0^0.1^0.0^3.0^0.0^text
 method actually requires quite a lot of code, but it is all stored for us in the System libraries. Thus rather than including that code every time we need to print, we just call the ^0.0^0.0^0.0^0.02857142857142857^0.0^0.0^35.0^0.5428571428571428^text
System.out.println()^0.0^0.0^0.3333333333333333^0.0^0.1^0.0^3.0^0.0^text
 method.^1.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
You can write and call your own methods too. Let's look at a simple example. Java has no built-in factorial method so we'll write one. The following is a simple program that requests a number from the user and then calculates the factorial of that number. ^0.0^0.0^0.0^0.0^0.0^0.0^47.0^0.574468085106383^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
We'll use two methods in the program, one that checks to see if the user has in fact entered a valid positive integer, and another that calculates the factorial. However we'll start by writing the main method of the program:^0.0^0.0^0.0^0.025^0.0^0.004405286343612335^40.0^0.55^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class Factorial { public static void main(String args[]) { int n; while ((n = getNextInteger()) >= 0) { System.out.println(factorial(n)); } } // main ends here }^1.6923076923076923^1.0^0.14285714285714285^0.2857142857142857^0.10945273631840796^0.009950248756218905^21.0^0.047619047619047616^text
 Among other things this code demonstrates that methods make it possible to design the flow of a program without getting bogged down in the details. We've simply named two methods, getNextInteger() and factorial() without worrying about their exact implementations. We can add the rest of the code in smaller, easier-to-understand pieces. Let's write the factorial method first.^0.0^0.0^0.01694915254237288^0.01694915254237288^0.01038961038961039^0.0^59.0^0.4576271186440678^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
long factorial (long n) { int i; long result=1; for (i=1; i <= n; i++) { result *= i; } return result; } // factorial ends here ^1.3076923076923077^1.0^0.0^0.3^0.08695652173913043^0.031055900621118012^20.0^0.05^text
 We could have included this code in our main method, but the algorithm is much easier to understand by breaking the code into smaller, more manageable pieces. It's also easier to test and debug. We can write a simple program that lets us test the factorial method before we worry ourselves with the much harder problem of accepting and validating user input. Here's the test program:^0.0^0.0^0.0^0.015151515151515152^0.0^0.002531645569620253^66.0^0.5151515151515151^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class FactorialTest { public static void main(String args[]) { int n; int i; long result; for (i=1; i <=10; i++) { result = factorial(i); System.out.println(result); } } // main ends here static long factorial (int n) { int i; long result=1; for (i=1; i <= n; i++) { result *= i; } return result; } // factorial ends here }^1.903225806451613^2.0^0.061224489795918366^0.30612244897959184^0.08705882352941176^0.021176470588235293^49.0^0.04081632653061224^text
 C++ programmers should take note that both methods are defined ^0.0^0.0^0.0^0.0^0.0^0.014492753623188406^10.0^0.5^text
inside^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 the class definition. Once again we see that in Java everything belongs to a class.^0.3333333333333333^0.0^0.0^0.13333333333333333^0.0^0.0^15.0^0.6666666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Let's take a closer look at the syntax of a method: ^0.0^0.0^0.0^0.0^0.0^0.01818181818181818^11.0^0.5454545454545454^text
 static long factorial (int n) { int i; long result=1; for (i=1; i <= n; i++) { result *= i; } return result; }^1.5^0.0^0.0^0.3888888888888889^0.0979020979020979^0.03496503496503497^18.0^0.0^text
 Methods begin with a declaration. This can include three to five parts. First is an optional ^0.0^0.0^0.0^0.0625^0.0^0.0^16.0^0.5625^text
access specifier^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 which can be public, private or protected. A public method can be called from pretty much anywhere. A private method can only be used within the class where it is defined. A protected method can be used anywhere within the package in which it is defined. Methods that aren't specifically declared public or private are protected by default.^0.16666666666666666^0.0^0.0^0.20689655172413793^0.0^0.0^58.0^0.5862068965517241^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Next we decide whether the method is or is not static. Static methods have only one instance per class rather than one instance per object. All objects of the same class share a single copy of a static method. By default methods are not static.^0.0^0.0^0.0^0.15555555555555556^0.0^0.0^45.0^0.5777777777777777^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Next we specify the ^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.75^text
return type^0.0^0.0^0.0^0.5^0.0^0.0^2.0^0.0^text
. This is the value that will be sent back to the calling method when all calculations inside the method are finished. If the return type is int, for example, we can use the method anywhere we use a constant integer. If the return type is ^0.0^0.0^0.0^0.15555555555555556^0.0^0.0^45.0^0.4888888888888889^text
void^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 then no value will be returned.^1.0^0.0^0.0^0.0^0.0^0.0^6.0^0.6666666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Next is the name of the method.^0.0^0.0^0.0^0.0^0.0^0.0^7.0^0.8571428571428571^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Then there are parentheses. Inside the parentheses we give names and types to the ^0.0^0.0^0.0^0.0^0.0^0.0^14.0^0.6428571428571429^text
arguments^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 of the method. A method may have no arguments or it may have one or several. These arguments can be used inside the method just like local variables.^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^28.0^0.6071428571428571^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Finally the rest of the method is enclosed in braces to make it a single block. The part inside braces is just like the main methods we've been exploring till now. There are variable declarations, some code, and finally something new, a return statement. The return statement sends a value back to the calling method. The type of this value must match the declared type of the method.^0.0^0.0^0.0^0.08823529411764706^0.0^0.0^68.0^0.47058823529411764^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
In general any line that looks like Text(arg1, arg2) or text(arg1) or text() is a method call. The compiler is responsible for distinguishing between parentheses that mean method calls and parentheses that serve as grouping operators in mathematical expressions like (3 + 7) * 2. The compiler does a very good job of this and you may safely assume that anything that isn't clearly an arithmetical expression is a method call.^0.0^0.0^0.04411764705882353^0.029411764705882353^0.018518518518518517^0.004629629629629629^68.0^0.45588235294117646^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Methods break up a program into logically separate algorithms and calculations. In still larger programs it's necessary to break up the data as well. The data can be separated into different classes and the methods attached to the classes they operate on. This is the heart of object oriented programming and the subject of Chapter 4 below.^0.0^0.0^0.0^0.05357142857142857^0.0^0.0^56.0^0.5178571428571429^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Recursive Methods^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Java supports recursive methods, i.e. even if you're already inside methodA() you can call methodA(). The easiest way I can think of to explain recursion is to look at a simple acronym, GNU. The GNU project, among other things, is trying to produce free versions of the Unix operating system and many Unix tools, such as lex, yacc, and cc. One minor problem with this effort is that the name Unix is trademarked so the GNU project can't use it. Hence, instead of Unix, we have GNU, where GNU stands for "Gnu's Not Unix." The definition of GNU refers to itself; that is, it's recursive. So what is GNU? One level deeper it's "(Gnu's Not Unix)'s Not Unix." One level deeper still, it becomes "((Gnu's Not Unix)'s Not Unix)'s Not Unix." And so on, ad infinitum. It's like standing between a pair of mirrors. The images just fade off into the distance with no clear end in sight. In computer programming recursion is achieved by allowing a method to call itself.^0.0^0.0^0.011627906976744186^0.01744186046511628^0.011258955987717503^0.0010235414534288639^172.0^0.4941860465116279^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
You probably already see one problem with recursion. Where does it all end? In fact when you write recursive methods you have to be careful to include stopping conditions. Although Java doesn't put any particular limits on the depth to which you can expand a recursion, it is very possible to have a run-away recursion eat up all the memory in your computer. ^0.0^0.0^0.0^0.0^0.0^0.0027472527472527475^64.0^0.59375^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Let's look at an example. n! (pronounced "En-factorial") is defined as n times n-1 times n-2 times n-3 ... times 2 times 1 where n is a positive integer. 0! is defined as 1. As you see n! = n time (n-1)!. This lends itself to recursive calculation, as in the following method:^0.2^0.0^0.0^0.020833333333333332^0.014234875444839857^0.021352313167259787^48.0^0.3541666666666667^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
public static long factorial (int n) { if (n == 0) { return 1; } else { return n*factorial(n-1); } }^1.6^0.0^0.0^0.5714285714285714^0.11023622047244094^0.015748031496062992^14.0^0.0^text
 Something to think about: What happens if a negative integer is passed into the factorial method? For example suppose you ask for factorial(-1). Then you get the following chain of calls: -1 * -2 * -3 * -4 * .... If you're lucky your program may unexpectedly pop into the positive numbers and count down to zero. If you're not, your program will crash with a StackOutOfMemoryError. Stopping conditions are very important. In this case you should check to see if you've been passed a negative integer; and, if you have been, return infinity. (^0.0^0.0^0.011764705882352941^0.11764705882352941^0.0071301247771836^0.012477718360071301^85.0^0.49411764705882355^text
The factorial is a special case of the gamma function for non-negative integers. Although the factorial function is only defined for non-negative integers, the gamma function is defined for all real numbers. It is possible to show that the gamma function is infinite for negative integers.^0.0^0.0^0.0^0.10416666666666667^0.0^0.0^48.0^0.3958333333333333^text
) Java doesn't support infinite values for longs, though, so return the warning value -1 instead. (Java does support infinite values for floats and doubles.) Here's a better recursive factorial method:^0.0^0.0^0.0^0.10344827586206896^0.014705882352941176^0.004901960784313725^29.0^0.20689655172413793^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
public static long factorial (int n) { if (n < 0) { return -1; } else if (n == 0) { return 1; } else { return n*factorial(n-1); } }^1.8461538461538463^0.0^0.0^0.6111111111111112^0.11176470588235295^0.01764705882352941^18.0^0.0^text
 It can be proven mathematically that all recursive algorithms have non-recursive counterparts. For instance the factorial method could have been written non-recursively like this:^0.0^0.0^0.0^0.07692307692307693^0.0^0.005405405405405406^26.0^0.38461538461538464^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
public static long factorial (int n) { long result = 1; for (int i = 1; i <= n; i++) { result *= i; } return result; }^1.4545454545454546^0.0^0.0^0.4444444444444444^0.08783783783783784^0.033783783783783786^18.0^0.0^text
 The non-recursive equivalent in this problem is straight-forward, but sometimes the non-recursive counterpart to a recursive algorithm isn't at all obvious. To see that one always exists, note that at the machine level of the computer, there's no such thing as recursion and that everything consists of values on a stack. Therefore even if you can't find a simpler way to rewrite the algorithm without recursion, you can always use your own stack instead of the Java stack. ^0.0^0.0^0.0^0.024691358024691357^0.0^0.0^81.0^0.5802469135802469^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Here's an example of a recursive program for which I have not been able to find a simple, non-recursive equivalent method. The goal is to find all possible RAM configurations for a PC, given the size of the memory chips it will accept and the number of slots it has available. We are not concerned with how the RAM is arranged inside the PC, only with the total quantity of installed RAM. For some computers this can easily be calculated by hand. For instance Apple's PowerBook 5300 series comes with 8 megabytes of RAM soldered onto the logic board and one empty slot that can hold chips of 8, 16, 32 or 56 MB capacity. Therefore the possible Ram configurations are 8, 16, 24, 40 and 64 MB. However as the number of available slots and the number of available chip sizes increases this becomes a much more difficult problem. The following is a recursive program to calculate and print all possible RAM configurations:^0.0^0.0^0.006493506493506494^0.03896103896103896^0.0^0.0010660980810234541^154.0^0.487012987012987^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 import java.util.Hashtable; import java.util.Enumeration; public class RamConfig { static int[] sizes = {0, 8, 16, 32, 64}; static Hashtable configs = new Hashtable(64); static int slots[] = new int[4]; public static void main (String args[]) { System.out.println("Available DIMM sizes are: "); for (int i=0; i < sizes.length; i++) System.out.println(sizes[i]); fillSlots(slots.length - 1); System.out.println("Ram configs are: "); for (Enumeration e = configs.elements(); e.hasMoreElements(); ) { System.out.println(e.nextElement()); } } private static void fillSlots(int n) { int total; for (int i=0; i < sizes.length; i++) { slots[n] = sizes[i]; if (n == 0) { total = 0; for (int j = 0; j < slots.length; j++) { total += slots[j]; } configs.put(Integer.toString(total), new Integer(total)); } else { fillSlots(n - 1); } } } } ^3.9361702127659575^0.0^0.19469026548672566^0.26548672566371684^0.09040590405904059^0.017527675276752766^113.0^0.02654867256637168^text
 Recursive methods are also useful for benchmarking. In particular, deep recursion tests the speed with which a language can make method calls. This is important because modern applications have a tendency to spend much of their time calling various API functions. PCWeek uses a benchmark they invented called Tak which performs 63,609 recursive method calls per pass. The algorithm is simple: If y is greater than or equal to x, Tak(x, y, z) is z. This is the nonrecursive stopping condition. Otherwise, if y is less than x, Tak(x, y, z) is Tak(Tak(x-1, y, z), Tak(y-1, z, x), Tak(z-1, x, y)). The Tak benchmark calculates Tak(18, 12, 6) between 100 and 10000 times and reports the number of passes per second. For more information about the Tak benchmark see Peter Coffee's article, "Tak test stands the test of time" on p. 91 of the 9-30-1996 PCWeek. (^0.0^0.0^0.10344827586206896^0.041379310344827586^0.017201834862385322^0.0011467889908256881^145.0^0.3448275862068966^text
The article may be on ^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.8^text
PCWeek's web site^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.0^text
 somewhere, but regrettably that site, while it looks pretty, is lacking some basic navigation aids. I was unable to locate the article, either directly or through their search engine. If anyone finds the URL let me know.^0.25^0.0^0.02702702702702703^0.05405405405405406^0.0^0.0^37.0^0.43243243243243246^text
) ^0.0^0.0^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Below is my variation of this benchmark. There are overloaded integer and floating point versions of the Tak method. Integer is used by default. If the -f flag is given on the command line, the floating point method is used. The number of passes to make may also be entered from the command line. If it is not, 1000 passes are made. The Java Date class is used to time that part of the test where the benchmarking is done. ^0.0^0.0^0.012658227848101266^0.06329113924050633^0.0^0.0^79.0^0.5189873417721519^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
import java.util.Date; public class Tak { public static void main(String[] args) { boolean useFloat = false; int numpasses; for (int i = 0; i < args.length; i++) { if (args[i].startsWith("-f")) useFloat = true; } try { numpasses = Integer.parseInt(args[args.length-1]); } catch (Exception e) { numpasses = 1000; } Date d1, d2; if (useFloat) { d1 = new Date(); for (int i = 0; i < numpasses; i++) { Tak(18.0f, 12.0f, 6.0f); } d2 = new Date(); } else { d1 = new Date(); for (int i = 0; i < numpasses; i++) { Tak(18, 12, 6); } d2 = new Date(); } long TimeRequired = d2.getTime() - d1.getTime(); double numseconds = TimeRequired/1000.0; System.out.println("Completed " + numpasses + " passes in " + numseconds + " seconds" ); System.out.println(numpasses/numseconds + " calls per second"); } public static int Tak(int x, int y, int z) { if (y >= x) return z; else return Tak(Tak(x-1, y, z), Tak(y-1, z, x), Tak(z-1, x, y)); } public static float Tak(float x, float y, float z) { if (y >= x) return z; else return Tak(Tak(x-1.0f, y, z), Tak(y-1.0f, z, x), Tak(z-1.0f, x, y)); } } ^2.9661016949152543^0.0^0.32335329341317365^0.2694610778443114^0.08803611738148984^0.021068472535741158^167.0^0.011976047904191617^text
 If you'd like to try this out right away, you can use the applet interface to the Tak benchmark at ^0.0^0.0^0.1^0.2^0.0^0.0^20.0^0.4^text
http://metalab.unc.edu/javafaq/newsletter/TakApplet.html^0.0^0.0^0.875^0.0^0.0^0.05357142857142857^8.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
My Powerbook 5300 achieved speeds between 3.5 and 5 passes per second on this test. Sun's Mac VM was about 10% faster on this test than Natural Intelligence's. The heavily loaded Sparcstation at metalab.unc.edu (load average 4+) achieved a little more than 3 passes per second. Given the various external factors affecting machine performance, these are hardly scientific measurements. I'd be curious to hear what your results are.^0.0^0.0^0.07692307692307693^0.03076923076923077^0.004545454545454545^0.004545454545454545^65.0^0.35384615384615387^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Exercises^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Find the non-recursive equivalent to the Ram Config algorithm. ^0.0^0.0^0.1^0.0^0.0^0.0^10.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Arrays^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 In non-trivial computing problems you often need to store lists of items. Often these items can be specified sequentially and referred to by their position in the list. Sometimes this ordering is natural as in a list of the first ten people to arrive at a sale. The first person would be item one in the list, the second person to arrive would be item two, and so on. Other times the ordering doesn't really mean anything such as in the ram configuration problem of the previous chapter where having a 4 MB SIMM in slot A and an 8 MB SIMM in slot B was effectively the same as an 8 MB SIMM in slot A and a 4 MB SIMM in slot B. However it's still convenient to be able to assign each item a unique number and enumerate all the items in a list by counting out the numbers.^0.0^0.0^0.026845637583892617^0.006711409395973154^0.0^0.0^149.0^0.5570469798657718^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
There are many ways to store lists of items including linked lists, sets, hashtables, binary trees and arrays. Which one you choose depends on the requirements of your application and the nature of your data. Java provides classes for many of these ways to store data and we'll explore them in detail in the chapter on the Java Class Library.^0.0^0.0^0.016666666666666666^0.03333333333333333^0.0^0.0^60.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Arrays are probably the oldest and still the most generally effective means of storing groups of variables. An array is a group of variables that share the same name and are ordered sequentially from zero to one less than the number of variables in the array. The number of variables that can be stored in an array is called the array's ^0.0^0.0^0.0^0.0^0.0^0.0^61.0^0.5901639344262295^text
dimension^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
. Each variable in the array is called an ^0.0^0.0^0.0^0.0^0.0^0.0^8.0^0.625^text
element^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 of the array. ^1.0^0.0^0.0^0.0^0.0^0.0^3.0^0.6666666666666666^text
 An array can be visualized as a column of data like so:^0.5^0.0^0.0^0.0^0.0^0.017543859649122806^12.0^0.5833333333333334^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 I[0]^0.0^0.0^0.0^0.0^0.3333333333333333^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 I[1]^0.0^0.0^0.0^0.0^0.3333333333333333^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 I[2]^0.0^0.0^0.0^0.0^0.3333333333333333^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 I[3]^0.0^0.0^0.0^0.0^0.3333333333333333^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 I[4]^0.0^0.0^0.0^0.0^0.3333333333333333^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 4^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 2^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 76^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 -90^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 6^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
In this case we're showing an integer array named ^0.0^0.0^0.0^0.2222222222222222^0.0^0.0^9.0^0.3333333333333333^text
I^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 with five elements; i.e. the type of the array is ^0.0^0.0^0.0^0.0^0.019230769230769232^0.0^11.0^0.5454545454545454^text
int^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 and the array has dimension 5. ^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.6^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Creating Arrays^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
There are three steps to creating an array, declaring it, allocating it and initializing it. ^0.0^0.0^0.0^0.0^0.0^0.0^15.0^0.6^text
 ^1.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Declaring Arrays^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 Like other variables in Java, an array must have a specific type like byte, int, String or double. Only variables of the appropriate type can be stored in an array. You cannot have an array that will store both ints and Strings, for instance.^0.2^0.0^0.022727272727272728^0.09090909090909091^0.0^0.0^44.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Like all other variables in Java an array must be declared. When you declare an array variable you suffix the type with ^0.0^0.0^0.0^0.0^0.0^0.0^22.0^0.5454545454545454^text
[]^0.0^0.0^0.0^0.0^1.0^0.0^0.0^0.0^text
 to indicate that this variable is an array. Here are some examples:^0.5^0.0^0.0^0.08333333333333333^0.0^0.014492753623188406^12.0^0.5833333333333334^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
int[] k; float[] yt; String[] names; ^0.0^0.0^0.0^0.3333333333333333^0.225^0.0^6.0^0.0^text
 In other words you declare an array like you'd declare any other variable except you append brackets to the end of the variable type.^0.0^0.0^0.0^0.0^0.0^0.0^24.0^0.5416666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Allocating Arrays^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 Declaring an array merely says what it is. It does not create the array. To actually create the array (or any other object) use the ^0.16666666666666666^0.0^0.0^0.0^0.013888888888888888^0.0^25.0^0.52^text
new^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 operator. When we create an array we need to tell the compiler how many elements will be stored in it. Here's how we'd create the variables declared above:^0.3333333333333333^0.0^0.0^0.0^0.0^0.00625^28.0^0.6071428571428571^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
k = new int[3]; yt = new float[7]; names = new String[50]; ^0.0^0.0^0.0^0.5555555555555556^0.14516129032258066^0.04838709677419355^9.0^0.0^text
 The numbers in the brackets specify the ^0.0^0.0^0.0^0.0^0.0^0.0^7.0^0.5714285714285714^text
dimension^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 of the array; i.e. how many slots it has to hold values. With the dimensions above ^0.3333333333333333^0.0^0.0^0.0^0.011494252873563218^0.0^17.0^0.5882352941176471^text
k^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 can hold three ints, ^1.0^0.0^0.25^0.0^0.0^0.0^4.0^0.5^text
yt^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 can hold seven floats and names can hold fifty Strings. Therefore this step is sometimes called ^0.3333333333333333^0.0^0.0^0.0625^0.0^0.0^16.0^0.375^text
dimensioning^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 the array. More commonly this is called ^0.5^0.0^0.0^0.14285714285714285^0.0^0.0^7.0^0.42857142857142855^text
allocating^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 the array since this step actually sets aside the memory in RAM that the array requires.^0.5^0.0^0.0^0.0625^0.0^0.0^16.0^0.375^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
This is also our first look at the ^0.0^0.0^0.0^0.125^0.0^0.0^8.0^0.75^text
new^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 operator. ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
new^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 is a reserved word in java that is used to allocate not just an array, but also all kinds of objects. Java arrays are full-fledged objects with all that implies. For now the main thing it implies is that we have to allocate them with ^0.2^0.0^0.0^0.021739130434782608^0.0^0.0^46.0^0.5869565217391305^text
new^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Initializing Arrays^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 Individual elements of the array are referenced by the array name and by an integer which represents their position in the array. The numbers we use to identify them are called ^0.0^0.0^0.0^0.0^0.0^0.0^31.0^0.5806451612903226^text
subscripts^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 or ^0.5^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
indexes^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 into the array. Subscripts are consecutive integers beginning with 0. Thus the array ^0.5^0.0^0.0^0.0^0.0^0.0^12.0^0.5^text
k^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 above has elements ^1.0^0.0^0.0^0.0^0.0^0.0^3.0^0.6666666666666666^text
k[0]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
, ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
k[1]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
, and ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
k[2]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
. Since we started counting at zero there is no ^0.0^0.0^0.0^0.0^0.0^0.0^9.0^0.6666666666666666^text
k[3]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
, and trying to access it will generate an ^0.0^0.0^0.0^0.0^0.0^0.0^8.0^0.625^text
ArrayIndexOutOfBoundsException^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
. ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
You can use array elements wherever you'd use a similarly typed variable that wasn't part of an array.^0.0^0.0^0.0^0.0^0.0^0.0^18.0^0.5555555555555556^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Here's how we'd store values in the arrays we've been working with:^0.0^0.0^0.0^0.0^0.0^0.014705882352941176^12.0^0.6666666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
k[0] = 2; k[1] = 5; k[2] = -2; yt[6] = 7.5f; names[4] = "Fred"; ^0.0^0.0^0.14285714285714285^0.0^0.21739130434782608^0.07246376811594203^7.0^0.0^text
 This step is called initializing the array or, more precisely, initializing the elements of the array. Sometimes the phrase "initializing the array" would be reserved for when we initialize all the elements of the array.^0.0^0.0^0.0^0.05714285714285714^0.0^0.0^35.0^0.5142857142857142^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
For even medium sized arrays, it's unwieldy to specify each element individually. It is often helpful to use ^0.0^0.0^0.0^0.05555555555555555^0.0^0.0^18.0^0.4444444444444444^text
for^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loops to initialize the array. For instance here is a loop that fills an array with the squares of the numbers from 0 to 100.^0.3333333333333333^0.0^0.0^0.043478260869565216^0.0^0.0^23.0^0.5652173913043478^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
float[] squares = new float[101]; for (int i=0; i <= 100; i++) { squares[i] = i*i; } ^0.3333333333333333^0.0^0.0^0.38461538461538464^0.15053763440860216^0.06451612903225806^13.0^0.0^text
 Two things you should note about this code fragment:^0.0^0.0^0.0^0.1111111111111111^0.0^0.017857142857142856^9.0^0.4444444444444444^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Watch the fenceposts! Since array subscripts begin at zero we need 101 elements if we want to include the square of 100.^0.0^0.0^0.05^0.05^0.0^0.00819672131147541^20.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Although ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
i^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 is an int it becomes a float when it is stored in squares, since we've declared squares to be an array of floats.^0.5^0.0^0.0^0.08695652173913043^0.0^0.0^23.0^0.6521739130434783^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 One way to avoid fencepost errors is to use the array's built-in length member. This tells you the number of components in the array. In the example above, squares.length equals 101. Thus the loop could have been written like this: ^1.0^0.0^0.0^0.04878048780487805^0.0^0.004149377593360996^41.0^0.4634146341463415^text
 ^0.6666666666666666^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
float[] squares = new float[101]; for (int i=0, i < squares.length; i++) { squares[i] = i*i; } ^0.3333333333333333^0.0^0.0^0.3333333333333333^0.1262135922330097^0.05825242718446602^15.0^0.0^text
 ^0.6666666666666666^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Note that the <= changed to a < to make this work. ^0.0^0.0^0.0^0.1^0.0^0.037037037037037035^10.0^0.5^text
 ^0.6666666666666666^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Shortcuts^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 It may seem to be a lot of work to set up arrays, particularly if you're used to a more array friendly language like Fortran. Fortunately Java has several shorthands for declaring, dimensioning and strong values in arrays.^0.0^0.0^0.05263157894736842^0.05263157894736842^0.0^0.0^38.0^0.4473684210526316^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
We can declare and allocate an array at the same time like this:^0.0^0.0^0.0^0.07692307692307693^0.0^0.015625^13.0^0.5384615384615384^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
int[] k = new int[3]; float[] yt = new float[7]; String[] names = new String[50]; ^0.0^0.0^0.0^0.5833333333333334^0.17647058823529413^0.03529411764705882^12.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 We can even declare, allocate, and initialize an array at the same time providing a list of the initial values inside brackets like so:^0.0^0.0^0.0^0.0^0.0^0.007246376811594203^24.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
int[] k = {1, 2, 3}; float[] yt = {0.0f, 1.2f, 3.4f, -9.87f, 65.4f, 0.0f, 567.9f}; ^0.0^0.0^0.6363636363636364^0.18181818181818182^0.11764705882352941^0.023529411764705882^11.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Counting Digits^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 We've already seen one example of an array. Main methods in an application store the command line arguments in an array of strings called ^0.0^0.0^0.0^0.0^0.0^0.0^24.0^0.4583333333333333^text
args^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
As our second example let's consider a class that counts the occurrences of the digits 0-9 in decimal expansion of the number pi, for example. This is an issue of some interest both to pure number theorists and to theologians. See, for example, ^0.0^0.0^0.0^0.09523809523809523^0.0^0.0^42.0^0.47619047619047616^text
Carl Sagan's^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.0^text
 ^0.5^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Contact^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 and ^0.5^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
John Updike's^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.0^text
 ^1.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Roger's Version^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
. More realistically we might wish to test the randomness of a random number generator. If a random number generator is truly random, all digits should occur with equal frequency over a sufficiently long period of time. ^0.0^0.0^0.0^0.05555555555555555^0.0^0.0^36.0^0.4166666666666667^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
We will do this by creating an array of ten longs called ^0.0^0.0^0.0^0.16666666666666666^0.0^0.0^12.0^0.5^text
ndigit^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
. The zeroth element of ^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
ndigit^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 will track the number of zeroes in the input stream; the first element of ^0.3333333333333333^0.0^0.0^0.0^0.01282051282051282^0.0^14.0^0.5714285714285714^text
ndigit^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 will track the numbers of 1's and so on. We'll test Java's random number generator and see if it produces apparently random numbers.^0.3333333333333333^0.0^0.0^0.045454545454545456^0.0^0.0^22.0^0.45454545454545453^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
import java.util.*; class RandomTest { public static void main (String args[]) { int[] ndigits = new int[10]; double x; int n; Random myRandom = new Random(); // Initialize the array for (int i = 0; i < 10; i++) { ndigits[i] = 0; } // Test the random number generator a whole lot for (long i=0; i < 100000; i++) { // generate a new random number between 0 and 9 x = myRandom.nextDouble() * 10.0; n = (int) x; //count the digits in the random number ndigits[n]++; } // Print the results for (int i = 0; i <= 9; i++) { System.out.println(i+": " + ndigits[i]); } } } ^3.2^5.0^0.13414634146341464^0.23170731707317074^0.075^0.027777777777777776^82.0^0.13414634146341464^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 We've got three ^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.6666666666666666^text
for^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loops in this code, one to initialize the array, one to perform the desired calculation, and a final one to print out the results. This is quite common in code that uses arrays.^0.3333333333333333^0.0^0.0^0.09090909090909091^0.0^0.0^33.0^0.45454545454545453^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Two Dimensional Arrays^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 The most common kind of multidimensional array is a two-dimensional array. If you think of a one-dimensional array as a column of values you can think of a two-dimensional array as a table of values like so:^0.3333333333333333^0.0^0.0^0.025^0.0^0.004761904761904762^40.0^0.55^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 c0^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 c1^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 c2^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 c3^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 r0^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 1^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 2^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 3^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 r1^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 1^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 2^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 3^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 4^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 r2^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 2^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 3^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 4^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 5^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 r3^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 3^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 4^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 5^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 6^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 r4^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 4^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 5^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 6^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 7^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Here we have an array with five rows and four columns. It has twenty total elements. However we say it has dimension five by four, not dimension twenty. This array is not the same as a four by five array like this one:^0.0^0.0^0.0^0.046511627906976744^0.0^0.0044444444444444444^43.0^0.6976744186046512^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 c0^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 c1^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 c2^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 c3^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 c4^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 r0^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 1^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 2^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 3^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 4^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 r1^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 1^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 2^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 3^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 4^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 5^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 r2^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 2^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 3^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 4^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 5^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 6^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 r3^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 3^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 4^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 5^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 6^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 7^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
We need to use two numbers to identify a position in a two-dimensional array. These are the element's row and column positions. For instance if the above array is called J then J[0][0] is 0, J[0][1] is 1, J[0][2] is 2, J[0][3] is 3, J[1][0] is 1, and so on.^0.0^0.0^0.0^0.043478260869565216^0.07662835249042145^0.0^46.0^0.5217391304347826^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Here's how the elements in a four by five array called M are referred to:^0.0^0.0^0.0^0.0^0.0^0.0136986301369863^15.0^0.6666666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
M[0][0]^0.0^0.0^0.0^0.0^0.5714285714285714^0.0^1.0^0.0^text
 M[0][1]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 M[0][2]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 M[0][3]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 M[0][4]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
M[1][0]^0.0^0.0^0.0^0.0^0.5714285714285714^0.0^1.0^0.0^text
 M[1][1]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 M[1][2]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 M[1][3]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 M[1][4]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
M[2][0]^0.0^0.0^0.0^0.0^0.5714285714285714^0.0^1.0^0.0^text
 M[2][1]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 M[2][2]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 M[2][3]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 M[2][4]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
M[3][0]^0.0^0.0^0.0^0.0^0.5714285714285714^0.0^1.0^0.0^text
 M[3][1]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 M[3][2]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 M[3][3]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 M[3][4]^0.0^0.0^0.0^0.0^0.5^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Declaring, Allocating and Initializing Two Dimensional Arrays^0.0^0.0^0.0^0.0^0.0^0.0^7.0^0.2857142857142857^text
 Two dimensional arrays are declared, allocated and initialized much like one dimensional arrays. However we have to specify two dimensions rather than one, and we typically use two nested ^0.0^0.0^0.0^0.0^0.0^0.0^29.0^0.5517241379310345^text
for^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loops to fill the array.^0.5^0.0^0.0^0.0^0.0^0.0^5.0^0.6^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The array examples above are filled with the sum of their row and column indices. Here's some code that would create and fill such an array:^0.0^0.0^0.0^0.0^0.0^0.007042253521126761^26.0^0.6153846153846154^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class FillArray { public static void main (String args[]) { int[][] M; M = new int[4][5]; for (int row=0; row < 4; row++) { for (int col=0; col < 5; col++) { M[row][col] = row+col; } } } }^3.125^0.0^0.07142857142857142^0.39285714285714285^0.13565891472868216^0.03488372093023256^28.0^0.0^text
 Of course the algorithm you would use to fill the array depends completely on the use to which the array is to be put. Here is a program which calculates the identity matrix for a given dimension. The identity matrix of dimension N is a square matrix which contains ones along the diagonal and zeros in all other positions.^0.0^0.0^0.0^0.01694915254237288^0.0^0.0^59.0^0.559322033898305^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class IDMatrix { public static void main (String args[]) { double[][] ID; ID = new double[4][4]; for (int row=0; row < 4; row++) { for (int col=0; col < 4; col++) { if (row != col) { ID[row][col]=0.0; } else { ID[row][col] = 1.0; } } } } }^4.476190476190476^0.0^0.06060606060606061^0.3939393939393939^0.12849162011173185^0.027932960893854747^33.0^0.0^text
 In two-dimensional arrays ArrayIndexOutOfBounds errors occur whenever you exceed the maximum column index or row index. Unlike two-dimensional C arrays, two-dimensional Java arrays are not just one-dimensional arrays indexed in a funny way.^0.0^0.0^0.02702702702702703^0.0^0.0^0.0^37.0^0.35135135135135137^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Exercises^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Write a program to generate the HTML for the above tables. ^0.0^0.0^0.09090909090909091^0.09090909090909091^0.0^0.0^11.0^0.45454545454545453^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Multidimensional Arrays^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 You don't have to stop with two dimensional arrays. Java lets you have arrays of three, four or more dimensions. However chances are pretty good that if you need more than three dimensions in an array, you're probably using the wrong data structure. Even three dimensional arrays are exceptionally rare outside of scientific and engineering applications.^0.0^0.0^0.0^0.03571428571428571^0.0^0.0^56.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The syntax for three dimensional arrays is a direct extension of that for two-dimensional arrays. Here's a program that declares, allocates and initializes a three-dimensional array:^0.0^0.0^0.03571428571428571^0.07142857142857142^0.0^0.005405405405405406^28.0^0.4642857142857143^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class Fill3DArray { public static void main (String args[]) { int[][][] M; M = new int[4][5][3]; for (int row=0; row < 4; row++) { for (int col=0; col < 5; col++) { for (int ver=0; ver < 3; ver++) { M[row][col][ver] = row+col+ver; } } } } }^3.7777777777777777^0.0^0.2^0.37142857142857144^0.14242424242424243^0.03939393939393939^35.0^0.0^text
 We need three nested ^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
for^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loops here to handle the extra dimension. ^0.5^0.0^0.0^0.0^0.0^0.0^7.0^0.42857142857142855^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The syntax for still higher dimensions is similar. Just add another pair pf brackets and another dimension.^0.0^0.0^0.0^0.058823529411764705^0.0^0.0^17.0^0.35294117647058826^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Unbalanced Arrays^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Like C Java does not have true multidimensional arrays. Java fakes multidimensional arrays using arrays of arrays. This means that it is possible to have ^0.0^0.0^0.0^0.04^0.0^0.0^25.0^0.32^text
unbalanced arrays^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
. An unbalanced array is a multidimensional array where the dimension isn't the same for all rows. IN most applications this is a horrible idea and should be avoided.^0.0^0.0^0.0^0.07142857142857142^0.0^0.0^28.0^0.5714285714285714^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Searching^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
One common task is searching an array for a specified value. Sometimes the value may be known in advance. Other times you may want to know the largest or smallest element.^0.0^0.0^0.0^0.03225806451612903^0.0^0.0^31.0^0.4838709677419355^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Unless you have some special knowledge of the contents of the array (for instance, that it is sorted) the quickest algorithm for searching an array is straight-forward linear search. Use a ^0.0^0.0^0.0^0.0625^0.010416666666666666^0.0^32.0^0.4375^text
for^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loop to look at every element of the array until you find the element you want. Here's a simple method that prints the largest and smallest elements of an array:^0.3333333333333333^0.0^0.0^0.0^0.0^0.006060606060606061^30.0^0.5666666666666667^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 static void printLargestAndSmallestElements (int[] n) { int max = n[0]; int min = n[0]; for (int i=1; i < n.length; i++) { if (max < n[i]) { max = n[i]; } if (min > n[i]) { min = n[i]; } } System.out.println("Maximum: " + max); System.out.println("Minimum: " + min); return; } ^4.333333333333333^0.0^0.06976744186046512^0.23255813953488372^0.10941475826972011^0.03307888040712468^43.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
If you're going to search an array many times, you may want to sort the array, before searching it. We'll discuss sorting algorithms in the next section.^0.0^0.0^0.0^0.037037037037037035^0.0^0.0^27.0^0.5185185185185185^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Sorting^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
All sorting algorithms rely on two fundamental operations, comparison and swapping. Comparison is straight-forward. Swapping is a little more complex. Consider the following problem. We want to swap the value of ^0.0^0.0^0.0^0.0^0.0^0.0^32.0^0.40625^text
a^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
 and ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
b^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
. Most people propose something like this as the solution:^0.0^0.0^0.0^0.1111111111111111^0.0^0.01639344262295082^9.0^0.4444444444444444^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class Swap1 { public static void main(String args[]) { int a = 1; int b = 2; System.out.println("a = "+a); System.out.println("b = "+b); // swap a and b a = b; b = a; System.out.println("a = "+a); System.out.println("b = "+b); } }^2.238095238095238^1.0^0.15^0.15^0.07792207792207792^0.03896103896103896^40.0^0.225^text
 This produces the following output:^0.0^0.0^0.0^0.2^0.0^0.02564102564102564^5.0^0.2^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 a = 1 b = 2 a = 2 b = 2 ^0.0^0.0^0.0^0.0^0.0^0.13333333333333333^4.0^0.5^text
 That isn't what you expected! The problem is that we lost track of the value 1 when we put the value of ^0.0^0.0^0.0^0.0^0.0^0.00909090909090909^21.0^0.7142857142857143^text
b^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 into ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
a^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
. To correct this we need to introduce a third variable, ^0.0^0.0^0.0^0.1^0.0^0.0^10.0^0.5^text
temp^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
, to hold the original value of ^0.0^0.0^0.0^0.0^0.0^0.0^6.0^0.5^text
a^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class Swap2 { public static void main(String args[]) { int a = 1; int b = 2; int temp; System.out.println("a = "+a); System.out.println("b = "+b); // swap a and b temp = a; a = b; b = temp; System.out.println("a = "+a); System.out.println("b = "+b); } }^2.3043478260869565^1.0^0.13636363636363635^0.1590909090909091^0.07669616519174041^0.038348082595870206^44.0^0.20454545454545456^text
 This code produces the output we expect:^0.0^0.0^0.0^0.14285714285714285^0.0^0.021739130434782608^7.0^0.2857142857142857^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 a = 1 b = 2 a = 2 b = 1 ^0.0^0.0^0.0^0.0^0.0^0.13333333333333333^4.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Bubble Sort^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 Now that we've learned how to properly swap the values of two variables, let's proceed to sorting. There are ^0.0^0.0^0.0^0.0^0.0^0.0^19.0^0.5789473684210527^text
many^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
 different sorting algorithms. One of the simplest and the most popular algorithms is referred to as ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^16.0^0.5625^text
bubble sort^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
. The idea of bubble sort is to start at the top of the array. We compare each element to the next element. If its greater than that element then we swap the two. We pass through the array as many times as necessary to sort it. The smallest value bubbles up to the top of the array while the largest value sinks to the bottom. (You could equally well call it a sink sort, but then nobody would know what you were talking about.) Here's the code:^0.125^0.0^0.0^0.022988505747126436^0.004366812227074236^0.002183406113537118^87.0^0.6436781609195402^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
import java.util.*; class BubbleSort { public static void main(String args[]) { int[] n; n = new int[10]; Random myRand = new Random(); // initialize the array for (int i = 0; i < 10; i++) { n[i] = myRand.nextInt(); } // print the array's initial order System.out.println("Before sorting:"); for (int i = 0; i < 10; i++) { System.out.println("n["+i+"] = " + n[i]); } boolean sorted = false; // sort the array while (!sorted) { sorted = true; for (int i=0; i < 9; i++) { if (n[i] > n[i+1]) { int temp = n[i]; n[i] = n[i+1]; n[i+1] = temp; sorted = false; } } } // print the sorted array System.out.println(); System.out.println("After sorting:"); for (int i = 0; i < 10; i++) { System.out.println("n["+i+"] = " + n[i]); } } }^3.282608695652174^4.0^0.0990990990990991^0.1891891891891892^0.10256410256410256^0.03952991452991453^111.0^0.05405405405405406^text
 In this case we have sorted the array in ascending order, smallest element first. It would be easy to change this to sort in descending order.^0.0^0.0^0.0^0.11538461538461539^0.0^0.0^26.0^0.46153846153846156^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Catching Exceptions^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 Do you remember this code? ^0.0^0.0^0.0^0.4^0.0^0.029411764705882353^5.0^0.2^text
// This is the Hello program in Java class Hello { public static void main (String args[]) { /* Now let's say hello */ System.out.print("Hello "); System.out.println(args[0]); } }^2.5454545454545454^2.0^0.1111111111111111^0.18518518518518517^0.07272727272727272^0.0^27.0^0.14814814814814814^text
 Do you remember what happened when you ran the program without giving it any command line arguments? The runtime system generated an exception^0.0^0.0^0.0^0.043478260869565216^0.0^0.006711409395973154^23.0^0.43478260869565216^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException at Hello.main(C:\javahtml\Hello.java:7)^1.0^0.0^0.14285714285714285^0.0^0.01818181818181818^0.01818181818181818^14.0^0.14285714285714285^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
What happened was that since we didn't give Hello any command line arguments there wasn't anything in ^0.0^0.0^0.0^0.0^0.0^0.0^17.0^0.6470588235294118^text
args[0]^0.0^0.0^1.0^0.0^0.2857142857142857^0.0^1.0^0.0^text
. Therefore Java kicked back this not too friendly error message about an "ArrayIndexOutOfBoundsException."^0.0^0.0^0.07692307692307693^0.07692307692307693^0.0^0.0^13.0^0.46153846153846156^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Previously we fixed this problem by testing the length of the array before we tried to access its first element. This worked well in this simple case, but this is far from the only such potential problem. If you were to check for every possible error condition in each line of code, you would find your code becoming bloated with more error checking than actual code. Moreover you then have to start checking for errors in the error conditions. In older languages like C, Basic and Fortran you sooner or later you find yourself resorting to goto or longjmp or other such ingredients in the recipe for illegible Spaghetti Code^0.0^0.0^0.01818181818181818^0.09090909090909091^0.0^0.0^110.0^0.4909090909090909^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The goal of exception handling is to be able to define the regular flow of the program in part of the code without worrying about all the special cases. Then, in a separate block of code, you cover the exceptional cases. This produces more legible code since you don't need to interrupt the flow of the algorithm to check and respond to every possible strange condition. The runtime environment is responsible for moving from the regular program flow to the exception handlers when an exceptional condition arises.^0.0^0.0^0.0^0.034482758620689655^0.0^0.0^87.0^0.4827586206896552^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
In practice what you do is write blocks of code that may generate exceptions inside try-catch blocks. You try the statements that generate the exceptions. Within your try block you are free to act as if nothing has or can go wrong. Then, within one or more catch blocks, you write the program logic that deals with all the special cases.^0.0^0.0^0.0^0.11290322580645161^0.0^0.0^62.0^0.532258064516129^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Here's an example of exception handling in Java using the Hello World program above:^0.0^0.0^0.0^0.0^0.0^0.011904761904761904^14.0^0.42857142857142855^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
// This is the Hello program in Java class ExceptionalHello { public static void main (String args[]) { /* Now let's say hello */ try { System.out.println("Hello " + args[0]); } catch (Exception e) { System.out.println("Hello whoever you are"); } } }^3.7333333333333334^2.0^0.14285714285714285^0.2^0.0668693009118541^0.00303951367781155^35.0^0.2^text
 Some exceptions need to be caught and dealt with while others are generally considered to be so horrific that the runtime system, just gives up. The compiler will complain if you write code that doesn't watch out for the not-too-dangerous exceptions, but you'll need to watch out for the really dangerous ones (like ArrayIndexOutOfBoundsExceptions) yourself.^0.0^0.0^0.017543859649122806^0.07017543859649122^0.005390835579514825^0.0^57.0^0.43859649122807015^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Sometimes catching an exception can feel like a little yippy dog that finally catches a car. Now that it's got hold of the bumper between its teeth, what is it going to do with it? Many times there may not be much you can do. Bad exceptions stop the program by default. This is at least preferable to unhandled exceptions in most programming languages where the entire system can come crashing down around your feet with a core dump or worse. Sometimes you may want to this too. In that case you can call the ^0.0^0.0^0.021052631578947368^0.07368421052631578^0.0^0.0019120458891013384^95.0^0.5789473684210527^text
System.exit(int)^0.0^0.0^0.0^0.3333333333333333^0.125^0.0^3.0^0.0^text
 method to halt your running program. ^0.5^0.0^0.0^0.0^0.0^0.0^6.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Other times you may just break out of a loop you were in and continue with the rest of your code. This is most common when an exception isn't really unexpected or when it doesn't badly affect your program logic. ^0.0^0.0^0.0^0.075^0.0^0.0^40.0^0.55^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
You may or may not print an error message. If you write an exception handler and you don't expect it to be called, then by all means put a ^0.0^0.0^0.0^0.06896551724137931^0.0^0.0^29.0^0.6206896551724138^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
System.out.println("Error: " + e);^0.0^0.0^0.2^0.0^0.08823529411764706^0.058823529411764705^5.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
in your exception handler. That way if something does go wrong (and something always does) you'll at least know where it went wrong. However don't put an error message in exception handlers you expect to be exercised in the course of normal program flow. Remember, they're exceptions, not errors.^0.2^0.0^0.0^0.04081632653061224^0.006622516556291391^0.0^49.0^0.5102040816326531^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
In the next section we'll see lots of examples of code that can possibly generate exceptions which must be caught. We'll talk more about exceptions in a later chapter, but this is the bare bones you need to know to respond to the exceptions generated by the java.io classes we'll be discussing in the next section.^0.0^0.0^0.0^0.017543859649122806^0.0^0.0^57.0^0.5614035087719298^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
File I/O and Streams^0.0^0.0^0.0^0.0^0.0^0.05^5.0^0.2^text
 Sometimes you write data to a file instead of the computer screen. Under Unix and DOS you can sometimes do this using the redirection operators ^0.0^0.0^0.0^0.08^0.0^0.0^25.0^0.52^text
<^0.0^0.0^0.0^0.0^0.0^1.0^0.0^0.0^text
 and ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
>^0.0^0.0^0.0^0.0^0.0^1.0^0.0^0.0^text
. However sometimes you need a more fine-grained approach that writes only certain data to a file while still putting other data on the screen. Or you may need access to multiple files simultaneously. Or maybe you want to query the user for input rather than accepting it all on the command line. Or maybe you want to read data out of a file that's in a particular format. In Java all these methods take place as ^0.0^0.0^0.0^0.025974025974025976^0.0^0.0^77.0^0.5194805194805194^text
streams^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Streams are a big topic in Java and later we'll devote an entire chapter to them. For now we want to cover just the very basics that let you write files, read files and communicate with the user. In fact the ^0.0^0.0^0.0^0.024390243902439025^0.0^0.0^41.0^0.4878048780487805^text
System.out.println()^0.0^0.0^0.3333333333333333^0.0^0.1^0.0^3.0^0.0^text
 statement we've been using all along is an implementation of Streams.^0.5^0.0^0.0^0.0^0.0^0.0^11.0^0.6363636363636364^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Interactively communicating with the user^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
We'll begin by writing a very simple program that asks the user for their name and then prints a personalized greeting.^0.0^0.0^0.0^0.047619047619047616^0.0^0.0^21.0^0.5238095238095238^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
import java.io.*; class PersonalHello { public static void main (String args[]) { byte name[] = new byte[100]; int bytesRead = 0; System.out.println("What is your name?"); try { bytesRead = System.in.read(name); System.out.print("Hello "); System.out.write(name, 0, bytesRead); } catch (IOException ex) { System.out.print("I'm Sorry. I didn't catch your name."); } } }^4.260869565217392^0.0^0.1346153846153846^0.23076923076923078^0.07272727272727272^0.010101010101010102^52.0^0.19230769230769232^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 In code that does any significant input or output you'll want to begin by importing all the various java.io classes. ^0.0^0.0^0.0^0.0^0.0^0.0^21.0^0.42857142857142855^text
import.java.io.*;^0.0^0.0^0.0^0.3333333333333333^0.058823529411764705^0.058823529411764705^3.0^0.0^text
 does this and is as ubiquitous in Java applications as ^0.5^0.0^0.0^0.1^0.0^0.0^10.0^0.5^text
#include <stdio.h>^0.0^0.0^0.3333333333333333^0.0^0.0^0.1111111111111111^3.0^0.0^text
 is in C programs.^0.5^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Most of the reading and writing you do in Java will be done with bytes. (As you'll see later there are also ways to read text files directly into Strings.) Here we've started with an array of bytes that will hold the user's name.^0.0^0.0^0.0^0.022727272727272728^0.008620689655172414^0.0^44.0^0.6136363636363636^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
First we print a query requesting the user's name. Then we read the user's name using the ^0.0^0.0^0.0^0.0^0.0^0.0^17.0^0.5882352941176471^text
System.in.read()^0.0^0.0^0.0^0.0^0.125^0.0^3.0^0.3333333333333333^text
 method. This method takes a byte array as an argument, and places whatever the user types in that byte array. Then, like before, we print "Hello." Finally we print the user's name.^0.25^0.0^0.0^0.125^0.0^0.0^32.0^0.4375^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The program doesn't actually see what the user types until he or she types a carriage return. This gives the user the chance to backspace over and delete any mistakes. Once the return key is pressed, everything in the line is placed in the array.^0.0^0.0^0.0^0.06666666666666667^0.0^0.0^45.0^0.5333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
What happens if the user types more than 100 characters of text before hitting a carriage return? In many programming languages this would lead to a rather nasty program crash. It's also the sort of bug that often gets out the door in a shipping product since programmers often fail to test their programs against extreme inputs. However Java has been programmed a little more safely. ^0.0^0.0^0.0^0.046153846153846156^0.0^0.002531645569620253^65.0^0.49230769230769234^text
System.in.read()^0.0^0.0^0.0^0.0^0.125^0.0^3.0^0.3333333333333333^text
 won't read past the end of the array even though we didn't explicitly check to make sure the input was sufficiently small. My guess is that the ^0.25^0.0^0.0^0.0^0.0^0.0^27.0^0.48148148148148145^text
System.in.read()^0.0^0.0^0.0^0.0^0.125^0.0^3.0^0.3333333333333333^text
 method internally checks the length of the array it's been passed using the name.length property. ^0.5^0.0^0.0^0.0^0.0^0.0^16.0^0.4375^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Reading Numbers^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Often strings aren't enough. A lot of times you'll want to ask the user for a number as input. All user input comes in as strings so we need to convert the string into a number. ^0.0^0.0^0.0^0.027777777777777776^0.0^0.0^36.0^0.5277777777777778^text
 Next we promised to write a ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^6.0^0.6666666666666666^text
getNextInteger()^0.0^0.0^1.0^0.0^0.125^0.0^1.0^0.0^text
 method that will accept an integer from the user. Here it is:^0.5^0.0^0.0^0.0^0.0^0.015625^12.0^0.6666666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 static int getNextInteger() { String line; DataInputStream in = new DataInputStream(System.in); try { line = in.readLine(); int i = Integer.valueOf(line).intValue(); return i; } catch (Exception e) { return -1; } } // getNextInteger ends here^4.2^1.0^0.23333333333333334^0.26666666666666666^0.07453416149068323^0.009316770186335404^30.0^0.13333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Reading Formatted Data^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
It's often the case that you want to read not just one number but multiple numbers. Sometimes you may need to read text and numbers on the same line. For this purpose Java provides the StreamTokenizer class.^0.0^0.0^0.02702702702702703^0.10810810810810811^0.0^0.0^37.0^0.4864864864864865^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Writing a text file^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Sometimes you want to save your output for posterity rather merely scrolling it across a screen. To do this we'll need to learn how to write data to a file. rather than create a completely new program we'll modify the Fahrenheit to Celsius conversion program to output to a file:^0.0^0.0^0.0^0.08^0.0^0.0035211267605633804^50.0^0.48^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
// Write the Fahrenheit to Celsius table in a file import java.io.*; class FahrToCelsius { public static void main (String args[]) { double fahr, celsius; double lower, upper, step; lower = 0.0; // lower limit of temperature table upper = 300.0; // upper limit of temperature table step = 20.0; // step size fahr = lower; try { FileOutputStream fout = new FileOutputStream("test.out"); // now to the FileOutputStream into a PrintStream PrintStream myOutput = new PrintStream(fout); while (fahr <= upper) { // while loop begins here celsius = 5.0 * (fahr-32.0) / 9.0; myOutput.println(fahr + " " + celsius); fahr = fahr + step; } // while loop ends here } // try ends here catch (IOException e) { System.out.println("Error: " + e); System.exit(1); } } // main ends here }^3.0256410256410255^9.0^0.2222222222222222^0.15151515151515152^0.04631578947368421^0.017894736842105262^99.0^0.15151515151515152^text
 There are only three things necessary to write formatted output to a file rather than to the standard output:^0.0^0.0^0.0^0.0^0.0^0.008547008547008548^19.0^0.5789473684210527^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Open a ^1.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
FileOutputStream^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 using a line like^1.0^0.0^0.0^0.0^0.0^0.0^4.0^0.25^text
 ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
FileOutputStream fout = new FileOutputStream("test.out"); ^0.0^0.0^0.5^0.16666666666666666^0.05^0.016666666666666666^6.0^0.0^text
 This line initializes the FileOutputStream with the name of the file you want to write into.^0.6666666666666666^0.0^0.125^0.0625^0.0^0.0^16.0^0.5625^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Convert the FileOutputStream into a ^0.0^0.0^0.2^0.0^0.0^0.0^5.0^0.6^text
PrintStream^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 using a statement like^1.0^0.0^0.0^0.0^0.0^0.0^4.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
PrintStream myOutput = new PrintStream(fout); ^0.0^0.0^0.8^0.2^0.06382978723404255^0.02127659574468085^5.0^0.0^text
 The PrintStream is passed the FileOutputStream from step 1. ^0.3333333333333333^0.0^0.25^0.0^0.0^0.0^8.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Instead of using ^1.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
System.out.println()^0.0^0.0^0.3333333333333333^0.0^0.1^0.0^3.0^0.0^text
 use ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
myOutput.println()^0.0^0.0^1.0^0.0^0.1111111111111111^0.0^2.0^0.0^text
. ^0.5^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
System.out^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 and ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
myOutput^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 are just different instances of the ^1.0^0.0^0.0^0.0^0.0^0.0^6.0^0.5^text
PrintStream^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 class. To print to a different ^1.0^0.0^0.0^0.16666666666666666^0.0^0.0^6.0^0.5^text
PrintStream^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 we keep the syntax the same but change the name of the ^1.0^0.0^0.0^0.0^0.0^0.0^12.0^0.8333333333333334^text
PrintStream^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
. ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Reading a text file^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.25^text
 Now that we know how to write a text file, let's try reading one. The following code implements the Unix cat utility in Java. That is it accepts a series of file names on the command line and then prints those filenames to the standard output in the order they were listed.^0.0^0.0^0.0^0.038461538461538464^0.0^0.0^52.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
// Imitate the Unix cat utility import java.io.*; class cat { public static void main (String args[]) { String thisLine; //Loop across the arguments for (int i=0; i < args.length; i++) { //Open the file for reading try { FileInputStream fin = new FileInputStream(args[i]); // now turn the FileInputStream into a DataInputStream try { DataInputStream myInput = new DataInputStream(fin); try { while ((thisLine = myInput.readLine()) != null) { // while loop begins here System.out.println(thisLine); } // while loop ends here } catch (Exception e) { System.out.println("Error: " + e); } } // end try catch (Exception e) { System.out.println("Error: " + e); } } // end try catch (Exception e) { System.out.println("failed to open file " + args[i]); System.out.println("Error: " + e); } } // for end here } // main ends here }^3.0454545454545454^10.0^0.1826086956521739^0.19130434782608696^0.06614017769002961^0.014807502467917079^115.0^0.11304347826086956^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Summing Up^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
 If you've gotten this far, you're capable of doing a surprising amount of real work in Java. You may not think so since we haven't yet talked about a lot of the modern features of Java like most of its object orientation, many of the details of working with applets, or threads. However it's important to realize what you do have. Right now the Java you know is able to handle any problem that past generations have handled with Basic and Fortran 77.^0.0^0.0^0.012195121951219513^0.036585365853658534^0.0^0.0^82.0^0.5487804878048781^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
FahrToCelsius is a very basic application that could be written in almost any programming language from the most ancient machine code to the most advanced LISP machine. Nonetheless it is important to notice that Java solves this problem just as easily as would a language more commonly associated with numeric and scientific programming such as Fortran or C. In fact this code was translated almost verbatim from Kernighan and Ritchie. Only a few minor semantic changes were required to produce a valid, efficient Java program. Although Java has many, many features that make it suitable for complex object-oriented applications, it is also fully suitable for classic numerical programs, something that is not true of competitors like SmallTalk or LISP. ^0.0^0.0^0.016666666666666666^0.03333333333333333^0.0^0.0^120.0^0.4583333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
In fact Java can outperform even Fortran and C in numerical applications when precision, reliability and portability are more important than speed. Java's true arrays with bounds checking and its well-defined IEEE 754 floating point data types are especially useful in this regard.^0.0^0.0^0.0^0.023255813953488372^0.0^0.0^43.0^0.37209302325581395^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Since there is as of yet no native architecture compiler for Java, it's too early to throw away your Fortran manuals. CPU intensive applications will still be coded in Fortran. The Java language itself (as opposed to its implementation) is also lacking in a couple of important respects for numeric computation. The lack of an exponentiation operator like Fortran's ^0.0^0.0^0.01694915254237288^0.06779661016949153^0.005376344086021506^0.0^59.0^0.4745762711864407^text
**^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 and the lack of a complex data type are both troublesome to longtime Fortran programmers. However neither is insurmountable.^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^19.0^0.5263157894736842^text
 Would anyone care to write a Fortran to Java translator? ^0.3333333333333333^0.0^0.0^0.0^0.0^0.016666666666666666^10.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
In the next chapter we'll move beyond the 1970's to discuss more modern features of Java including Objects, Applets, Event Driven Programming and threads.^0.0^0.0^0.043478260869565216^0.0^0.0^0.0^23.0^0.4782608695652174^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Part 3: Applets^0.0^0.0^0.5^0.0^0.0^0.06666666666666667^2.0^0.5^text
 The last chapter was rooted solidly in the 1970's. It used techniques often referred to as "structured" or "procedural programming" which were popular then. (We skipped right over the most popular innovation of the 60's and the Basic programmer, spaghetti code). Certain programmers are sometimes said to "Write Fortran in any language," and that's more or less what we did. You now have the knowledge to accomplish with Java anything that can be done within the bounds of ANSI-standard Fortran 77.^0.0^0.0^0.0^0.0^0.003898635477582846^0.0^80.0^0.5875^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
In this chapter we're going to move into the 1980's. In particular we're going to work with ^0.0^0.0^0.0^0.058823529411764705^0.0^0.0^17.0^0.5882352941176471^text
event driven programming^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
. This style of programming should be very familiar to Macintosh and Windows programmers. In those environments program logic doesn't flow from the top to the bottom of the program as it does in most procedural code. Rather the operating system collects ^0.0^0.0^0.0^0.024390243902439025^0.0^0.0^41.0^0.5365853658536586^text
events^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 and the program responds to them. These events may be mouse clicks, keypresses, network data arriving on the Ethernet port, or any of about two dozen other possibilities. The operating system looks at each event, determines what program it was intended for, and places the event in the appropriate program's ^0.14285714285714285^0.0^0.02^0.02^0.0^0.0^50.0^0.5^text
event queue^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Every application program has an ^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.6^text
event loop^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
. This is just a ^0.0^0.0^0.0^0.25^0.0^0.0^4.0^0.5^text
while^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 loop which loops continuously. On every pass through the loop the application retrieves the next event from its event queue and responds accordingly.^0.25^0.0^0.0^0.0^0.0^0.0^23.0^0.4782608695652174^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Java applets behave similarly. However the runtime environment (i.e. the browser) takes care of the event loop for the applet so there's no need to write one explicitly. Rather you need to have methods in your applet subclass that respond to each kind of event you want to process.^0.0^0.0^0.06^0.02^0.006968641114982578^0.0^50.0^0.46^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
This is all fairly abstract until you see some concrete examples. Let's begin with a simple one.^0.0^0.0^0.0^0.11764705882352941^0.0^0.0^17.0^0.5294117647058824^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Hello World: The Applet^0.0^0.0^0.25^0.0^0.0^0.043478260869565216^4.0^0.25^text
 The reason people are excited about Java as more than just another OOP language is because it allows them to write interactive applets on the web. ^0.0^0.0^0.07692307692307693^0.0^0.0^0.0^26.0^0.5384615384615384^text
Hello World^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 isn't a very interactive program, but let's look at a webbed version.^0.5^0.0^0.0^0.0^0.0^0.0^12.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
import java.applet.Applet; import java.awt.Graphics; public class HelloWorldApplet extends Applet { public void paint(Graphics g) { g.drawString("Hello world!", 50, 25); } }^2.4^0.0^0.22727272727272727^0.3181818181818182^0.0514018691588785^0.004672897196261682^22.0^0.0^text
 This applet version of HelloWorld is a little more complicated than the HelloWorld application of the previous chapter, and it will take a little more effort to run it as well.^0.0^0.0^0.0967741935483871^0.03225806451612903^0.0^0.0^31.0^0.5806451612903226^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
First type in the source code and save it into file called HelloWorldApplet.java in the javahtml/classes directory. Compile this file by typing ^0.5^0.0^0.08333333333333333^0.041666666666666664^0.0^0.006666666666666667^24.0^0.375^text
javac HelloWorldApplet.java^0.0^0.0^0.6666666666666666^0.0^0.0^0.0^3.0^0.0^text
 at the command line prompt.^1.0^0.0^0.0^0.0^0.0^0.0^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
If all is well a file called HelloWorldApplet.class will be created. This file must be in your classes directory.^0.0^0.0^0.05^0.15^0.0^0.0^20.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Now you need to create an HTML file that will include your applet. The following simple HTML file will do. ^0.0^0.0^0.15^0.05^0.0^0.0^20.0^0.45^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
<HTML> <HEAD> <TITLE> Hello World </TITLE> </HEAD> <BODY> This is the applet:<P> <APPLET codebase="classes" code="HelloWorldApplet.class" width=200 height=200 ></APPLET> </BODY> </HTML> ^0.0^0.0^0.2916666666666667^0.08333333333333333^0.0^0.09644670050761421^24.0^0.08333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Save this file as "HelloWorldApplet.html" in the javahtml directory. When you've done that load the HTML file into a Java enabled browser such as HotJava or Netscape 2.0. You should see the following:^0.0^0.0^0.18181818181818182^0.030303030303030304^0.0^0.004878048780487805^33.0^0.5151515151515151^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
This is the applet: Hello World! ^0.0^0.0^0.16666666666666666^0.16666666666666666^0.0^0.05714285714285714^6.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
If the applet compiled without error and produced a HelloWorldApplet.class file, and yet you don't see the string "Hello World" in your browser chances are that the class file is in the wrong place. Make sure the .html file is in the javahtml directory and the compiled .class file is in the javahtml/classes directory.^0.0^0.0^0.08928571428571429^0.08928571428571429^0.0^0.003076923076923077^56.0^0.4642857142857143^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Examining the Hello World Applet^0.0^0.0^0.2^0.0^0.0^0.0^5.0^0.2^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The Hello World Applet adds several constructs to what we saw in the Hello World Application. Moving from top to bottom the first thing you notice is the two lines: ^0.0^0.0^0.03333333333333333^0.0^0.0^0.005847953216374269^30.0^0.5666666666666667^text
import java.applet.Applet; import java.awt.Graphics;^0.0^0.0^0.375^0.25^0.03508771929824561^0.0^8.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
import^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 statement in Java is similar to the #include statement in C or C++. It pulls in the classes that are contained in a package elsewhere. A package is merely a collection of related classes. In this case we're requesting access to the public classes contained in the basic release, java.applet.Applet and java.awt.Graphics. Depending on the phase of the moon, awt stands for "advanced window toolkit" or "applet window toolkit". You'll see a lot more of it.^0.125^0.0^0.0625^0.075^0.0^0.0021413276231263384^80.0^0.45^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The next change from the application is the Class definition:^0.0^0.0^0.0^0.1^0.0^0.01639344262295082^10.0^0.6^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
public class HelloWorldApplet extends Applet^0.0^0.0^0.4^0.6^0.0^0.0^5.0^0.0^text
 ^1.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
extends^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 keyword indicates that this class is a ^1.0^0.0^0.0^0.2857142857142857^0.0^0.0^7.0^0.42857142857142855^text
subclass^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 of the Applet class; or, to put it another way, Applet is a ^1.0^0.0^0.15384615384615385^0.07692307692307693^0.01639344262295082^0.0^13.0^0.6923076923076923^text
superclass^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 of HelloWorldApplet. The Applet class is defined in the java.applet.Applet package which we just imported. Since HelloWorldApplet is a subclass of the Applet class, our HelloWorldApplet automatically inherits all the functionality of the generic Applet class. Anything an Applet can do, the HelloWorldApplet can do too.^0.0^0.0^0.20833333333333334^0.125^0.0^0.0^48.0^0.4791666666666667^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The next difference between the applet and the application is far less obvious (except maybe to a longtime C programmer). ^0.0^0.0^0.05^0.0^0.016129032258064516^0.0^20.0^0.55^text
There's no main method!^0.0^0.0^0.0^0.0^0.0^0.041666666666666664^4.0^0.5^text
 Applets don't need them. The main method is actually in the browser or the AppletViewer, not in the Applet itself. Applets are like plugin code modules for Adobe Photoshop that provide extra functionality, but can't run without a main program to host them.^0.0^0.0^0.13953488372093023^0.046511627906976744^0.0^0.0^43.0^0.4186046511627907^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Rather than starting at a specific place in the code applets are ^0.0^0.0^0.08333333333333333^0.0^0.0^0.0^12.0^0.5833333333333334^text
event driven^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
. An applet waits for one of a series of events such as a key press, the mouse pointer being moved over the applets visible area, or a mouse click and then executes the appropriate event handler. Since this is our first program we only have one event handler, ^0.0^0.0^0.041666666666666664^0.041666666666666664^0.0^0.0^48.0^0.5208333333333334^text
paint^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
. ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Most applets need to handle the ^0.0^0.0^0.16666666666666666^0.0^0.0^0.0^6.0^0.5^text
paint^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 event. This event occurs whenever a part of the applet's visible area is uncovered and needs to be drawn again.^0.3333333333333333^0.0^0.05^0.05^0.0^0.0^20.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The paint method is passed a ^0.0^0.0^0.0^0.0^0.0^0.0^6.0^0.5^text
Graphics^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 object which we've chosen to call g. The Graphics class is defined in the java.awt.Graphics package which we've imported. Within the paint method we call g's drawString method to draw the string "Hello World!" at the coordinates (50,25). That's 50 pixels across and twenty-five pixels down from the upper left hand corner of the applet. We'll talk more about coordinate systems later. This drawing takes place whenever a portion of the screen containing our applet is covered and then uncovered and needs to be refreshed.^0.1111111111111111^0.0^0.03488372093023256^0.03488372093023256^0.0037593984962406013^0.0018796992481203006^86.0^0.4883720930232558^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The APPLET HTML Tag^0.0^0.0^0.5^0.0^0.0^0.0^4.0^0.25^text
 Applets are included on web pages using the <APPLET> tag. The <APPLET> tag is perhaps most similar to the <IMG> tag. Like <IMG> <APPLET> needs to reference a source file that is not part of the HTML page on which it is embedded. IMG's do this with the SRC= parameter. APPLET's do this with the CODE= parameter. The CODE parameter tells the browser where to look for the compiled .class file. It is relative to the location of the source document. Thus if you're browsing http://metalab.unc.edu/javafaq/index.html and that page references an applet with CODE=animation.class, then the animation.class file needs to be at http://metalab.unc.edu/javafaq/animation.class.^0.0^0.0^0.1864406779661017^0.0847457627118644^0.0^0.02467343976777939^118.0^0.3983050847457627^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
For reasons that remain a mystery to HTML authors everywhere, but possibly having something to do with packages and classpaths, if the applet resides somewhere other than the same directory as the page it lives on, then you don't just give a URL to its location. Rather you point at the directory where the .class file is using the CODEBASE parameter. You still also have to use CODE to give name of the .class file.^0.0^0.0^0.06666666666666667^0.08^0.0^0.0^75.0^0.5733333333333334^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Also like IMG, APPLET has several parameters to define how it is positioned on the page. HEIGHT and WIDTH parameters work exactly as they do with IMG, specifying how big a rectangle the browser should leave for the applet. These numbers are specified in pixels. ALIGN also works exactly as for images (in those browsers that support ALIGN) defining how the applet's rectangle is placed on the page relative to other elements. Possible values include LEFT, RIGHT, TOP, TEXTTOP, MIDDLE, ABSMIDDLE, BASELINE, BOTTOM and ABSBOTTOM. Finally as with IMG you can specify an HSPACE and a VSPACE in pixels to set the amount of blank space between an applet and the surrounding text.^0.0^0.0^0.10619469026548672^0.035398230088495575^0.0029069767441860465^0.0^113.0^0.46017699115044247^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Finally also like IMG, APPLET has an ALT tag. As far as I know ALT is not yet implemented in any browsers. An ALT tag is used by a browser that understands the APPLET tag but for some reason cannot play the applet. For instance if an applet needs to write a file on your hard drive, but your preferences are set not to allow that, then the browser should display the ALT text.^0.0^0.0^0.06756756756756757^0.05405405405405406^0.0^0.0^74.0^0.47297297297297297^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
ALT is not used for browsers that do not understand APPLET at all. For that purpose APPLET has been defined to include a closing tag as well, </APPLET>. All raw text between the opening and closing APPLET tags is ignored by a Java capable browser. However a non-Java capable browser will ignore the APPLET tags instead and read the text between them.^0.0^0.0^0.07936507936507936^0.047619047619047616^0.0^0.0028011204481792717^63.0^0.4444444444444444^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Passing Parameters to Applets^0.0^0.0^0.25^0.0^0.0^0.0^4.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The area between the opening and closing APPLET tag is also used to pass parameters to applets. This is done through the use of the PARAM HTML tag and the getParameter method of the java.applet.Applet class.^0.0^0.0^0.18421052631578946^0.05263157894736842^0.0^0.0^38.0^0.47368421052631576^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
To demonstrate this we'll convert HelloWorldApplet into a generic string drawing applet. To do this we'll need to pass the applet ^0.0^0.0^0.14285714285714285^0.14285714285714285^0.0^0.0^21.0^0.38095238095238093^text
parameters^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 that define the string to be drawn.^0.5^0.0^0.0^0.0^0.0^0.0^7.0^0.5714285714285714^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
import java.applet.Applet; import java.awt.Graphics; public class DrawStringApplet extends Applet { String input_from_page; public void init() { input_from_page = getParameter("String"); } public void paint(Graphics g) { g.drawString(input_from_page, 50, 25); } }^2.1875^0.0^0.3448275862068966^0.3103448275862069^0.058823529411764705^0.0030959752321981426^29.0^0.0^text
 Now you need to create an HTML file that will include your applet. The following simple HTML file will do: ^0.0^0.0^0.15^0.05^0.0^0.008771929824561403^20.0^0.45^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
<HTML> <HEAD> <TITLE> Draw String </TITLE> </HEAD> <BODY> This is the applet:<P> <APPLET codebase="classes" code="DrawStringApplet.class" width=200 height=200><PARAM name="String" value="Howdy, there!"></APPLET> </BODY> </HTML>^0.0^0.0^0.26666666666666666^0.06666666666666667^0.0^0.09282700421940929^30.0^0.13333333333333333^text
 Of course you are free to change "Howdy, there!" to a string of your choice. Note that this allows you to change the output of the applet without changing or recompiling the code.^0.0^0.0^0.030303030303030304^0.030303030303030304^0.0^0.005494505494505495^33.0^0.5454545454545454^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
You're not limited to one parameter either. You can pass as many named parameters to an applet as you like.^0.0^0.0^0.05^0.0^0.0^0.0^20.0^0.65^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
getParameter^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 method is straightforward. You give it a string that's the name of the parameter you want. You get back a string that's the value of the parameter. All parameters are passed as Strings. If you want to get something else like an integer then you'll need to pass it as a String and convert it into the type you really want.^0.16666666666666666^0.0^0.0^0.03278688524590164^0.0^0.0^61.0^0.6229508196721312^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
PARAM^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 HTML tag is also straightforward. It occurs between ^0.5^0.0^0.125^0.0^0.0^0.0^8.0^0.5^text
<APPLET>^0.0^0.0^1.0^0.0^0.0^0.25^1.0^0.0^text
 and ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
</APPLET>^0.0^0.0^1.0^0.0^0.0^0.1111111111111111^1.0^0.0^text
. It has two parameters of its own, NAME and VALUE. The NAME identifies which parameter this is for the ^0.0^0.0^0.0^0.10526315789473684^0.0^0.0^19.0^0.6842105263157895^text
getParameter^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 method. VALUE is the value of the parameter as a String. Both must be enclosed in double quote marks like all other HTML tag parameters.^0.25^0.0^0.04^0.04^0.0^0.0^25.0^0.48^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Events and Applets^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Event Tutor Applet^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.0^text
 The following applet is designed to give you some feel for just what event driven programming is like and what the various events you're likely to encounter are. Whenever an event occurs, the applet responds by printing the name of the event at the command line. ^0.0^0.0^0.043478260869565216^0.021739130434782608^0.0^0.0^46.0^0.5217391304347826^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
import java.applet.Applet; import java.awt.*; public class EventTutor extends Applet { public void init() { System.out.println("init event"); } public void paint(Graphics g) { System.out.println("paint event"); } public void start() { System.out.println("start event"); } public void destroy() { System.out.println("destroy event"); } public void update(Graphics g) { System.out.println("update event"); } public boolean mouseUp(Event e, int x, int y) { System.out.println("mouseUp event"); return false; } public boolean mouseDown(Event e, int x, int y) { System.out.println("mouseDown event"); return false; } public boolean mouseDrag(Event e, int x, int y) { System.out.println("mouseDrag event"); return false; } public boolean mouseMove(Event e, int x, int y) { System.out.println("mouseMove event"); return false; } public boolean mouseEnter(Event e, int x, int y) { System.out.println("mouseEnter event"); return false; } public boolean mouseExit(Event e, int x, int y) { System.out.println("mouseExit event"); return false; } public void getFocus() { System.out.println("getFocus event"); } public void gotFocus() { System.out.println("gotFocus event"); } public void lostFocus() { System.out.println("lostFocus event"); } public boolean keyDown(Event e, int x) { System.out.println("keyDown event"); return true; } } ^2.608108108108108^0.0^0.22105263157894736^0.2894736842105263^0.07209446861404599^6.215040397762585E-4^190.0^0.0^text
 Once you've compiled and loaded this applet play with it. Click the mouse in the applet window. Doubleclick the mouse. Click and drag. Type some text. Resize the browser window. Cover it and then uncover it. Keep your eye on the standard output (Java console in Netscape) while doing this.^0.0^0.0^0.1^0.06^0.006622516556291391^0.0^50.0^0.42^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Here are some questions to answer:^0.0^0.0^0.0^0.0^0.0^0.027777777777777776^6.0^0.6666666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Can you have a mouseDown event that is not followed by a mouseUp event? ^0.0^0.0^0.14285714285714285^0.0^0.0^0.0136986301369863^14.0^0.6428571428571429^text
Can you have a mouseDown event that is not followed by a mouseDrag event? ^0.0^0.0^0.14285714285714285^0.0^0.0^0.013333333333333334^14.0^0.6428571428571429^text
Can you have a mouseUp Event that is not preceded by a mouseDown event? ^0.0^0.0^0.14285714285714285^0.0^0.0^0.0136986301369863^14.0^0.6428571428571429^text
What has to happen for a paint event to occur? ^0.0^0.0^0.0^0.1^0.0^0.020833333333333332^10.0^0.5^text
What's the most common event? Why? ^0.0^0.0^0.0^0.0^0.0^0.05555555555555555^6.0^0.6666666666666666^text
Are there any events you don't see? ^0.0^0.0^0.0^0.14285714285714285^0.0^0.02702702702702703^7.0^0.7142857142857143^text
How many times can you make the start event get called? the stop event? ^0.0^0.0^0.0^0.0^0.0^0.0273972602739726^14.0^0.5^text
Of those events you can make occur, exactly how do you do it? How many different ways can you do it? There are a number of new things in this code but none of them are particularly difficult. The first one is the second import statement, ^0.0^0.0^0.0^0.13043478260869565^0.0^0.0080^46.0^0.5869565217391305^text
import java.awt.*^0.0^0.0^0.3333333333333333^0.3333333333333333^0.0^0.058823529411764705^3.0^0.0^text
. This time we need more than one class from the awt package so rather than worrying about which one to import, we just get them all with the ^0.0^0.0^0.03571428571428571^0.14285714285714285^0.0^0.0^28.0^0.6785714285714286^text
*^0.0^0.0^0.0^0.0^0.0^1.0^0.0^0.0^text
. The compiler is smart enough to only link in those that it actually uses.^0.0^0.0^0.0^0.0^0.0^0.0^14.0^0.6428571428571429^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Finally there are a whole lot of new event methods. We'll cover them in detail in the next section. For now see under what circumstances you can make each one happen.^0.0^0.0^0.0^0.0967741935483871^0.0^0.0^31.0^0.6451612903225806^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Making a List^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
It is extremely bad form to use ^0.0^0.0^0.0^0.0^0.0^0.0^7.0^0.42857142857142855^text
System.out.println()^0.0^0.0^0.3333333333333333^0.0^0.1^0.0^3.0^0.0^text
 in an applet. On some systems this may not work at all. However it has the advantage of being familiar and easy. For more serious work you should actually draw your text in the applet window. There are at least three different ways to do this. For our purposes the one that makes the most sense is to use a ^0.14285714285714285^0.0^0.03333333333333333^0.08333333333333333^0.0^0.0^60.0^0.6166666666666667^text
List^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
A List is a scrolling list of Strings defined in ^0.0^0.0^0.0^0.0^0.0^0.0^10.0^0.5^text
java.awt.List^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.0^text
. We create a new List with new, just as we create any other Object. The specific constructor we use asks for an int that's the number of visible lines and a boolean that tells whether or not multiple selections are allowed. We'll ask for 25 lines and no multiple selections.^0.0^0.0^0.0^0.12244897959183673^0.0^0.0^49.0^0.46938775510204084^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 List theList; theList = new List(25, false); ^0.5^0.0^0.3333333333333333^0.16666666666666666^0.07692307692307693^0.019230769230769232^6.0^0.0^text
 ^0.25^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
We add Strings to the list by using the addItem method of the List we're adding to like so:^0.0^0.0^0.05263157894736842^0.0^0.0^0.010869565217391304^19.0^0.5263157894736842^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 theList.addItem("This is a list item"); ^1.3333333333333333^0.0^0.2857142857142857^0.14285714285714285^0.06382978723404255^0.0^7.0^0.2857142857142857^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Finally we need to actually add this List to our applet (more precisely the applet's container). We do this with the line^0.0^0.0^0.09090909090909091^0.18181818181818182^0.016260162601626018^0.0^22.0^0.4090909090909091^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 add(theList); ^1.3333333333333333^0.0^0.5^0.0^0.14285714285714285^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 in the init method. That's all. We can use the same applet we used before with these simple changes.^0.0^0.0^0.10526315789473684^0.0^0.0^0.0^19.0^0.631578947368421^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
import java.applet.Applet; import java.awt.*; public class EventList extends Applet { List theList; public void init() { theList = new List(25, false); add(theList); theList.addItem("init event"); } public void paint(Graphics g) { theList.addItem("paint event"); } public void start() { theList.addItem("start event"); } public void destroy() { theList.addItem("destroy event"); } public void update(Graphics g) { theList.addItem("update event"); } public boolean mouseUp(Event e, int x, int y) { theList.addItem("mouseUp event"); return false; } public boolean mouseDown(Event e, int x, int y) { theList.addItem("mouseDown"); return false; } public boolean mouseDrag(Event e, int x, int y) { theList.addItem("mouseDrag event"); return false; } public boolean mouseMove(Event e, int x, int y) { theList.addItem("mouseMove event"); return false; } public boolean mouseEnter(Event e, int x, int y) { theList.addItem("mouseEnter event"); return false; } public boolean mouseExit(Event e, int x, int y) { theList.addItem("mouseExit event"); return false; } public void getFocus() { theList.addItem("getFocus event"); } public void gotFocus() { theList.addItem("gotFocus event"); } public void lostFocus() { theList.addItem("lostFocus event"); } public boolean keyDown(Event e, int x) { theList.addItem("keyDown event"); return true; } } ^2.6025641025641026^0.0^0.32967032967032966^0.3076923076923077^0.07536764705882353^0.0012254901960784314^182.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
We'll talk more about containers, Lists, and applet components in a later section.^0.0^0.0^0.07692307692307693^0.0^0.0^0.0^13.0^0.46153846153846156^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The Events^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
In this section we're going to categorize the events your applet should respond to. You may not always need to respond to each one. For some of the events we'll also include new methods for the EventTutor applet that show a little more information. When we do you should replace the old method with the new one.^0.0^0.0^0.05263157894736842^0.10526315789473684^0.0^0.0^57.0^0.5789473684210527^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^1.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
init^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 The ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
init()^0.0^0.0^1.0^0.0^0.3333333333333333^0.0^1.0^0.0^text
 method is called when your applet begins executing. Netscape is also known to call this method at other times such as when an applet is reloaded or you return to a page containing an applet. Generally you use this method to set up any data structures or perform any tasks you need to get ready to run the applet. Since it's only called once it's easy to miss the ^0.16666666666666666^0.0^0.07246376811594203^0.043478260869565216^0.0^0.0^69.0^0.5362318840579711^text
init()^0.0^0.0^1.0^0.0^0.3333333333333333^0.0^1.0^0.0^text
 method in the EventTutor applet. If necessary redirect the standard output to a file and look at the first line of that file to see it.^0.3333333333333333^0.0^0.07692307692307693^0.038461538461538464^0.0^0.0^26.0^0.5384615384615384^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public void init() { System.out.println("init event"); }^2.6666666666666665^0.0^0.375^0.25^0.10606060606060606^0.0^8.0^0.0^text
 ^1.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
paint^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 We've already seen the ^0.6666666666666666^0.0^0.0^0.0^0.0^0.0^4.0^0.75^text
paint()^0.0^0.0^0.0^0.0^0.2857142857142857^0.0^1.0^0.0^text
 method. Almost any applet is going to need to override this method. This is the method in which you will do all your drawing. You can only write to the applet screen in the paint method. However there are times when you'll want to write to an offscreen image in another method and then just quickly copy that image to the screen in your ^0.16666666666666666^0.0^0.046875^0.046875^0.0^0.0^64.0^0.578125^text
paint()^0.0^0.0^0.0^0.0^0.2857142857142857^0.0^1.0^0.0^text
 method.^1.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.6666666666666666^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public void paint(Graphics g) { theList.addItem("paint event"); }^2.6666666666666665^0.0^0.2222222222222222^0.2222222222222222^0.09333333333333334^0.0^9.0^0.0^text
 ^1.25^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
stop ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 A ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
stop()^0.0^0.0^0.0^0.0^0.3333333333333333^0.0^1.0^0.0^text
 message says the user is no longer looking at the page that contains the applet. This is usually because the user left the page or minimized the window. At this time you should stop any CPU eating activities that don't matter when the user isn't looking at your page. For instance your Doom applet should stop tracking monster movement if the user isn't actually playing. On the other hand a spreadsheet applet in the middle of a long calculation should continue calculating because the user is likely to want the result later. Once the user returns to the page the ^0.1111111111111111^0.0^0.03^0.07^0.0^0.0^100.0^0.46^text
start()^0.0^0.0^0.0^0.0^0.2857142857142857^0.0^1.0^0.0^text
 method is called. ^0.5^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.6666666666666666^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public void stop() { theList.addItem("stop event"); }^2.6666666666666665^0.0^0.2857142857142857^0.2857142857142857^0.1111111111111111^0.0^7.0^0.0^text
 ^1.6666666666666667^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
start ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 The start() method is called when a user brings their attention back to an applet, for instance after maximizing a window or returning to the applet's page. It is called after the init() method. Initialization code that needs to be performed every time an applet is restarted should be put here.^0.0^0.0^0.0784313725490196^0.0196078431372549^0.013289036544850499^0.0^51.0^0.5294117647058824^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public void start() { theList.addItem("start event"); }^2.6666666666666665^0.0^0.2857142857142857^0.2857142857142857^0.1076923076923077^0.0^7.0^0.0^text
 ^0.75^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
destroy^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 The destroy() method is called before the applet is unloaded completely. It is called after the stop() method. Users may reload the applet later, but if they do it will be as if they've never seen it before. All variables, static, member, local or otherwise will be initialized to their initial state. If you have any final cleanup to do (for instance sending output back to the httpd server) do it here.^0.0^0.0^0.041666666666666664^0.125^0.014598540145985401^0.0^72.0^0.5138888888888888^text
 ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public void destroy() { theList.addItem("destroy event"); }^2.6666666666666665^0.0^0.2857142857142857^0.2857142857142857^0.10144927536231885^0.0^7.0^0.0^text
 ^1.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
update ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 The ^1.3333333333333333^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
update()^0.0^0.0^0.0^0.0^0.25^0.0^1.0^0.0^text
 method is called automatically by the system when ????. It's often overridden when you want to use offscreen Images to avoid flicker.^1.5^0.0^0.047619047619047616^0.0^0.0^0.0^21.0^0.47619047619047616^text
 ^0.6666666666666666^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public void update(Graphics g) { theList.addItem("update event"); }^2.6666666666666665^0.0^0.2222222222222222^0.2222222222222222^0.09090909090909091^0.0^9.0^0.0^text
 ^1.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
mouseUp^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 The ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
mouseUp()^0.0^0.0^1.0^0.0^0.2222222222222222^0.0^1.0^0.0^text
 method is called whenever the mouse button is ^0.5^0.0^0.0^0.0^0.0^0.0^8.0^0.5^text
released^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 in your applet. In most cases this is the event you'll want to watchout for, not mouseDown. A button is typically highlighted when the mouse button is pressed on it, but it is not activated till the user releases the mouse button. This gives the user a chance to change their mind by moving the cursor off the object without releasing it.^0.16666666666666666^0.0^0.03225806451612903^0.04838709677419355^0.0^0.0^62.0^0.5161290322580645^text
 The exception would be when you want an action to continue as long as the mouse button is held down, a fast forward button on a movie playing applet for instance.^0.16666666666666666^0.0^0.03225806451612903^0.0967741935483871^0.0^0.0^31.0^0.4838709677419355^text
 ^1.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
mouseUp()^0.0^0.0^1.0^0.0^0.2222222222222222^0.0^1.0^0.0^text
 methods also receive the coordinates of the point where the mouse was released. ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^13.0^0.5384615384615384^text
 public boolean mouseUp(Event e, int x, int y) { theList.addItem("mouseUp event at (" + x + "," + y + ")"); return false; }^3.0^0.0^0.2222222222222222^0.2777777777777778^0.072992700729927^0.029197080291970802^18.0^0.05555555555555555^text
 ^1.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
mouseDown^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 The ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
mouseDown()^0.0^0.0^1.0^0.0^0.18181818181818182^0.0^1.0^0.0^text
 method is called whenever the mouse button is ^0.5^0.0^0.0^0.0^0.0^0.0^8.0^0.5^text
pressed^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 in your applet. In most cases you'll want to wait for a mouseUp before taking any action though. ^0.3333333333333333^0.0^0.1111111111111111^0.05555555555555555^0.0^0.0^18.0^0.5555555555555556^text
 ^1.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
mouseDown()^0.0^0.0^1.0^0.0^0.18181818181818182^0.0^1.0^0.0^text
 methods also receive the coordinates of the point where the mouse was released. ^0.5^0.0^0.0^0.0^0.0^0.0^13.0^0.5384615384615384^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public boolean mouseDown(Event e, int x, int y) { theList.addItem("mouseDown event at (" + x + "," + y + ")"); return false; }^3.0^0.0^0.2222222222222222^0.2777777777777778^0.07092198581560284^0.028368794326241134^18.0^0.05555555555555555^text
 ^1.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
mouseDrag ^1.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
mouseDrag()^0.0^0.0^1.0^0.0^0.18181818181818182^0.0^1.0^0.0^text
 methods occur when a user moves the mouse while holding down the mouse button. ^0.5^0.0^0.0^0.07142857142857142^0.0^0.0^14.0^0.35714285714285715^text
mouseDrag()^0.0^0.0^1.0^0.0^0.18181818181818182^0.0^1.0^0.0^text
 methods receive the coordinates of the point where the mouse is when the event occurs.^0.0^0.0^0.0^0.0^0.0^0.0^15.0^0.5333333333333333^text
 ^0.6666666666666666^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public boolean mouseDrag(Event e, int x, int y) { theList.addItem("mouseDrag event at (" + x + "," + y + ")"); return false; }^4.0^0.0^0.2222222222222222^0.2777777777777778^0.06896551724137931^0.027586206896551724^18.0^0.05555555555555555^text
 ^1.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
mouseMove ^1.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 mouseMove methods occur when a user moves the mouse without holding down the mouse button. mouseMove methods receive the coordinates of the point where the mouse is when the event occurs. ^1.3333333333333333^0.0^0.06451612903225806^0.0^0.0^0.0^31.0^0.45161290322580644^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public boolean mouseMove(Event e, int x, int y) { theList.addItem("mouseMove event at (" + x + "," + y + ")"); return false; }^3.0^0.0^0.2222222222222222^0.2777777777777778^0.07092198581560284^0.028368794326241134^18.0^0.05555555555555555^text
 ^1.5^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
mouseEnter^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 Your applet receives a mouseEnter event whenever the cursor enters your applet from somewhere else. You'll also receive the coordinates of the point at which the cursor entered your applet. After this happens its typically followed by a Stream of mouseMoved events as the cursor continues through the applet so it can be hard to see.^0.0^0.0^0.10714285714285714^0.03571428571428571^0.0^0.0^56.0^0.5535714285714286^text
 ^0.6666666666666666^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public boolean mouseEnter(Event e, int x, int y) { theList.addItem("mouseEnter event at " + x + "," + y + ")"); return false; }^3.0^0.0^0.2222222222222222^0.2777777777777778^0.06338028169014084^0.028169014084507043^18.0^0.05555555555555555^text
 ^1.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
mouseExit^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 Your applet receives a mouseExit event whenever the cursor leaves your applet. You'll also receive the coordinates of the point at which the cursor exited your applet.^0.0^0.0^0.14814814814814814^0.0^0.0^0.0^27.0^0.5185185185185185^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public boolean mouseExit(Event e, int x, int y) { theList.addItem("mouseExit event at (" + x + "," + y + ")"); return false; }^2.75^0.0^0.2222222222222222^0.2777777777777778^0.07142857142857142^0.02857142857142857^18.0^0.05555555555555555^text
 ^1.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
getFocus^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public void getFocus() { theList.addItem("getFocus event"); }^2.6666666666666665^0.0^0.5714285714285714^0.2857142857142857^0.09859154929577464^0.0^7.0^0.0^text
 ^1.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
gotFocus ^1.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
public void gotFocus() { theList.addItem("gotFocus event"); } ^2.0^0.0^0.5714285714285714^0.2857142857142857^0.09090909090909091^0.0^7.0^0.0^text
lostFocus^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public void lostFocus() { theList.addItem("lostFocus event"); }^2.6666666666666665^0.0^0.5714285714285714^0.2857142857142857^0.0958904109589041^0.0^7.0^0.0^text
 ^1.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
keyDown ^1.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 A keydown event is generated whenever the user presses a key while your applet is active. An integer keycode is returned indicating which key was pressed. As a general rule you'll want to cast this to a char to get the actual letter.^0.0^0.0^0.06976744186046512^0.06976744186046512^0.0^0.0^43.0^0.46511627906976744^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public boolean keyDown(Event e, int x) { theList.addItem("The " + (char) x + " key was pressed."); return false; }^3.0^0.0^0.17647058823529413^0.29411764705882354^0.07751937984496124^0.015503875968992248^17.0^0.11764705882352941^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Here's the revised EventTutor Applet:^0.0^0.0^0.4^0.0^0.0^0.02564102564102564^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Drawing Text^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Drawing Graphics: Lines, Circles, Rectangles and Colors^0.0^0.0^0.0^0.0^0.0^0.01818181818181818^7.0^0.14285714285714285^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Drawing Rectangles^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 Next we'll write an applet that fills the screen with lots of randomly sized and positioned rectangles in the style of Piet Mondrian. In the process we'll learn the basics of applet graphics. We're going to take this one step at a time, adding a bit as we go. ^0.14285714285714285^0.0^0.04081632653061224^0.02040816326530612^0.0^0.0^49.0^0.5306122448979592^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
In the first applet we'll just draw a rectangle on the screen. We'll get the size of the applet as specified in the HTML file, and then we'll draw a rectangle around the applet to frame it. Here's the code:^0.0^0.0^0.1^0.0^0.0^0.004761904761904762^40.0^0.625^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Draw a rectangle import java.applet.*; import java.awt.*; public class Mondrian1 extends Applet { int height, width; public void init() { Dimension d = size(); height = d.height; width = d.width; repaint(); } public void paint(Graphics g) { g.drawRect(0, 0, width, height); } }^1.44^1.0^0.15384615384615385^0.2564102564102564^0.06779661016949153^0.014124293785310734^39.0^0.02564102564102564^text
 Compile this applet; move the resulting class file to your classes directory, and create an HTML file that points to it. Set the height of the applet to 300 pixels and the width to 300 pixels as well. Load that file into your browser and what do you see? Probably not what you expected. You should see half a rectangle. What happened to the other half?^0.1^0.0^0.046875^0.046875^0.0027247956403269754^0.005449591280653951^64.0^0.5625^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
This is called a ^0.0^0.0^0.0^0.25^0.0^0.0^4.0^0.5^text
fencepost error.^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 The applet lives in a square 300 pixels tall by 300 pixels wide. However the upper left hand corner of the applet starts at (0, 0), not at (1, 1). This means that the applet includes the points with x and y coordinates between 0 and 299, not between 0 and 300. We drew a rectangle 301 pixels high and 301 pixels wide so the edges were chopped off.^0.14285714285714285^0.0^0.05263157894736842^0.017543859649122806^0.011267605633802818^0.0^57.0^0.49122807017543857^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
This is fortuitous however. Not only does it allow me the opportunity to digress on fencepost errors (which, although annoying, are far less dangerous in Java than in C since Java does check array boundaries) but it also shows us something else. In Java the coordinate system for an applet begins in the upper left hand corner and increases to the right and down. This is common in computer graphics but is different from the Cartesian coordinate system where the direction of increasing y is generally assumed to be up.^0.0^0.0^0.011111111111111112^0.044444444444444446^0.0037735849056603774^0.0^90.0^0.5111111111111111^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Correcting the fence post error is easy. We just change ^0.0^0.0^0.0^0.0^0.0^0.0^10.0^0.3^text
g.drawRect(0, 0, width, height);^0.0^0.0^0.25^0.0^0.09375^0.0^4.0^0.0^text
 to ^0.5^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
g.drawRect(0, 0, width-1, height-1);^0.0^0.0^0.25^0.0^0.08333333333333333^0.0^4.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Draw a rectangle import java.applet.*; import java.awt.*; public class Mondrian2 extends Applet { int height, width; public void init() { Dimension d = size(); height = d.height; width = d.width; repaint(); } public void paint(Graphics g) { g.drawRect(0, 0, width-1, height-1); } }^1.44^1.0^0.15384615384615385^0.2564102564102564^0.0670391061452514^0.013966480446927373^39.0^0.02564102564102564^text
 As usual compile this and load it into your browser. If the problem isn't fixed check to make sure that you moved the new class file into the classes directory and that you modified the HTML file to point to Mondrian2.^0.0^0.0^0.04878048780487805^0.0975609756097561^0.0^0.0^41.0^0.4634146341463415^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
We've introduced exactly one new statement in all this code, ^0.0^0.0^0.0^0.2^0.0^0.0^10.0^0.4^text
drawRect^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 which is a method in the Graphics class. The line ^0.5^0.0^0.0^0.1^0.0^0.0^10.0^0.6^text
g.drawRect(0, 0, height-1, width-1)^0.0^0.0^0.25^0.0^0.05714285714285714^0.0^4.0^0.0^text
 instructs the Graphics class ^0.0^0.0^0.0^0.25^0.0^0.0^4.0^0.25^text
g^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 to draw a rectangle beginning at the point (0, 0) and ending at the point (299, 299). ^0.5^0.0^0.0^0.0^0.045454545454545456^0.0^13.0^0.5384615384615384^text
 This particular rectangles encompasses the entire applet's visible space. There is nothing to keep us from drawing outside the applet, in fact we did exactly that in our first version where we actually extended the rectangle to (300, 300); but anything we draw there won't be seen by the user.^0.16666666666666666^0.0^0.041666666666666664^0.020833333333333332^0.009933774834437087^0.0^48.0^0.5416666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The drawRect method draws an open rectangle. If we want to draw a filled rectangle we use the fillRect method. Otherwise the syntax is identical. In Mondrian3 we'll draw a filled rectangle in the center of the applet. Here's the code:^0.0^0.0^0.0975609756097561^0.024390243902439025^0.0^0.004132231404958678^41.0^0.4634146341463415^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Draw a rectangle import java.applet.*; import java.awt.*; public class Mondrian3 extends Applet { int AppletHeight; int AppletWidth; int RectHeight; int RectWidth; int RectTop; int RectLeft; public void init() { Dimension d = size(); AppletHeight = d.height; AppletWidth = d.width; RectHeight = AppletHeight/3; RectWidth = AppletWidth/3; RectTop = (AppletHeight - RectHeight)/2; RectLeft= (AppletWidth - RectWidth)/2; repaint(); } public void paint(Graphics g) { g.drawRect(0, 0, AppletWidth-1, AppletHeight-1); g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1); } } ^1.7837837837837838^1.0^0.484375^0.234375^0.05763688760806916^0.018731988472622477^64.0^0.015625^text
 This latest example also demonstrates one other thing. Until now you may have thought that we were passing two points to the drawRect and fillRect methods and drawing the rectangle that joins them. This is how rectangles are implemented in QuickDraw on the Mac for example. However if that was the case the preceding rectangle would have been drawn between (100, 100) and (100, 100), a fairly small rectangle. Since that isn't the case our association of the last two variables with width and height must be correct.^0.0^0.0^0.03571428571428571^0.07142857142857142^0.007590132827324478^0.0^84.0^0.5833333333333334^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The extremely astute reader may object at this point. Until now we've only drawn squares. Although the last two variables passed to drawRect and fillRect must be the height and the width how do we know which is which? The simplest way to tell is to write a test program that draws a non-square rectangle. Let's try that now:^0.0^0.0^0.03333333333333333^0.05^0.0^0.0060790273556231^60.0^0.5333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Draw a rectangle import java.applet.Applet; import java.awt.*; public class Mondrian4 extends Applet { int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight; public void init() { Dimension d = size(); AppletHeight = d.height; AppletWidth = d.width; RectHeight = AppletHeight/3; RectWidth = (AppletWidth*2)/3; RectTop = (AppletHeight - RectHeight)/2; RectLeft= (AppletWidth - RectWidth)/2; repaint(); } public void paint(Graphics g) { g.drawRect(0, 0, AppletWidth-1, AppletHeight-1); g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1); } }^1.6129032258064515^1.0^0.5333333333333333^0.16666666666666666^0.05606060606060606^0.019696969696969695^60.0^0.016666666666666666^text
 So you see that the third argument is indeed the width and the fourth is the height.^0.0^0.0^0.0^0.0^0.0^0.0^17.0^0.7647058823529411^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Now that we've learned how to draw rectangles, both filled and unfilled, let's make life a little more exciting by randomly selecting the position and size of the rectangle. To do this we'll need the Math.random() method from java.lang.Math. This method returns a double between 0.0 and 1.0 so we'll need to multiply the result by the applet's height and width to get a reasonably sized rectangle that fits into our applet space. To do this we'll create the following Randomize method:^0.0^0.0^0.024096385542168676^0.07228915662650602^0.004032258064516129^0.0020161290322580645^83.0^0.4457831325301205^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
private int Randomize( int range ) { double rawResult; rawResult = Math.random(); return (int) (rawResult * range); }^1.0^0.0^0.21428571428571427^0.42857142857142855^0.0962962962962963^0.014814814814814815^14.0^0.0^text
 This method forces the result of Math.random into an ^0.0^0.0^0.0^0.1^0.0^0.0^10.0^0.4^text
int^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 in the range we require. Pay special attention to the last line. When you see a raw type in parentheses like ^0.5^0.0^0.0^0.0^0.0^0.0^21.0^0.5238095238095238^text
(int)^0.0^0.0^0.0^1.0^0.4^0.0^1.0^0.0^text
 or ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
(float)^0.0^0.0^0.0^1.0^0.2857142857142857^0.0^1.0^0.0^text
 it's a ^1.0^0.0^0.0^0.0^0.0^0.0^2.0^1.0^text
cast^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
. Casts change one value type into another. Thus here we're changing a ^0.0^0.0^0.0^0.0^0.0^0.0^12.0^0.5833333333333334^text
double^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 into an ^1.0^0.0^0.0^0.0^0.0^0.0^2.0^1.0^text
int^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
. The cast rounds as necessary.^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Casting in Java is safer than in C or other languages that allow arbitrary casting. Java only lets casts occur when they make sense, such as a cast between a ^0.0^0.0^0.0^0.0^0.0^0.0^30.0^0.5^text
float^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 and an ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^1.0^text
int^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
. However you can't cast between an ^0.0^0.0^0.0^0.0^0.0^0.0^6.0^0.6666666666666666^text
int^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 and a ^1.0^0.0^0.0^0.0^0.0^0.0^2.0^1.0^text
String^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 for example.^1.0^0.0^0.0^0.5^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Draw a rectangle import java.applet.Applet; import java.awt.*; public class Mondrian5 extends Applet { int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight; public void init() { Dimension d = size(); AppletHeight = d.height; AppletWidth = d.width; RectTop = Randomize(AppletHeight); RectLeft= Randomize(AppletWidth); RectHeight = Randomize(AppletHeight - RectTop); RectWidth = Randomize(AppletWidth - RectLeft); repaint(); } public void paint(Graphics g) { g.drawRect(0, 0, AppletWidth-1, AppletHeight-1); g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1); } private int Randomize(int range) { double rawResult; rawResult = Math.random(); return (int) (rawResult * range); } }^1.7560975609756098^1.0^0.44871794871794873^0.20512820512820512^0.06212664277180406^0.011947431302270013^78.0^0.01282051282051282^text
 Occasionally this applet does randomly produce a rectangle that's two small to see so if you don't see anything, reload it. Reload it a few times. Each time you'll see a rectangle of a different size appear in a different place. ^0.0^0.0^0.024390243902439025^0.07317073170731707^0.0^0.0^41.0^0.5121951219512195^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Let's make our world a little more colorful. To do this we'll change the rectangle color to red. To do this we'll use a new methods setColor(), part of the Graphics class. ^0.0^0.0^0.03125^0.1875^0.011235955056179775^0.0^32.0^0.40625^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Draw a colored rectangle import java.applet.Applet; import java.awt.*; public class Mondrian6 extends Applet { int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight; public void init() { Dimension d = size(); AppletHeight = d.height; AppletWidth = d.width; RectTop = Randomize(AppletHeight); RectLeft= Randomize(AppletWidth); RectHeight = Randomize(AppletHeight - RectTop); RectWidth = Randomize(AppletWidth - RectLeft); repaint(); } public void paint(Graphics g) { // g.setBackground(Color.white); g.setColor(Color.red); g.drawRect(0, 0, AppletWidth-1, AppletHeight-1); g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1); } private int Randomize(int range) { double rawResult; rawResult = Math.random(); return (int) (rawResult * range); } } ^1.7954545454545454^2.0^0.42528735632183906^0.1839080459770115^0.06359649122807018^0.010964912280701754^87.0^0.011494252873563218^text
 The awt predefines a number of colors including:^0.0^0.0^0.25^0.0^0.0^0.018867924528301886^8.0^0.375^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
black ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
blue ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
cyan ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
darkGray ^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
gray ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
green ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
lightGray ^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
magenta ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
orange ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
pink ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
red ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
white ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
yellow ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 If these aren't sufficient for your needs, you can define others using the same RGB triple that's used to set background colors on many web pages. You even get to use decimal numbers instead of the hex values you have to use for the bgcolor tag. For example to select a medium gray you'd use ^0.0^0.0^0.03636363636363636^0.07272727272727272^0.0^0.0^55.0^0.45454545454545453^text
Color(127, 127, 127)^0.0^0.0^0.0^0.0^0.1^0.0^1.0^0.0^text
. Pure white would be ^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
Color(255, 255, 255)^0.0^0.0^0.0^0.0^0.1^0.0^1.0^0.0^text
. Pure red is ^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
(255, 0, 0)^0.0^0.0^0.0^0.0^0.18181818181818182^0.0^0.0^0.0^text
 and so on. ^1.0^0.0^0.0^0.0^0.0^0.0^3.0^1.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
By using the color constructor we can expand our program to select not only a random rectangle but also a random color for the rectangle. Here's the code:^0.0^0.0^0.0^0.03571428571428571^0.0^0.00641025641025641^28.0^0.5357142857142857^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Draw a randomly colored rectangle import java.applet.Applet; import java.awt.*; public class Mondrian7 extends Applet { int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight; Color RectColor; public void init() { Dimension d = size(); AppletHeight = d.height; AppletWidth = d.width; RectTop = Randomize(AppletHeight); RectLeft= Randomize(AppletWidth); RectHeight = Randomize(AppletHeight - RectTop); RectWidth = Randomize(AppletWidth - RectLeft); RectColor = new Color(Randomize(255),Randomize(255),Randomize(255)); repaint(); } public void paint(Graphics g) { // g.setBackground(Color.white); g.setColor(RectColor); g.drawRect(0, 0, AppletWidth-1, AppletHeight-1); g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1); } private int Randomize(int range) { double rawResult; rawResult = Math.random(); return (int) (rawResult * range); } }^1.8888888888888888^2.0^0.42105263157894735^0.17894736842105263^0.06712734452122408^0.01085883514313919^95.0^0.010526315789473684^text
 In the next example we're going to draw multiple randomly sized, randomly colored rectangles. Since we want each rectangle to be different we're going to have to move the calculation of the rectangle's shape, position and color into the paint() method. Here's the code:^0.0^0.0^0.0^0.0^0.007246376811594203^0.0036231884057971015^44.0^0.5227272727272727^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Draw many randomly colored rectangles import java.applet.Applet; import java.awt.*; public class Mondrian8 extends Applet { int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight; Color RectColor; int numberRectangles = 100; public void init() { Dimension d = size(); AppletHeight = d.height; AppletWidth = d.width; repaint(); } public void paint(Graphics g) { g.setColor(Color.black); g.drawRect(0, 0, AppletWidth-1, AppletHeight-1); for (int i=0; i < numberRectangles; i++) { RectTop = Randomize(AppletHeight); RectLeft= Randomize(AppletWidth); RectHeight = Randomize(AppletHeight - RectTop); RectWidth = Randomize(AppletWidth - RectLeft); RectColor = new Color(Randomize(255),Randomize(255),Randomize(255)); g.setColor(RectColor); g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1); } } private int Randomize(int range) { double rawResult; rawResult = Math.random(); return (int) (rawResult * range); } } ^2.32^1.0^0.4077669902912621^0.1941747572815534^0.06690454950936664^0.013380909901873328^103.0^0.009708737864077669^text
 Finally let's let the HTML specify the number of rectangles to be drawn in one pass. We'll keep the default value as is and only replace it if the HTML includes a Number PARAM.^0.0^0.0^0.08823529411764706^0.08823529411764706^0.0^0.0^34.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Draw many random rectangles import java.applet.Applet; import java.awt.*; public class Mondrian9 extends Applet { int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight; Color RectColor; int numberRectangles = 100; public void init() { Dimension d = size(); AppletHeight = d.height; AppletWidth = d.width; String s = getParameter("Number"); if (s != null) { numberRectangles = Integer.valueOf(s).intValue(); } repaint(); } public void paint(Graphics g) { g.setColor(Color.black); g.drawRect(0, 0, AppletWidth-1, AppletHeight-1); for (int i=0; i < numberRectangles; i++) { RectTop = Randomize(AppletHeight); RectLeft= Randomize(AppletWidth); RectHeight = Randomize(AppletHeight - RectTop); RectWidth = Randomize(AppletWidth - RectLeft); RectColor = new Color(Randomize(255),Randomize(255),Randomize(255)); g.setColor(RectColor); g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1); } } private int Randomize(int range) { double rawResult; rawResult = Math.random(); return (int) (rawResult * range); } } ^2.4814814814814814^1.0^0.40350877192982454^0.18421052631578946^0.07033144704931285^0.014551333872271624^114.0^0.008771929824561403^text
 That's all for now, but we'll return to Mondrian at the end of this chapter when we add threading, and show how to draw rectangles continuously.^0.0^0.0^0.0^0.11538461538461539^0.0^0.0^26.0^0.5769230769230769^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Exercises^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
For the artistically inclined: write a version of Mondrian that draws pictures that are more believably in the style of Piet Mondrian. You should probably restrict your color choices and not allow rectangles to overlap.^0.0^0.0^0.0^0.02857142857142857^0.0^0.0045045045045045045^35.0^0.45714285714285713^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Drawing Lines^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 The awt contains several graphics primitives. Rectangles are one and we've pretty much beaten them into the ground in the previous section. Lines are another. Within a graphics context there is one key line drawing method, ^0.0^0.0^0.027777777777777776^0.0^0.0^0.0^36.0^0.5277777777777778^text
drawLine(int x1, int y1, int x2, int y2)^0.0^0.0^0.5555555555555556^0.4444444444444444^0.05^0.0^9.0^0.0^text
. This method draws a straight line between the point (x1, y1) and the point (x2, y2). Here's a simple applet that draws a line diagonally across the applet frame:^0.0^0.0^0.20689655172413793^0.034482758620689655^0.023952095808383235^0.005988023952095809^29.0^0.3793103448275862^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
import java.applet.Applet; import java.awt.*; public class SimpleLine extends Applet { int AppletHeight, AppletWidth; public void init() { Dimension d = size(); AppletHeight = d.height; AppletWidth = d.width; } public void paint(Graphics g) { g.drawLine(0, 0, AppletWidth, AppletHeight); } } ^1.2857142857142858^0.0^0.3611111111111111^0.2777777777777778^0.05965909090909091^0.011363636363636364^36.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Graphing Functions^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 We're now going to demonstrate the use of the ^0.0^0.0^0.0^0.0^0.0^0.0^9.0^0.6666666666666666^text
drawLine()^0.0^0.0^1.0^0.0^0.2^0.0^1.0^0.0^text
 method to draw considerably non-straight figures. It is shown in advanced calculus that any reasonably well-behaved (should that be differentiable?) function can be approximated arbitrarily well by straight lines where quantities like &well-behaved" and "arbitrarily are precisely defined. I'll spare you the details of the mathematical proof, but I will demonstrate its probability to you by producing an applet that does a very good job of graphing any function you care to throw at it. As usual we'll develop it in pieces rather than just throwing it all out at once.^0.09090909090909091^0.0^0.010638297872340425^0.010638297872340425^0.003436426116838488^0.003436426116838488^94.0^0.5106382978723404^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
We begin with the skeleton applet. We'll need to add some code to the paint method of the applet to make it draw something. Let's begin by drawing a sine wave from the left hand side of the image to the right hand side. Here's the complete program:^0.0^0.0^0.041666666666666664^0.0^0.0^0.003937007874015748^48.0^0.5208333333333334^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
import java.applet.*; import java.awt.*; public class GraphApplet extends Applet { int x0, xN, y0, yN; public void init() { // How big is the applet? Dimension d = size(); x0 = 0; xN = d.width-1; y0=0; yN=d.height-1; } public void paint(Graphics g) { for (int x = x0; x < xN; x++) { g.drawLine(x,(int) (yN*Math.sin(x)),x+1, (int) (yN*Math.sin(x+1))); } } }^2.6153846153846154^1.0^0.3114754098360656^0.22950819672131148^0.08874458874458875^0.032467532467532464^61.0^0.04918032786885246^text
 The meat of this applet is in the for loop of the paint method.^0.0^0.0^0.07142857142857142^0.14285714285714285^0.0^0.0^14.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 for (int x = x0; x < xN; x++) { g.drawLine(x,(int) (yN*Math.sin(x)),x+1, (int) (yN*Math.sin(x+1))); }^4.666666666666667^0.0^0.23809523809523808^0.19047619047619047^0.1794871794871795^0.05982905982905983^21.0^0.0^text
 Here we loop across every x pixel of the applet. At each one we calculate the sine of that pixel. We also calculate the sine of the next pixel. This gives us two 2-D points and we draw a line between them. Since the sine of a real number is always between one and negative one, we scale the y value by yN. Finally we cast the y values to ints since sines are fundamentally floating point values but drawLine requires ints.^0.4^0.0^0.06097560975609756^0.024390243902439025^0.0^0.0^82.0^0.5487804878048781^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
This applet runs but it's got a lot of problems. All of them can be related to two factors:^0.0^0.0^0.05263157894736842^0.05263157894736842^0.0^0.010752688172043012^19.0^0.5789473684210527^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Sines are floating point operations. To do a really useful graphing applet we need to be able to use floating point numbers.^0.0^0.0^0.045454545454545456^0.045454545454545456^0.0^0.0^22.0^0.3181818181818182^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The coordinate system of an applet counts from (0,0) at the upper left hand corner to the right and down. The standard Cartesian coordinate system we expect graphs to use counts from (0,0) in the lower left hand corner to the right and up. The origin can be moved in both systems, for instance to the center of the applet, but we still need to transform between the y down and the y up coordinates.^0.0^0.0^0.0273972602739726^0.0136986301369863^0.009852216748768473^0.0^73.0^0.5342465753424658^text
 There are a number of ways we can resolve this. The key to all of them, however, is to separate the data from the display. Since we are graphing more or less well behaved mathematical functions, we can assume that our data is completely described by a rectangle in Cartesian space within which we wish to plot a function. The display, on the other hand, is described by a rectangle of discrete points of fixed size and width. We need to be able to calculate in the general Cartesian plane and display in the particular applet window.^0.0^0.0^0.010309278350515464^0.010309278350515464^0.0^0.0^97.0^0.5773195876288659^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
We'll need a method that will convert a point in the applet window into a point in the Cartesian plane, and one that will convert it back. Here it is:^0.0^0.0^0.03333333333333333^0.0^0.0^0.006535947712418301^30.0^0.6666666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
import java.applet.*; import java.awt.*; public class GraphApplet extends Applet { int x0, xN, y0, yN; double xmin, xmax, ymin, ymax; int AppletHeight, AppletWidth; public void init() { // How big is the applet? Dimension d = size(); AppletHeight = d.height; AppletWidth = d.width; x0 = 0; xN = AppletWidth-1; y0=0; yN=AppletHeight-1; xmin = -10.0; xmax = 10.0; ymin = -1.0; ymax = 1.0; } public void paint(Graphics g) { double x1,y1,x2,y2; int i, j1, j2; j1 = yvalue(0); for (i = 0; i < AppletWidth; i++) { j2 = yvalue(i+1); g.drawLine(i, j1 ,i+1, j2); j1 = j2; } } private int yvalue(int ivalue) { // Given the xpoint we're given calculate the Cartesian equivalent double x, y; int jvalue; x = (ivalue * (xmax - xmin)/(AppletWidth - 1)) + xmin; // Take the sine of that x y = Math.sin(x); // Scale y into window coordinates jvalue = (int) ((y - ymin)*(AppletHeight - 1)/(ymax - ymin)); // Switch jvalue from cartesian coordinates to computer graphics coordinates jvalue = AppletHeight - jvalue; return jvalue; } }^3.096774193548387^5.0^0.4375^0.1597222222222222^0.05764796310530361^0.02382782475019216^144.0^0.09722222222222222^text
 Run this applet. Isn't that a much nicer looking sine wave? There are still a number of things we can add to make this a more complete applet though. The most important would be to add some parameters so that we can define the size of the applet in HTML. The following modification of the init and paint methods looks for xmin, xmax, ymin, and ymax to be specified via parameters. However for robustness if the author of the HTML forgets to specify them we supply some reasonable default values.^0.3333333333333333^0.0^0.1111111111111111^0.06666666666666667^0.0^0.0019305019305019305^90.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
import java.applet.*; import java.awt.*; public class GraphApplet extends Applet { int x0, xN, y0, yN; double xmin, xmax, ymin, ymax; int AppletHeight, AppletWidth; public void init() { String ParamString; // How big is the applet? Dimension d = size(); AppletHeight = d.height; AppletWidth = d.width; x0 = 0; xN = AppletWidth-1; y0=0; yN=AppletHeight-1; ParamString = getParameter("xmin"); if (ParamString != null) { xmin = Double.valueOf(ParamString).doubleValue(); } else { xmin = -1.0; } ParamString = getParameter("xmax"); if (ParamString != null) { xmax = Double.valueOf(ParamString).doubleValue(); } else { xmax = 1.0; } ParamString = getParameter("ymax"); if (ParamString != null) { ymax = Double.valueOf(ParamString).doubleValue(); } else { ymax = 1.0; } ParamString = getParameter("ymin"); if (ParamString != null) { ymin = Double.valueOf(ParamString).doubleValue(); } else { ymin = -1.0; } } public void paint(Graphics g) { double x1,y1,x2,y2; int i, j1, j2; j1 = yvalue(0); for (i = 0; i < AppletWidth; i++) { j2 = yvalue(i+1); g.drawLine(i, j1 ,i+1, j2); j1 = j2; } } private int yvalue(int ivalue) { // Given the xpoint we're given calculate the Cartesian equivalent double x, y; int jvalue; x = (ivalue * (xmax - xmin)/(AppletWidth - 1)) + xmin; // Take the sine of that x y = Math.sin(x); // Scale y into window coordinates jvalue = (int) ((y - ymin)*(AppletHeight - 1)/(ymax - ymin)); // Switch jvalue from cartesian coordinates to computer graphics coordinates jvalue = AppletHeight - jvalue; return jvalue; } }^3.5402298850574714^5.0^0.4948453608247423^0.18041237113402062^0.06741573033707865^0.021961184882533197^194.0^0.07216494845360824^text
 Now we can adjust the range over which we graph without modifying our code!^1.0^0.0^0.0^0.0^0.0^0.011904761904761904^14.0^0.6428571428571429^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
So far we've only graphed sine functions. It should be obvious how to modify the code to graph cosines or many other kinds of functions. However what if we want to define the function at runtime?^0.0^0.0^0.0^0.027777777777777776^0.0^0.0050^36.0^0.5555555555555556^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Exercises^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Add labeled coordinate axes to the graph.^0.0^0.0^0.0^0.0^0.0^0.0^7.0^0.2857142857142857^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Our graph method handled mathematical functions. How would you need to change it and what features would you add to make it suitable for plotting discrete experimental data?^0.0^0.0^0.0^0.03571428571428571^0.0^0.005649717514124294^28.0^0.42857142857142855^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
An infinite set that with zero length^0.0^0.0^0.0^0.0^0.0^0.0^7.0^0.42857142857142855^text
 We're now going to use Java to implement some classic examples of fractal geometry. We'll do three of these. We begin with a one-dimensional set with an infinite number of points that covers zero length. Then we'll investigate the Koch snowflake. Finally in the next chapter we'll delve into the most famous fractal of all, the Mandelbrot set.^0.0^0.0^0.0^0.03389830508474576^0.0^0.0^59.0^0.5254237288135594^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The middle third set is defined by starting with all the real numbers between zero and one inclusive. Then we cut out the middle third of that set (exclusive of the endpoints). i.e. everything between one third and two thirds exclusive.^0.0^0.0^0.0^0.0^0.008333333333333333^0.0^42.0^0.5714285714285714^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Next we cut the middle third of the two line segments that remain, i.e. everything between one ninth and two ninths and between seven ninths and eight ninths. We continue this process indefinitely.^0.0^0.0^0.0^0.058823529411764705^0.0^0.0^34.0^0.5294117647058824^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Was that confusing? Good. A picture is worth a thousand words and a good Java program is worth a thousand pictures. We now proceed to show you a Java program that draws successive pictures to demonstrate the middle third set.^0.0^0.0^0.0^0.0^0.0^0.004366812227074236^40.0^0.475^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 import java.applet.Applet; import java.awt.*; import java.util.Vector; public class MiddleThird extends Applet { int AppletWidth; int AppletHeight; Vector endpoints = new Vector(); public void init() { Dimension d = size(); AppletHeight = d.height; AppletWidth = d.width; endpoints.addElement(new Float(0.0f)); endpoints.addElement(new Float(1.0f)); } public void paint(Graphics g) { float x1, x2; Float tempFloat; for (int i = 0; i < AppletHeight; i+= 5) { // draw the lines for (int j=0; j < endpoints.size(); j += 2) { tempFloat = (Float) endpoints.elementAt(j); x1 = tempFloat.floatValue(); tempFloat = (Float) endpoints.elementAt(j+1); x2 = tempFloat.floatValue(); g.drawLine( Math.round(x1*AppletWidth), i, Math.round(x2*AppletWidth), i); } //remove the middle third of the lines CutSegments(); // Now check to see if we've exceeded the resolution of our screen tempFloat = (Float) endpoints.elementAt(0); x1 = tempFloat.floatValue(); tempFloat = (Float) endpoints.elementAt(1); x2 = tempFloat.floatValue(); if (Math.round(x1*AppletWidth) == Math.round(x2*AppletWidth)) break; } } private void CutSegments() { int index = 0; float gap; float x1, x2; Float tempFloat1, tempFloat2; int stop = endpoints.size(); for (int i=0; i < stop; i+=2) { CutMiddleThird(index, index+1); index += 4; } } private void CutMiddleThird(int left, int right) { float gap; float x1, x2; Float tempFloat1, tempFloat2; tempFloat1 = (Float) endpoints.elementAt(left); tempFloat2 = (Float) endpoints.elementAt(right); gap = tempFloat2.floatValue() - tempFloat1.floatValue(); x1 = tempFloat1.floatValue() + gap/3.0f; x2 = tempFloat2.floatValue() - gap/3.0f; endpoints.insertElementAt(new Float(x2), right); endpoints.insertElementAt(new Float(x1), right); } } ^2.7^3.0^0.35874439461883406^0.23318385650224216^0.07610276296655356^0.019389238972370333^223.0^0.053811659192825115^text
 Compile and load this applet. Is that clearer? Of course this isn't a perfect representation of the middle third set since we have to deal with points of finite size rather than with genuine mathematical points. Depending on how large a window you give your applet, you will probably only see about six to twelve iterations before we need to start working with fractional pixels.^0.0^0.0^0.03076923076923077^0.03076923076923077^0.0^0.0025380710659898475^65.0^0.5538461538461539^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Flying Lines^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 The next example is harder to describe than it is to code. Like Mondrian it runs in an infinite loop but it's a little more than random images. Compile the following code, run it and then look over the code to see if you can understand the algorithm.^0.0^0.0^0.0^0.020833333333333332^0.0^0.0^48.0^0.5833333333333334^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Bounce lines around in a box import java.applet.Applet; import java.awt.*; public class FlyingLines extends Applet { int NUM_LINES = 25; int gDeltaTop=3, gDeltaBottom=3; int gDeltaLeft=2, gDeltaRight=6; int AppletWidth, AppletHeight; int gLines[][] = new int[NUM_LINES][4]; public void init() { AppletWidth = size().width; AppletHeight = size().height; } public void start() { gLines[0][0] = Randomize(AppletWidth); gLines[0][1] = Randomize(AppletHeight); gLines[0][2] = Randomize(AppletWidth); gLines[0][3] = Randomize(AppletHeight); for (int i=1; i < NUM_LINES; i++ ) { LineCopy(i, i-1); RecalcLine(i); } repaint(); } public void paint(Graphics g) { while (true) { for (int i=NUM_LINES - 1; i > 0; i--) { LineCopy(i, i-1); } RecalcLine(0); g.setColor(Color.black); g.drawLine(gLines[0][0], gLines[0][1], gLines[0][2], gLines[0][3]); g.setColor(getBackground()); g.drawLine(gLines[NUM_LINES-1][0], gLines[NUM_LINES-1][1], gLines[NUM_LINES-1][2], gLines[NUM_LINES-1][3]); } } private void LineCopy (int to, int from) { for (int i = 0; i < 4; i++) { gLines[to][i] = gLines[from][i]; } } public int Randomize( int range ) { double rawResult; rawResult = Math.random(); return (int) (rawResult * range); } private void RecalcLine( int i ) { gLines[i][1] += gDeltaTop; if ((gLines[i][1] < 0) || (gLines[i][1] > AppletHeight)) { gDeltaTop *= -1; gLines[i][1] += 2*gDeltaTop; } gLines[i][3] += gDeltaBottom; if ( (gLines[i][3] < 0) || (gLines[i][3] > AppletHeight) ) { gDeltaBottom *= -1; gLines[i][3] += 2*gDeltaBottom; } gLines[i][0] += gDeltaLeft; if ( (gLines[i][0] < 0) || (gLines[i][0] > AppletWidth) ) { gDeltaLeft *= -1; gLines[i][0] += 2*gDeltaLeft; } gLines[i][2] += gDeltaRight; if ( (gLines[i][2] < 0) || (gLines[i][2] > AppletWidth) ) { gDeltaRight *= -1; gLines[i][2] += 2*gDeltaRight; } } //RecalcLine ends here } // FlyingLines ends here ^3.0631578947368423^3.0^0.43414634146341463^0.2048780487804878^0.12511013215859032^0.02290748898678414^205.0^0.04390243902439024^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Taking Action: Threads^0.0^0.0^0.0^0.0^0.0^0.045454545454545456^3.0^0.0^text
 Depending on your operating system and Java-enabled browser you may have noticed that the Mondrian and Flying Line programs tended to hog your CPU. On Windows NT HotJava stopped responding to my commands several thousand iterations into Mondrian, and I had to kill it from the Task List.^0.0^0.0^0.02040816326530612^0.0^0.0^0.0^49.0^0.4489795918367347^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The paint loops in both Mondrian and FlyingLines are ideal for a ^0.0^0.0^0.08333333333333333^0.08333333333333333^0.0^0.0^12.0^0.5^text
thread^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
, a separate stream of execution that takes place simultaneously and independently of everything else that might be happening (like responding to the programmer's insistence to "Quit!, Damnit!"). Without threads an entire program can be held up by one CPU intensive task or, as in Flying Lines, one infinite loop, intentional or otherwise.^0.0^0.0^0.0^0.019230769230769232^0.005780346820809248^0.005780346820809248^52.0^0.4807692307692308^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
As a general rule all CPU intensive tasks should be placed in their own threads. Here's one way to do it.^0.0^0.0^0.0^0.047619047619047616^0.0^0.0^21.0^0.5714285714285714^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Draw infinitely many random rectangles import java.applet.Applet; import java.awt.*; public class ThreadedMondrian extends Applet implements Runnable { int RectHeight, RectWidth, RectTop, RectLeft, AppletWidth, AppletHeight; Color RectColor; Thread kicker = null; int pause; public void init() { Dimension d = size(); AppletHeight = d.height; AppletWidth = d.width; repaint(); } public void paint(Graphics g) { g.setColor(Color.black); g.drawRect(0, 0, AppletWidth-1, AppletHeight-1); for (int i=0; i < 10; i++) { RandomRect(); g.setColor(RectColor); g.fillRect(RectLeft, RectTop, RectWidth-1, RectHeight-1); } } public void run() { Thread.currentThread().setPriority(Thread.MIN_PRIORITY); while (true) { // infinite loop repaint(); try { Thread.sleep(100); } catch (Exception e) { } } } public void start() { if (kicker == null) { kicker = new Thread(this); kicker.start(); } } public void stop() { kicker = null; } public void RandomRect() { RectTop = Randomize(AppletHeight); RectLeft = Randomize(AppletWidth); RectHeight= Randomize(AppletHeight - RectTop); RectWidth = Randomize(AppletWidth - RectLeft); RectColor = new Color(Randomize(255),Randomize(255),Randomize(255)); } private int Randomize(int range) { double rawResult; rawResult = Math.random(); return (int) (rawResult * range); } }^2.9473684210526314^2.0^0.3129251700680272^0.23809523809523808^0.07800982800982802^0.011056511056511056^147.0^0.006802721088435374^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
We added four key things to Mondrian to make it threaded and a lot more CPU friendly.^0.0^0.0^0.0^0.0^0.0^0.0^17.0^0.47058823529411764^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
We specified that our applet implements Runnable. ^0.0^0.0^0.2857142857142857^0.14285714285714285^0.0^0.0^7.0^0.42857142857142855^text
We added a run method. ^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.4^text
We added a start method. ^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.4^text
We added a stop method. ^0.0^0.0^0.0^0.0^0.0^0.0^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Let's look at them in more detail:^0.0^0.0^0.0^0.0^0.0^0.029411764705882353^7.0^0.7142857142857143^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Our applet implements Runnable ^0.0^0.0^0.5^0.25^0.0^0.0^4.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Run Method ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Start Method ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Stop Method ^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Here's a threaded version of Flying Lines.^0.0^0.0^0.0^0.0^0.0^0.0^7.0^0.42857142857142855^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Bounce lines around in a box import java.applet.Applet; import java.awt.*; public class FlyingLines extends Applet implements Runnable { int NUM_LINES = 25; int gDeltaTop=3, gDeltaBottom=3; int gDeltaLeft=2, gDeltaRight=6; int AppletWidth, AppletHeight; int gLines[][] = new int[NUM_LINES][4]; public void init() { AppletWidth = size().width; AppletHeight = size().height; } public void start() { gLines[0][0] = Randomize(AppletWidth); gLines[0][1] = Randomize(AppletHeight); gLines[0][2] = Randomize(AppletWidth); gLines[0][3] = Randomize(AppletHeight); for (int i=1; i < NUM_LINES; i++ ) { LineCopy(i, i-1); RecalcLine(i); } repaint(); Thread t = new Thread(this); t.start(); } public void run () { Thread.currentThread().setPriority(Thread.MIN_PRIORITY); while (true) { for (int i=NUM_LINES - 1; i > 0; i--) { LineCopy(i, i-1); } RecalcLine(0); System.out.println(gLines[0][0] + ", " + gLines[0][1] + "," + gLines[0][2] + ", " + gLines[0][3]); repaint(); try { Thread.currentThread().sleep(10); } catch (Exception e) { } } } public void paint(Graphics g) { for (int i=0; i < NUM_LINES; i++) { g.drawLine(gLines[i][0], gLines[i][1], gLines[i][2], gLines[i][3]); } } private void LineCopy (int to, int from) { for (int i = 0; i < 4; i++) { gLines[to][i] = gLines[from][i]; } } public int Randomize( int range ) { double rawResult; rawResult = Math.random(); return (int) (rawResult * range); } private void RecalcLine( int i ) { gLines[i][1] += gDeltaTop; if ((gLines[i][1] < 0) || (gLines[i][1] > AppletHeight)) { gDeltaTop *= -1; gLines[i][1] += 2*gDeltaTop; } gLines[i][3] += gDeltaBottom; if ( (gLines[i][3] < 0) || (gLines[i][3] > AppletHeight) ) { gDeltaBottom *= -1; gLines[i][3] += 2*gDeltaBottom; } gLines[i][0] += gDeltaLeft; if ( (gLines[i][0] < 0) || (gLines[i][0] > AppletWidth) ) { gDeltaLeft *= -1; gLines[i][0] += 2*gDeltaLeft; } gLines[i][2] += gDeltaRight; if ( (gLines[i][2] < 0) || (gLines[i][2] > AppletWidth) ) { gDeltaRight *= -1; gLines[i][2] += 2*gDeltaRight; } } //RecalcLine ends here } // FlyingLines ends here ^3.1272727272727274^3.0^0.3826086956521739^0.2217391304347826^0.12273086029992107^0.0244672454617206^230.0^0.0391304347826087^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Bozo Sort^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Some of the first compelling Java demos were ^0.0^0.0^0.0^0.0^0.0^0.0^8.0^0.625^text
graphical illustrations of several sorting methods^0.0^0.0^0.0^0.0^0.0^0.0^6.0^0.3333333333333333^text
 including quick sort, bubble sort and bidirectional bubblesort intended to show off the threading capabilities of Java. That's nice, but those methods eventually succeed within our lifetime. For an applet that truly puts threading to good use consider the following ^0.16666666666666666^0.0^0.05^0.025^0.0^0.0^40.0^0.375^text
bozo sort^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
. In bozo sort the same collection of differently sized sticks is thrown up in the air. If they land in sorted order, the algorithm stops. Otherwise we throw all the sticks in the air again. This algorithm runs in about O(N!) time where N is the number of sticks. It takes effectively infinite time for more than a dozen or so sticks. It's a horrible algorithm but a really great opportunity for threading.^0.0^0.0^0.0^0.06756756756756757^0.00477326968973747^0.002386634844868735^74.0^0.4594594594594595^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 class BozoSortAlgorithm extends SortAlgorithm { void sort(int a[]) { boolean sorted = false; while (!sorted) { int index1 = Randomize(a.length); int index2 = Randomize(a.length); int temp = a[index2]; a[index2] = a[index1]; a[index1] = temp; // Is a[] sorted? sorted = true; for (int i = 1; i < a.length; i++) { if (a[i-1] > a[i]) { sorted = false; break; } // end if } // end for } // end while } // end sort private int Randomize( int range ) { double rawResult; rawResult = Math.random(); return (int) (rawResult * range); } } // end BozoSortAlgorithm ^3.9444444444444446^6.0^0.15384615384615385^0.28205128205128205^0.08244680851063829^0.02127659574468085^78.0^0.15384615384615385^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
To actually run this you'll also need the ^0.0^0.0^0.0^0.125^0.0^0.0^8.0^0.5^text
SortItem^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 and ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
SortAlgorithm^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 classes from Sun.^0.5^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Interaction: Mouse and Keyboard Input^0.0^0.0^0.0^0.0^0.0^0.02702702702702703^5.0^0.2^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
You now have the tools to draw a lot of really cool animations and images on your web pages. This alone puts you leaps and bounds beyond the average web page designer. Still that's only half the point of applets. The other half is interaction with the user. Your applets can accept input from the user and respond to them. For the first time a web surfer can move beyond mere browsing to genuine participation.^0.0^0.0^0.02666666666666667^0.02666666666666667^0.0^0.0^75.0^0.52^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Mouse Input: Java Doodle^0.0^0.0^0.0^0.0^0.0^0.041666666666666664^4.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Here's a simple applet that lets you doodle with the mouse on an applet.^0.0^0.0^0.14285714285714285^0.0^0.0^0.0^14.0^0.5714285714285714^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
import java.applet.Applet; import java.awt.*; import java.util.Vector; public class JavaDoodle extends Applet { Vector points = new Vector(); public void paint(Graphics g) { int x1, y1, x2, y2; Point tempPoint; if (points.size() > 1) { tempPoint = (Point) points.elementAt(0); x1 = tempPoint.x; y1 = tempPoint.y; for (int i = 1; i < points.size(); i++) { tempPoint = (Point) points.elementAt(i); x2 = tempPoint.x; y2 = tempPoint.y; g.drawLine(x1, y1, x2, y2); x1 = x2; y1 = y2; } // end for } // end if } public boolean mouseDown(Event e, int x, int y) { points.addElement(new Point(x, y)); return true; } public boolean mouseDrag(Event e, int x, int y) { points.addElement(new Point(x, y)); repaint(); return true; } public boolean mouseUp(Event e, int x, int y) { points.addElement(new Point(x, y)); repaint(); return true; } } ^4.52^2.0^0.2923076923076923^0.25384615384615383^0.08201581027667984^0.01383399209486166^130.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Exercises^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Revise the applet so that it doesn't draw a line between the point where the mouse button was released and the point where it was pressed again. ^0.0^0.0^0.037037037037037035^0.0^0.0^0.0^27.0^0.5925925925925926^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Keyboard Input: TypeWriter^0.0^0.0^0.0^0.0^0.0^0.038461538461538464^3.0^0.0^text
 Here's a simple applet that uses the keyDown method to let you type some text.^0.0^0.0^0.13333333333333333^0.0^0.0^0.0^15.0^0.4666666666666667^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
import java.applet.Applet; import java.awt.Event; import java.awt.Graphics; public class typewriter extends Applet { int numcols = 80; int numrows = 25; int row = 0; int col = 0; char page[][] = new char[numrows][]; public void init() { for (int i = 0; i < numrows; i++) { page[i] = new char[numcols]; } for (int i = 0; i < numrows; i++) { for (int j = 0; j < numcols; j++) { page[i][j] = '\0'; } } } public boolean keyDown(Event e, int key) { char c = (char) key; switch (key) { case Event.HOME: row = 0; col = 0; break; case Event.END: row = numrows-1; col = numcols-1; break; case Event.UP: if (row > 0) row--; break; case Event.DOWN: if (row < numrows-1) row++; break; case Event.LEFT: if (col > 0) col--; else if (col == 0 && row > 0) { row--; col=numcols-1; } break; case Event.RIGHT: if (col < numcols-1) col++; else if (col == numcols-1 && row < numrows-1) { row++; col=0; } break; default: if (c == '\n' || c == '\r') { row++; col = 0; } else if (row < numrows) { if (col >= numcols) { col = 0; row++; } page[row][col] = c; col++; } else { // row >= numrows col++; } } repaint(); return true; } public void paint(Graphics g) { for (int i=0; i < numrows; i++) { String tempString = new String(page[i]); g.drawString(tempString, 5, 15*(i+1)); } } }^6.186813186813187^1.0^0.14917127071823205^0.3370165745856354^0.0780065005417118^0.03358613217768147^181.0^0.011049723756906077^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Part 4: Objects, Classes, Methods, and Interfaces^0.0^0.0^0.0^0.0^0.0^0.02^6.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
What is Object Oriented Programming?^0.0^0.0^0.0^0.0^0.0^0.027777777777777776^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Object Oriented Programming is the programming buzzword of the 90's. Everyone and everything advertises their products as object-oriented. But what does object oriented mean? To understand why object oriented programming is so revolutionary, let's take a brief glance back at the history of computing.^0.0^0.0^0.0^0.0^0.0^0.003257328990228013^45.0^0.4666666666666667^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The History of Programming^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Programming has always been guided by various methodologies. In the early days of computers, computer memories were quite small. Programs had to be loaded in by toggling switches on a panel. In these days it was possible for a programmer to keep track of every memory location and every machine instruction in his or her head. Since computer memories were so small (often just a few hundred bytes) and the machines so slow, program efficiency was the primary concern. Any program was acceptable as long as it worked. Algorithms were very closely tied to the capabilities of the specific machine they ran on. This is called machine language programming. The toggling of individual memory locations (by switch or other means) is called a ^0.0^0.0^0.0^0.032520325203252036^0.005333333333333333^0.0^123.0^0.5284552845528455^text
first-generation language^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
, and we're being very liberal with the definition of language. In a first generation language there is almost no abstraction.^0.0^0.0^0.0^0.0^0.0^0.0^20.0^0.7^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
As computers grew in power and memory, it was no longer possible for a programmer to keep track of what was happening at every location in the machine's physical memory. Card readers and assembly language were invented to make programming more feasible. In assembly language the programmer uses mnemonic codes like MOV to represent particular bit sequences. These codes mapped directly to individual instructions on the CPU, and memory was still addressed directly. One code meant exactly one CPU instruction. ^0.0^0.0^0.0125^0.0125^0.0^0.0^80.0^0.4^text
(More modern assembly languages don't always map as directly to the CPU as the older ones did.)^0.0^0.0^0.0^0.058823529411764705^0.020618556701030927^0.0^17.0^0.4117647058823529^text
 Algorithmically The philosophy of "Use whatever works" continued. ^0.5^0.0^0.125^0.0^0.0^0.0^8.0^0.375^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Assembly language was still a bear to deal with, especially as related to arrays and storage in memory. Therefore the first high-level programming language, Fortran, was invented to spare programmers from the pains of dealing with keeping track of the location of their variables in memory. ^0.0^0.0^0.0^0.0^0.0^0.0^47.0^0.48936170212765956^text
(It's interesting to note that this lesson has had to be learned again and again and again. The buggiest parts of C and C++ programs result from programmers being allowed to access arbitrary bytes of memory. Java has wisely removed this capability. 99 times out of a 100 you don't need it. A large part of training a C or C++ programmer to use Java, consists of convincing them of this fact.)^0.0^0.0^0.0^0.05714285714285714^0.004975124378109453^0.004975124378109453^70.0^0.4714285714285714^text
. Fortran was the first example of a third-generation language. In a third generation language you tell the computer the algorithms and data structures it should use to calculate the results you want; but you use more abstract logical and mathematical operators rather than directly manipulating addresses in memory and CPU instructions. In a third generation language, statements represent several machine instructions. Which instructions they represent may even depend on their context.^0.0^0.0^0.0^0.013888888888888888^0.002012072434607646^0.0^72.0^0.5138888888888888^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
These languages may be compiled or interpreted. In either case your program code needs to be translated into equivalent machine instructions. This level of abstraction made considerably more powerful algorithms and data structures possible. ^0.0^0.0^0.0^0.058823529411764705^0.0^0.0^34.0^0.4117647058823529^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Java is a very advanced third generation language. Most of the other computer languages you're probably familiar with, Fortran, Basic, C, C++, Cobol, Pascal, as well as most of the one's you're not familiar with (AppleScript, Frontier, Eiffel, Modula-3, ADA, PL/I, etc.) are also third-generation languages (or 3GL's for short).^0.0^0.0^0.038461538461538464^0.038461538461538464^0.012012012012012012^0.006006006006006006^52.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
When third generation languages were invented, they were supposed to make computers so easy to use even the CEO could write programs. This turned out not to be true. Fourth generation languages (or 4GL's for short) moved the abstraction level a step higher. In these languages you tell the computer what results you want rather telling it how to calculate those results. For instance you would ask for the total sales for the year, without specifying the loops necessary to sum all the sales of all the salespeople. SQL is the most popular fourth generation language.^0.0^0.0^0.010416666666666666^0.0625^0.0034662045060658577^0.0^96.0^0.4583333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Of all these languages there's no question that 3GL's have been the most successful by almost any measure. A number of different styles of 3GL programming and programming languages have sprung up, most learning from the experience and mistakes of its predecessors. Fortran (and its cousin Basic) were the first. They shared with assembly language an attitude of "Whatever works, no matter how ugly." They had limited flow control (essentially for loops and goto statements) and one data structure, the array. All variables were global and it was impossible to hide one part of the program from any other. Although it was possible to write maintainable, legible code in these languages, few people did.^0.0^0.0^0.02631578947368421^0.017543859649122806^0.005594405594405594^0.0^114.0^0.5526315789473685^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Pascal and C were the next widely successful languages. They made possible a style of programming known as ^0.0^0.0^0.0^0.0^0.0^0.0^18.0^0.5^text
structured programming^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
. Structured programming languages have many different flow control constructs (switch statements, while loops, and more) as well as tools for more complicated data structures (structs, records and pointers). Goto is deprecated in structured programming though not eliminated entirely. (It is still necessary for some error handling.) Finally they have subroutines with local variables that are capable of splitting the code into more manageable and understandable chunks. These languages proved more capable of writing larger, more maintainable programs. However they too began to bog down when faced with the need to share code among programmers and to write very large (greater than 50,000 line) programs.^0.0^0.0^0.019417475728155338^0.05825242718446602^0.0110803324099723^0.0^103.0^0.4368932038834951^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Some of the above history may sound a little funny to those of you with experience in the languages I'm discussing. After all Basic has subroutines and local variables, doesn't it? The fact is successful computer languages have continued to evolve. Fortran now has pointers so it can create more complicated data structures. Basic has while loops. Cobol has objects. And on some architectures like Alpha/VMS the assembly language bears little to no resemblance to the underlying machine architecture. These features were not parts of the first versions of the language, however. And despite these improvements the modern versions of these languages are their parents children. Basic and Fortran programmers still often produce spaghetti code. Assembly language is quick to run but long to program. C is obfuscated beyond the comprehension of mere mortals.^0.0^0.0^0.0^0.014814814814814815^0.0^0.002280501710376283^135.0^0.4888888888888889^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The third generation of 3GL's (3.3 GL's) began to take hold in the late 80's. These were the object oriented languages. Although object oriented languages had been around since the late 1960's, it wasn't until the late 80's that computer hardware became fast enough and memory cheap enough to support them. ^0.0^0.0^0.04^0.0^0.006389776357827476^0.0^50.0^0.56^text
(Object oriented programming is not a panacea. It exacts a speed penalty over plain vanilla C or Fortran code, and often requires twice as much memory.)^0.0^0.0^0.0^0.0^0.01282051282051282^0.0^26.0^0.4230769230769231^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Object oriented languages (OOP for short) included all the features of structured programming and added still more powerful ways to organize algorithms and data structures. There are three key features of OOP languages: encapsulation, polymorphism and inheritance. All of them are tied to the notion of a class.^0.0^0.0^0.041666666666666664^0.0625^0.006309148264984227^0.0031545741324921135^48.0^0.4375^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Classes and Objects^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The primary distinguishing feature of OOP languages is the class. A class is a data structure that can associate the methods which act on an object with the object itself. In pre-OOP languages methods and data were separate. In OOP languages they are all part of classes.^0.0^0.0^0.0625^0.041666666666666664^0.0^0.0^48.0^0.5208333333333334^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Programming languages provide a number of simple data types like int, float and String. However very often the data you want to work with may not be simple ints, floats or Strings. Classes let programmers define their own more complicated data types.^0.2^0.0^0.023809523809523808^0.047619047619047616^0.0^0.0^42.0^0.40476190476190477^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
For instance let's suppose your program needs to keep a database of web sites. For each site you have a name, a URL, and a description. In traditional programming languages you'd have three different String variables for each web site. With a class you combine these into one package like so:^0.0^0.0^0.0196078431372549^0.09803921568627451^0.0^0.0033444816053511705^51.0^0.49019607843137253^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class website { String name; String url; String description; } ^0.75^0.0^0.25^0.125^0.0641025641025641^0.0^8.0^0.125^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
These variables (name, url and description) are called the ^0.0^0.0^0.1111111111111111^0.0^0.03333333333333333^0.0^9.0^0.5555555555555556^text
members^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 of the class. They tell you what a class is and what its properties are. They are the nouns of the class.^0.3333333333333333^0.0^0.0^0.13636363636363635^0.0^0.0^22.0^0.7272727272727273^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
In our web site database we will have many thousands of websites. Each specific web site is an object. The definition of a web site though, which we gave above, is a class. This is a very important distinction. A class defines what an object is, but it is not itself an object. An object is a specific ^0.0^0.0^0.017241379310344827^0.05172413793103448^0.0^0.0^58.0^0.603448275862069^text
instance^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 of a class. Thus when we create a new object we say we are ^0.3333333333333333^0.0^0.0^0.14285714285714285^0.0^0.0^14.0^0.6428571428571429^text
instantiating^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 the object. Each class exists only once in a program, but there can be many thousands of objects that are instances of that class.^0.3333333333333333^0.0^0.0^0.08333333333333333^0.0^0.0^24.0^0.6666666666666666^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
To instantiate an object in Java we use the ^0.0^0.0^0.0^0.0^0.0^0.0^9.0^0.5555555555555556^text
new^0.0^0.0^0.0^1.0^0.0^0.0^1.0^0.0^text
 operator. Here's how we'd create a new web site:^0.0^0.0^0.0^0.1111111111111111^0.0^0.0196078431372549^9.0^0.4444444444444444^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 website x = new website(); ^1.3333333333333333^0.0^0.5^0.25^0.08823529411764706^0.029411764705882353^4.0^0.0^text
 Once we've got a website we want to know something about it. To get at the member variables of the website we can use the ^0.2^0.0^0.08^0.0^0.0^0.0^25.0^0.68^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 operator. Website has three member variables, name, url and description, so x has three member variables as well, x.name, x.url and x.description. We can use these just like we'd use any other String variables. For instance:^0.2^0.0^0.07692307692307693^0.02564102564102564^0.0^0.004366812227074236^39.0^0.4358974358974359^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 website x = new website(); x.name = "Cafe Au Lait"; x.url = "http://metalab.unc.edu/javafaq/"; x.description = "Really cool!"; System.out.println(x.name + " at " + x.url + " is " + x.description); ^3.111111111111111^0.0^0.3225806451612903^0.03225806451612903^0.038135593220338986^0.046610169491525424^31.0^0.12903225806451613^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Methods^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 Data types aren't much use unless you can do things with them. For this purpose classes have methods. Members say what a class is. Methods say what a class does. For instance our website class might have a method to print its data. If so that would look like this:^0.0^0.0^0.02^0.18^0.0^0.0036900369003690036^50.0^0.42^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class website { String name; String url; String description; print() { System.out.println(name + " at " + url + " is " + description); } } ^1.3333333333333333^0.0^0.23529411764705882^0.058823529411764705^0.07100591715976332^0.023668639053254437^17.0^0.23529411764705882^text
 Outside the website method we call the print method just like we referenced the member variables, using the name of the particular object we want to print and the ^0.0^0.0^0.034482758620689655^0.0^0.0^0.0^29.0^0.4827586206896552^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 operator.^1.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 website x = new website(); x.name = "Cafe Au Lait"; x.url = "http://metalab.unc.edu/javafaq/"; x.description = "Really cool!"; x.print(); ^3.111111111111111^0.0^0.36363636363636365^0.045454545454545456^0.05084745762711865^0.03954802259887006^22.0^0.045454545454545456^text
 Notice that within the website class we don't need to use x.name or x.url. name and url are sufficient. That's because the print method must be called by a specific instance of the website class, and this instance knows what its data is. Or, another way of looking at it, the every object has its own print method. ^0.0^0.0^0.06666666666666667^0.06666666666666667^0.0^0.0^60.0^0.55^text
 The print() method is completely enclosed within the website class. All methods in Java must belong to a class. Unlike C++ programs, Java programs cannot have a method hanging around in global space that does everything you forgot to do in your classes.^0.2^0.0^0.023255813953488372^0.06976744186046512^0.007751937984496124^0.003875968992248062^43.0^0.46511627906976744^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Constructors^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 The first method most classes need is a ^0.0^0.0^0.0^0.0^0.0^0.0^8.0^0.625^text
constructor^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
. A constructor creates a new instance of the class. It initializes all the variables and does any work necessary to prepare the class to be used. In the line ^0.0^0.0^0.034482758620689655^0.10344827586206896^0.0^0.0^29.0^0.5172413793103449^text
website x = new website();^0.0^0.0^0.5^0.25^0.11538461538461539^0.038461538461538464^4.0^0.0^text
 website() is a constructor. If no constructor exists Java provides a default one, but it's better to make sure you have your own. You make a constructor by writing a public method that has the same name as the class. Thus our website constructor is called website(). Here's a revised website class with a constructor that initializes all the members to null Strings.^0.125^0.0^0.07936507936507936^0.07936507936507936^0.010638297872340425^0.0^63.0^0.5396825396825397^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class website { String name; String url; String description; public website() { name = ""; url = ""; description = ""; } } ^1.7142857142857142^0.0^0.3076923076923077^0.15384615384615385^0.07272727272727272^0.01818181818181818^13.0^0.15384615384615385^text
 Better yet, we should create a constructor that accepts three Strings as arguments and uses those to initialize the member variables like so:^0.0^0.0^0.0^0.0^0.0^0.006802721088435374^23.0^0.5217391304347826^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class website { String name; String url; String description; public website(String n, String u, String d) { name = n; url = u; description = d; } } ^1.7142857142857142^0.0^0.18181818181818182^0.09090909090909091^0.06315789473684211^0.015789473684210527^22.0^0.09090909090909091^text
 We'd use this like so:^0.0^0.0^0.0^0.2^0.0^0.038461538461538464^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 website x = new website("Cafe Au Lait", "http://metalab.unc.edu/javafaq/", "Really cool!"); x.print(); ^2.0^0.0^0.4375^0.0625^0.05217391304347826^0.034782608695652174^16.0^0.0^text
 This fits in well with the goal of keeping code relevant to the proper functioning of a class within the class.^0.0^0.0^0.0^0.14285714285714285^0.0^0.0^21.0^0.5238095238095238^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
However what if sometimes when we want to create a web site we know the URL, name, and description, and sometimes we don't? Best of all, let's use both!^0.0^0.0^0.03333333333333333^0.03333333333333333^0.0^0.012987012987012988^30.0^0.5666666666666667^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
class website { String name; String url; String description; public website(String n, String u, String d) { name = n; url = u; description = d; } public website() { name = ""; url = ""; description = ""; } } ^2.0^0.0^0.2222222222222222^0.1111111111111111^0.06909090909090909^0.02181818181818182^27.0^0.1111111111111111^text
 This is called ^0.0^0.0^0.0^0.3333333333333333^0.0^0.0^3.0^0.3333333333333333^text
method overloading^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 or ^0.5^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
polymorphism^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
. Polymorphism is a feature of object oriented languages that lets one name refer to different methods depending on context. The important context is typically the number and type of arguments to the method. In this case we use the first version of the method if we have three String arguments and the second version if we don't have any arguments.^0.0^0.0^0.0^0.08333333333333333^0.0^0.0^60.0^0.48333333333333334^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
If you have one or two or four String arguments to the constructor, or arguments that aren't Strings, then the compiler generates an error because it doesn't have a method whose ^0.0^0.0^0.0^0.03225806451612903^0.0^0.0^31.0^0.6451612903225806^text
signature^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 matches the requested method call. ^0.5^0.0^0.0^0.0^0.0^0.0^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
toString Methods^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
 Print methods are common in some languages but most Java programs operate differently. You can use ^0.0^0.0^0.0^0.0^0.0^0.0^16.0^0.4375^text
System.out.println()^0.0^0.0^0.3333333333333333^0.0^0.1^0.0^3.0^0.0^text
 to print any object. However for good results your class should have a ^0.5^0.0^0.0^0.15384615384615385^0.0^0.0^13.0^0.5384615384615384^text
toString()^0.0^0.0^1.0^0.0^0.2^0.0^1.0^0.0^text
 method that formats the objects data in a sensible way and returns a String. Here's how we'd implement it in the ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^21.0^0.5714285714285714^text
website^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 example: ^0.0^0.0^0.0^0.0^0.0^0.09090909090909091^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
public class ClassTest { public static void main(String args[]) { website x = new website("Cafe Au Lait", "http://metalab.unc.edu/javafaq/", "Really cool!"); System.out.println(x); } } class website { String name; String url; String description; public website(String n, String u, String d) { name = n; url = u; description = d; } public website() { name = ""; url = ""; description = ""; } public String toString() { return (name + " at " + url + " is " + description); } }^1.8857142857142857^0.0^0.2857142857142857^0.1746031746031746^0.06779661016949153^0.023728813559322035^63.0^0.09523809523809523^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Some Advocacy^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
 Unfortunately the object oriented language that took hold was C++. Among much fitter contenders for object languages, notably Smalltalk, C++ had the unique advantage of being downward compatible with the C programmers were already familiar with. Unfortunately this advantage had the huge side effect of forcing C++ to accept all of C's obfuscated macros, pointer arithmetic, and now redundant structs. The baggage imposed on C++ by the need to be compatible with C went a long way toward wiping out the advantage of object oriented programming.^0.0^0.0^0.023255813953488372^0.03488372093023256^0.0^0.00718132854578097^86.0^0.3953488372093023^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Java is the latest and possibly the greatest third generation programming language. Here I need to explain why Java is a better OOP language than C++.^0.0^0.0^0.038461538461538464^0.0^0.0^0.006535947712418301^26.0^0.4230769230769231^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
A Non-Trivial Examples: Complex Numbers^0.0^0.0^0.0^0.0^0.0^0.02564102564102564^6.0^0.16666666666666666^text
 As mentioned in Chapter 2 one of the features needed for serious scientific computation is complex numbers. Unfortunately no popular computer language other than Fortran provides them as a built-in data type. (Actually this is such a common and useful example and was used by so many textbooks that it was recently added to the C++ standard library which makes it far less useful as an example. Fortunately, however, Java has not yet been around long enough to have all its really useful examples coopted into the standard library.) Let's see how we might implement them in Java. From the standpoint of a data type you really don't need much. Mathematically a complex number is composed of a real part u and an imaginary part v. We can create such a class in the following way:^0.0^0.0^0.0^0.03676470588235294^0.0025^0.0025^136.0^0.5367647058823529^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
public class ComplexNumber extends Object { public double u; public double v; }^0.6666666666666666^0.0^0.09090909090909091^0.6363636363636364^0.044444444444444446^0.0^11.0^0.0^text
 While this is sufficient to encompass all the data that one needs in a complex number it's not a very good example of object-oriented programming. To actually do anything with this number we have to know exactly how the data structure is defined. If we change the data structure, for instance by defining a complex number in terms of it's magnitude r and its argument theta instead of by its real and imaginary components we have to change all the code that depends on it.^0.0^0.0^0.0^0.06976744186046512^0.0^0.0^86.0^0.5^text
 We also have to write code to explicitly add the numbers, multiply them or do anything else we might need to do with complex numbers. If we need to add complex numbers in more than one place, then we need to write the addition code again, or, at the very least, copy and paste it.^0.0^0.0^0.0^0.07272727272727272^0.0^0.0^55.0^0.5636363636363636^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
A better implementation of a complex number class will shield us from the exact storage of the data, i.e. x and y vs. r and theta. It will also provide methods that let us perform any operation we might need to perform on or with a complex number.^0.0^0.0^0.0^0.02040816326530612^0.0^0.0^49.0^0.4897959183673469^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Before writing code we need to ask ourselves what we'll do with a complex number. Most objects first require a ^0.0^0.0^0.0^0.05^0.0^0.0^20.0^0.55^text
constructor^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
, a method that is called when you create a new complex number. A more complicated object may also require a ^0.0^0.0^0.0^0.05^0.0^0.0^20.0^0.55^text
destructor^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 method that's called when you get rid of an object; but since this is a fairly simple object, we'll let Java's built-in garbage collection take care of that for us.^0.3333333333333333^0.0^0.0^0.06451612903225806^0.005988023952095809^0.0^31.0^0.5161290322580645^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Since these are complex ^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.75^text
numbers^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 it's not unlikely that we'll need to add them, subtract them, multiply them and divide them. We'll also want to be able to access their real and imaginary parts as well as their absolute values and arguments. The following class does all that.^0.2^0.0^0.0^0.023255813953488372^0.0^0.0^43.0^0.5813953488372093^text
 ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
// public class Complex extends Object { private double u; private double v; Complex (double x, double y) { u=x; v=y; } public double Real () { return u; } public double Imaginary () { return v; } public double Magnitude () { return Math.sqrt(u*u + v*v); } public double Arg () { return Math.atan2(v, u); } // Add z to w; i.e. w += z public Complex Plus (Complex z) { return new Complex(u + z.u, v + z.v); } // Subtract z from w public Complex Minus (Complex z) { return new Complex(u - z.u, v - z.v); } public Complex Times (Complex z) { return new Complex(u*z.u - v*z.v, u*z.v + v*z.u); } // divide w by z public Complex DivideBy (Complex z) { double rz = z.Magnitude(); return new Complex((u * z.u + v * z.v)/(rz*rz),(v * z.u - u * z.v)/(rz*rz)); } }^1.4202898550724639^4.0^0.06428571428571428^0.24285714285714285^0.07773109243697479^0.02415966386554622^140.0^0.02142857142857143^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Notice especially that ^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
u^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 and ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
v^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 are now private. They cannot be accessed by external code even if we want them to be. ^0.5^0.0^0.0^0.11764705882352941^0.0^0.0^17.0^0.6470588235294118^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The use of one of these methods will look like the following. Add the following ^0.0^0.0^0.0^0.0^0.0^0.0^15.0^0.5333333333333333^text
ComplexExamples^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 class to the Complex.java file and compile. Then run ^0.0^0.0^0.0^0.1^0.0^0.0^10.0^0.4^text
ComplexExamples^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 in the usual way by typing ^0.5^0.0^0.0^0.0^0.0^0.0^6.0^0.5^text
java ComplexExamples^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
//Complex Arithmetic Examples class ComplexExamples { public static void main (String args[]) { Complex u, v, w, z; u = new Complex(1,2); System.out.println("u: " + u.Real() + " + " + u.Imaginary() + "i"); v = new Complex(3,-4.5); System.out.println("v: " + v.Real() + " + " + v.Imaginary() + "i"); // Add u + v; z=u.Plus(v); System.out.println("u + v: "+ z.Real() + " + " + z.Imaginary() + "i"); // Add v + u; z=v.Plus(u); System.out.println("v + u: "+ z.Real() + " + " + z.Imaginary() + "i"); z=u.Minus(v); System.out.println("u - v: "+ z.Real() + " + " + z.Imaginary() + "i"); z=v.Minus(u); System.out.println("v - u: "+ z.Real() + " + " + z.Imaginary() + "i"); z=u.Times(v); System.out.println("u * v: "+ z.Real() + " + " + z.Imaginary() + "i"); z=v.Times(u); System.out.println("v * u: "+ z.Real() + " + " + z.Imaginary() + "i"); z=u.DivideBy(v); System.out.println("u / v: "+ z.Real() + " + " + z.Imaginary() + "i"); z=v.DivideBy(u); System.out.println("v / u: "+ z.Real() + " + " + z.Imaginary() + "i"); } }^2.7567567567567566^3.0^0.08860759493670886^0.0379746835443038^0.09552495697074011^0.06712564543889846^158.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Exercises^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
What happens if we try to add a complex number to itself? e.g.^0.0^0.0^0.0^0.14285714285714285^0.0^0.016129032258064516^14.0^0.42857142857142855^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 z = u.Add(u); ^0.0^0.0^0.0^0.0^0.17647058823529413^0.058823529411764705^4.0^0.0^text
 How about if we multiply, divide or subtract? e.g.^0.0^0.0^0.0^0.1^0.0^0.019230769230769232^10.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 z = u.Multiply(u); z = u.Divide(u); z = u.Minus(u); ^0.0^0.0^0.0^0.0^0.15789473684210525^0.05263157894736842^12.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Rewrite the Complex class so that it stores its data as r and theta rather than u and v. Be sure to be careful at zero. ^0.25^0.0^0.0^0.038461538461538464^0.0^0.0^26.0^0.5384615384615384^text
Add PlusEqual, MinusEqual, DivideEqual and MultiplyEqual methods to the Complex class that mimic the behavior of the +=, -=, *= and /= operators. ^0.0^0.0^0.21052631578947367^0.05263157894736842^0.0^0.02702702702702703^19.0^0.42105263157894735^text
Add an equality method to the Complex class that tests whether two complex numbers are equal and returns a boolean. ^0.0^0.0^0.0^0.1^0.0^0.0^20.0^0.45^text
For math whizzes only: Explain why it would ^0.0^0.0^0.0^0.125^0.0^0.022727272727272728^8.0^0.5^text
not^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
 be a good idea to add less than or greater than methods to the Complex class. ^0.3333333333333333^0.0^0.0^0.0625^0.0^0.0^16.0^0.5625^text
For math whizzes only: Add a logarithm method to the Complex number class. Pick the branch between zero and 2pi. ^0.0^0.0^0.05^0.1^0.0^0.008695652173913044^20.0^0.35^text
For math whizzes only: Add a power method to the complex number class. This is straightforward for real powers. For a real challenge allow arbitrary complex powers. Be sure to consider how you'll deal with branch cuts. ^0.0^0.0^0.0^0.13513513513513514^0.0^0.004424778761061947^37.0^0.2972972972972973^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
toString Methods^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
 Our printing in the last program was quite stilted because we needed to break a complex number into its real and imaginary parts, print them, and then put it all back together again. Wouldn't it be nice if we could just write:^0.0^0.0^0.0^0.047619047619047616^0.0^0.004291845493562232^42.0^0.6190476190476191^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
System.out.println(u);^0.0^0.0^0.25^0.0^0.13636363636363635^0.0^4.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
instead? It turns out we can. All objects have a toString method which is inherited from the Object class. However the default toString() method isn't very useful so we want to override it with one of our own creation that handles the conversion to complex numbers. Add the following method to the Complex class:^0.0^0.0^0.037037037037037035^0.05555555555555555^0.00625^0.00625^54.0^0.5370370370370371^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public String toString() { if (v >= 0) return (String.valueOf(u) + " + " + String.valueOf(v) + "i"); else return (String.valueOf(u) + " - " + String.valueOf(-v) + "i"); }^2.8^0.0^0.22727272727272727^0.22727272727272727^0.10582010582010581^0.042328042328042326^22.0^0.0^text
 ^1.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
You should also modify the ComplexExamples class as follows:^0.0^0.0^0.1111111111111111^0.1111111111111111^0.0^0.016666666666666666^9.0^0.5555555555555556^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 class ComplexExamples { public static void main (String args[]) { Complex u, v, z; u = new Complex(1,2); System.out.println("u: " + u); v = new Complex(3,-4.5); System.out.println("v: " + v); // Add u + v; z=u.Plus(v); System.out.println("u + v: " + z); // Add v + u; z=v.Plus(u); System.out.println("v + u: " + z); z=u.Minus(v); System.out.println("u - v: " + z); z=v.Minus(u); System.out.println("v - u: " + z); z=u.Times(v); System.out.println("u * v: " + z); z=v.Times(u); System.out.println("v * u: "+ z); z=u.DivideBy(v); System.out.println("u / v: " + z); z=v.DivideBy(u); System.out.println("v / u: " + z); } }^2.736842105263158^2.0^0.12280701754385964^0.05263157894736842^0.09208819714656291^0.04928664072632944^114.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
That's about an order of magnitude easier to understand and to write.^0.0^0.0^0.0^0.0^0.0^0.0^12.0^0.5833333333333334^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Polymorphism^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
So far our methods just do arithmetic on two complex numbers. It's not uncommon to want to multiply a complex number by a real number. To add this capability to our class we'll add the following method:^0.0^0.0^0.0^0.08108108108108109^0.0^0.004878048780487805^37.0^0.43243243243243246^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 public Complex Times (double x) { return new Complex(u*x, v*x); }^2.1666666666666665^0.0^0.0^0.3333333333333333^0.08139534883720931^0.023255813953488372^12.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Here's a simple test program for your new method:^0.0^0.0^0.0^0.2222222222222222^0.0^0.02040816326530612^9.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 class RealComplex { public static void main (String args[]) { Complex v, z; double x = 5.1; v = new Complex(3,-4.5); System.out.println("v: " + v); System.out.println("x: " + x); z=v.Times(x); System.out.println("v * x: " + z); } } ^1.6363636363636365^0.0^0.1388888888888889^0.16666666666666666^0.08333333333333333^0.03333333333333333^36.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The astute among you may be saying to hold on here, we've redefined the Times method. Now how can we multiply two complex numbers? However there's really no problem. The compiler notices that the arguments of the two methods named Times (not the same as the arguments of the two complex numbers but unfortunately the terminology fails us here) are different. One multiplies two complex numbers, the other multiplies a real number and a complex number. The compiler is smart enough to figure out which version of Times to use when. This is called ^0.0^0.0^0.0^0.010638297872340425^0.0035714285714285713^0.0017857142857142857^94.0^0.5638297872340425^text
method overloading^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 or ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
polymorphism^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
In some object-oriented languages like C++ you can not only overload methods but even operators like + and =. However while this makes numeric classes like complex numbers easier to work with, it tends to lead to unreadable and unmaintainable code for non-numeric classes. Therefore Java's designers elected not to add this feature to the language. As you can see from our example, with a little forethought you really don't lose very much without operator overloading.^0.14285714285714285^0.0^0.0^0.06578947368421052^0.0^0.00625^76.0^0.4342105263157895^text
 ^0.3333333333333333^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Exercises^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Add a method to the Complex class that adds a real number to a complex number and returns a complex number. ^0.0^0.0^0.0^0.047619047619047616^0.0^0.0^21.0^0.42857142857142855^text
Add methods for subtracting a real number from a complex number and for subtracting a complex number from a real. Be careful since subtraction, unlike addition, is not commutative. ^0.0^0.0^0.0^0.06896551724137931^0.0^0.0^29.0^0.3793103448275862^text
Add methods for dividing a real by a complex number and for dividing a complex number by a real. Be careful since division, unlike multiplication, is not commutative. ^0.0^0.0^0.0^0.07142857142857142^0.0^0.0^28.0^0.39285714285714285^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Scope: Calling the Complex Class From External Classes^0.0^0.0^0.0^0.125^0.0^0.018518518518518517^8.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Until now we've stored almost every program in a single file. This becomes unwieldy as programs grow large. It becomes impossible to manage when more than one person is working on a program. It also loses out on one of the key benefits of OOP, code reusability. As long as all the code for a program is stored in one file, you can't reuse code except by cut and paste, just like in a non-object oriented language.^0.0^0.0^0.01282051282051282^0.038461538461538464^0.0^0.0^78.0^0.5128205128205128^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
There has been some code that hasn't resided in our source files. Remember all those import statements at the top of every file? What they do is pull in prewritten and precompiled code from various locations so we can use it in our programs. You can do the same thing with classes you write. However to do this you do need to be aware of several conventions and restrictions. ^0.0^0.0^0.028985507246376812^0.08695652173913043^0.0^0.0025906735751295338^69.0^0.5942028985507246^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
No file should contain more than one public class. This means that our Hello World, Goodbye World example is no longer valid because each of the classes was public. ^0.0^0.0^0.0^0.13793103448275862^0.0^0.0^29.0^0.4827586206896552^text
All files should have the same name as their single public class followed by the extension ".java". ^0.0^0.0^0.0^0.11764705882352941^0.0^0.0^17.0^0.5882352941176471^text
Source code files should be stored in the same directory as their compiled .class file. This is so the Java compiler can find the appropriate definitions and interfaces for a class when the class is referred to in a different file. ^0.0^0.0^0.0^0.12195121951219512^0.0^0.0^41.0^0.5121951219512195^text
Source code and .class files should be in a directory that's part of the $CLASSPATH environment variable. ^0.0^0.0^0.058823529411764705^0.058823529411764705^0.0^0.0^17.0^0.5294117647058824^text
 We'll demonstrate this by splitting the example of the previous sections into two separate files, each of which contains one class. Begin by creating a file that contains the Complex class. (Your complex file may be a little different depending on how you answered the exercises in the previous sections.) Save this file as Complex.java.^0.0^0.0^0.0^0.07142857142857142^0.005763688760806916^0.0^56.0^0.4642857142857143^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Next save the examples from the previous exercises in a separate file called ComplexExamples.java in the same directory as Complex.java. Now compile both files and run Complex Examples.java.^0.0^0.0^0.03225806451612903^0.0^0.0^0.0^31.0^0.41935483870967744^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The Mandelbrot Set^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The Mandelbrot set is a classic application of complex arithmetic. It is ^0.0^0.0^0.0^0.0^0.0^0.0^12.0^0.5^text
the^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
 example of a fractal set. ^1.0^0.0^0.0^0.0^0.0^0.0^5.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Here and in the future we are going to try to separate the mathematical definition of our data from its display on the screen. In fact we won't even add the screen display till the second iteration of the program.^0.0^0.0^0.0^0.025^0.0^0.0^40.0^0.55^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Our data structure will be a two dimensional array, each element of which represents a fixed point in the complex plane. The array is defined by the value of the lower left point, the gap between points and the number of pixels in the x and y directions. Thus given that element (0,0) of the array matches the complex point (x0,y0), each point is separated by a value ^0.0^0.0^0.029411764705882353^0.0^0.010666666666666666^0.0^68.0^0.5^text
gap^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
, we know that element i,j of the array represents the point (x0 + i*gap, y0 + j*gap) in the complex plane. Since we know this by position of the array element alone we dont' need to store this value in the array.^0.0^0.0^0.06976744186046512^0.046511627906976744^0.009174311926605505^0.01834862385321101^43.0^0.3953488372093023^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
What will we store in each element of this array? We'll calculate a number to go there in the following fashion. Let z = 0 + 0i and let c be the position of that array element in complex space. calculate z = z*z + c and iterate as follows up to 200 times:^0.0^0.0^0.02040816326530612^0.02040816326530612^0.0^0.026923076923076925^49.0^0.46938775510204084^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
for (i=0; i < 200; i++) { z = z.Times(z) + c; }^0.6666666666666666^0.0^0.0^0.1111111111111111^0.17307692307692307^0.09615384615384616^9.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The Mandelbrot set is composed of those elements which, no matter how long we do this, never approach infinity. Since infinity can take a mighty long time to approach, it's fortunate that a fairly elementary theorem in complex variable theory guarantees that any number whose magnitude ever exceeds two in this iterative scheme will become as large as one might wish. (i.e. They asymptotically approach infinity.) Therefore once a number exceeds two we can break out of the loop and say definitively that this number is ^0.0^0.0^0.0^0.08045977011494253^0.003780718336483932^0.0^87.0^0.4827586206896552^text
not^0.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
 in the Mandelbrot set.^1.0^0.0^0.0^0.0^0.0^0.0^4.0^0.5^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Unfortunately there's no guarantee that just because an element doesn't reach 2 in two hundred iterations it might not reach two on the two hundredth and first iteration or the two thousandth or the two millionth. However most numbers that don't prove they're not in the Mandelbrot Set by the two hundredth iteration are reasonably likely to be in it.^0.16666666666666666^0.0^0.0^0.01694915254237288^0.0^0.0^59.0^0.6440677966101694^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Here's how the code will work. First we'll select the lower left hand corner of our rectangle in complex space, the size of the gap between the points and the number of points in each dimension. For a specific example we can choose the square bordered on the lower left by (-2,-2) and on the upper right by (2,2). To keep initial computations manageable we'll break this up into an array of 101 by 101 elements which implies a gap size of 0.05.^0.0^0.0^0.0^0.038461538461538464^0.008830022075055188^0.0^78.0^0.5384615384615384^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Once this array is created we'll loop through it and fill each element with a Boolean value, true if the element is probably in the Mandelbrot Set (doesn't pass two in two hundred iterations) and false if it's not (does pass two and thus go to infinity). Here's the code:^0.0^0.0^0.0^0.08^0.01444043321299639^0.0036101083032490976^50.0^0.56^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 class MandelApp { public static void main(String args[]) { int xdim = 101; int ydim = 101; double xstart = -2.0; double ystart = -2.0; boolean Mandel[][] = new boolean[xdim][ydim]; double gap = 0.05; int max_iterations = 200; int i,j,k; Complex z, c; for (i=0; i < xdim; i++) { for (j=0; j < ydim; j++) { c = new Complex(xstart + i*gap ,ystart + j*gap); z = new Complex(0.0, 0.0); k=0; while (z.Magnitude() < 2.0 && k < max_iterations) { z = z.Times(z); z = z.Plus(c); k++; } if (z.Magnitude() < 2.0) { Mandel[i][j] = true; } else Mandel[i][j] = false; } } } }^4.742857142857143^0.0^0.2073170731707317^0.25609756097560976^0.09530026109660575^0.037859007832898174^82.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Drawing the Mandelbrot Set^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.25^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
To make this interesting we want to actually draw pictures of the Mandelbrot Set. To do this we'll move the actual calculation into a thread in an applet and then draw the results into a bitmap. Here's the code:^0.0^0.0^0.02564102564102564^0.07692307692307693^0.0^0.004651162790697674^39.0^0.5128205128205128^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
import java.applet.Applet; import java.awt.*; public class Mandelbrot extends Applet { int xdim; int ydim; double xstart = -2.0; double ystart = -1.25; int Mandel[][]; double gap = 0.05; int max_iterations = 256; public void paint(Graphics g) { int i,j,k; Complex z, c; xdim = size().width; ydim = size().height; gap = 2.5/ydim; Mandel = new int[xdim][ydim]; for (i=0; i < xdim; i++) { for (j=0; j < ydim; j++) { c = new Complex(xstart + i*gap, ystart + j*gap); z = new Complex(0.0, 0.0); for (k = 0; z.Magnitude() < 2.0 && k < max_iterations; k++) { z = z.Times(z); z = z.Plus(c); } g.setColor(selectColor(k)); g.fillRect(i, j, 1, 1); } } } protected Color selectColor (int num_iterations) { if (num_iterations > max_iterations) return Color.black; else if (num_iterations > 9*max_iterations/10) return Color.darkGray; else if (num_iterations > 8*max_iterations/10) return Color.gray; else if (num_iterations > 7*max_iterations/10) return Color.magenta; else if (num_iterations > 6*max_iterations/10) return Color.cyan; else if (num_iterations > 5*max_iterations/10) return Color.blue; else if (num_iterations > 4*max_iterations/10) return Color.green; else if (num_iterations > 3*max_iterations/10) return Color.yellow; else if (num_iterations > 2*max_iterations/10) return Color.orange; else if (num_iterations > 1*max_iterations/10) return Color.red; else return Color.white; } }^3.4827586206896552^0.0^0.27011494252873564^0.3160919540229885^0.06521739130434782^0.034420289855072464^174.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
This program is minimal. It should really create an ^0.0^0.0^0.0^0.1111111111111111^0.0^0.0^9.0^0.4444444444444444^text
ImageProducer^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 which draws the Mandelbrot set. There are also a lot of additions that could be made to the parameters to allow for zooming in on particular regions. In fact you could even implement this as a ^0.25^0.0^0.0^0.05555555555555555^0.0^0.0^36.0^0.6111111111111112^text
Canvas^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 in an applet with various controls to select the area of interest. This will all be investigated in the Cafe Au Lait newsletter.^0.5^0.0^0.043478260869565216^0.043478260869565216^0.0^0.0^23.0^0.5217391304347826^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
For more details on the Mandelbrot Set see the first chapter of ^0.0^0.0^0.0^0.08333333333333333^0.0^0.0^12.0^0.5833333333333334^text
A.K. Dewdney's^0.0^0.0^0.25^0.0^0.0^0.0^4.0^0.25^text
 ^1.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The Armchair Universe^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text
. ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Exercises^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Explore different starting points and gap sizes for the Mandelbrot set. To make this easier add user input to dynamically select the starting point and gap size.^0.0^0.0^0.0^0.07407407407407407^0.0^0.0^27.0^0.2222222222222222^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 What happens if you allow the x and y gap size to be chosen independently? ^0.5^0.0^0.0^0.06666666666666667^0.0^0.012987012987012988^15.0^0.4^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Acknowledgements^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Noone ever truly writes a book alone. This tutorial relies heavily on ^0.0^0.0^0.08333333333333333^0.08333333333333333^0.0^0.0^12.0^0.4166666666666667^text
Brian Kernighan^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 and ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
Dennis Ritchie's^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The C Programming Language^0.0^0.0^0.0^0.0^0.0^0.0^4.0^0.25^text
, one of the alltime classics of computer language manuals.^0.0^0.0^0.1111111111111111^0.0^0.0^0.0^9.0^0.5555555555555556^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The presentations at the first Java Day in New York City were crucial to getting my understanding of Java off the ground, especially those of ^0.0^0.0^0.0^0.04^0.0^0.0^25.0^0.52^text
Bill Joy^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.5^text
 and ^0.5^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
Frank Greco^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
The eventtutor applet, flying lines applet and Mondrian applets are taken in spirit if not in code from ^0.0^0.0^0.2222222222222222^0.05555555555555555^0.0^0.0^18.0^0.3888888888888889^text
Dave Mark^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 and ^1.0^0.0^0.0^0.0^0.0^0.0^1.0^1.0^text
Cartwright Reed's^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Macintosh Programming Primer^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
.^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Finally I'd like to thank ^0.0^0.0^0.0^0.2^0.0^0.0^5.0^0.2^text
Olivia Whiteman^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
, ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Dave Fisco^0.0^0.0^0.5^0.0^0.0^0.0^2.0^0.0^text
, ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
Tim Arnold^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 and all the other Java Invaders for putting together forums in which I could learn more Java.^0.3333333333333333^0.0^0.0^0.058823529411764705^0.0^0.0^17.0^0.5294117647058824^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
[ ^0.0^0.0^0.0^0.0^0.5^0.0^0.0^0.0^text
Cafe Au Lait^0.0^0.0^0.0^0.0^0.0^0.0^3.0^0.0^text
 | ^1.0^0.0^0.0^0.0^0.0^0.3333333333333333^0.0^0.0^text
Books^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 | ^1.0^0.0^0.0^0.0^0.0^0.3333333333333333^0.0^0.0^text
Trade Shows^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 | ^1.0^0.0^0.0^0.0^0.0^0.2^0.0^0.0^text
FAQ^0.0^0.0^1.0^0.0^0.0^0.0^1.0^0.0^text
 | ^1.0^0.0^0.0^0.0^0.0^0.3333333333333333^0.0^0.0^text
Tutorial^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
 | ^1.0^0.0^0.0^0.0^0.0^0.3333333333333333^0.0^0.0^text
User Groups^0.0^0.0^0.0^0.0^0.0^0.0^2.0^0.0^text
 ]^1.0^0.0^0.0^0.0^0.5^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 Copyright 1995-1998, 2000-2002, 2004-2006 ^0.0^0.0^0.0^0.0^0.0^0.0^1.0^0.0^text
Elliotte Rusty Harold^0.0^0.0^0.3333333333333333^0.0^0.0^0.0^3.0^0.0^text
 ^1.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
 ^0.0^0.0^0.0^0.0^0.0^0.0^0.0^0.0^text
elharo@metalab.unc.edu^0.0^0.0^1.0^0.0^0.0^0.0^4.0^0.0^text
 Last Modified June 3, 2006 ^0.2^0.0^0.0^0.0^0.0^0.0^3.0^0.3333333333333333^text

