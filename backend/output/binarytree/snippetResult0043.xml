<?xml version="1.0" encoding="UTF-8"?>
<result>
<description>
<docid>21146</docid>
<orderid>0</orderid>
<type>TEXT</type>
<url>http://www.java-tips.org/java-se-tips/java.lang/aa-tree-implementation-in-java-2.html</url>
</description>
<TEXT orderid="0" >
&#160;
            
	      





              Home    Java SE Tips               

              


            &#160;
          


        
      
  





  
    &#160;
    
    
      
        
          
              
                		
				
			
							
		
		
				
					
				
					Main Menu				
			
					
			
				

Home
Java Tutorials
Book Reviews
Java SE Tips
Java ME Tips
Java EE Tips
Other API Tips
Java Applications
Java Libraries
Java Games
Sitemap
			
		
		
				
					
				
					Java Network				
			
					
			
				






 Java Forums












			
		
		
				
				
			
				
 



 
 










 


			
		
		
				
					
				
					Most Visited Tips				
			
					
			
				

Java SE Tips
Java ME Tips
Java EE Tips
Other API Tips
Java Applications
Java Libraries
Java Games
Book Reviews
			
		
		
				
					
				
					Top Rated Tips				
			
					
			
				

Java SE Tips
Java ME Tips
Java EE Tips
Other API Tips
Java Applications
Java Libraries
Java Games
Book Reviews
			
		
		
				
				
			
				











			
		
		
				
					
				
					Statistics				
			
					
			
				Registered Users: 770Java SE Tips: 614Java ME Tips: 201Java EE Tips: 184Other API Tips: 779Java Applications: 298Java Libraries: 209Java Games: 16Book Reviews: 			
		
		
		                
              
              
                &#160;
              
            
        
        
          &#160;
        
      
      

      &#160;
        
								
			
								
					AA-Tree Implementation in Java									
							
				
					
			
						
			
			User Rating:&#160;/&#160;33


PoorBest&#160;
		
				
			
				An AA tree in computer science is a red-black tree with one additional rule. Unlike red-black trees, RED nodes on an AA tree can only be added as a right subchild. In other words, no RED node can be a left subchild. This results in the simulation of a 2-3 tree instead of a 2-3-4 tree, which greatly simplifies the maintenance operations. 

The following code shows how to implement a AA tree in Java:
</TEXT>
<CODE orderid="1" >
//&#160;AATree&#160;class

//

//&#160;CONSTRUCTION:&#160;with&#160;no&#160;initializer

//

//&#160;******************PUBLIC&#160;OPERATIONS*********************

//&#160;void&#160;insert(&#160;x&#160;)&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&gt;&#160;Insert&#160;x

//&#160;void&#160;remove(&#160;x&#160;)&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&gt;&#160;Remove&#160;x

//&#160;Comparable&#160;find(&#160;x&#160;)&#160;&#160;&#160;--&gt;&#160;Return&#160;item&#160;that&#160;matches&#160;x

//&#160;Comparable&#160;findMin(&#160;)&#160;&#160;--&gt;&#160;Return&#160;smallest&#160;item

//&#160;Comparable&#160;findMax(&#160;)&#160;&#160;--&gt;&#160;Return&#160;largest&#160;item

//&#160;boolean&#160;isEmpty(&#160;)&#160;&#160;&#160;&#160;&#160;--&gt;&#160;Return&#160;true&#160;if&#160;empty;&#160;else&#160;false

//&#160;void&#160;makeEmpty(&#160;)&#160;&#160;&#160;&#160;&#160;&#160;--&gt;&#160;Remove&#160;all&#160;items

//&#160;******************ERRORS********************************

//&#160;Exceptions&#160;are&#160;thrown&#160;by&#160;insert&#160;and&#160;remove&#160;if&#160;warranted



/**

&#160;*&#160;Implements&#160;an&#160;AA-tree.

&#160;*&#160;Note&#160;that&#160;all&#160;&quot;matching&quot;&#160;is&#160;based&#160;on&#160;the&#160;compareTo&#160;method.

&#160;*&#160;@author&#160;Mark&#160;Allen&#160;Weiss

&#160;*/

public&#160;class&#160;AATree&#160;{

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Construct&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;AATree(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root&#160;=&#160;nullNode;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Insert&#160;into&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;x&#160;the&#160;item&#160;to&#160;insert.

&#160;&#160;&#160;&#160;&#160;*&#160;@throws&#160;DuplicateItemException&#160;if&#160;x&#160;is&#160;already&#160;present.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;void&#160;insert(&#160;Comparable&#160;x&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root&#160;=&#160;insert(&#160;x,&#160;root&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Remove&#160;from&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;x&#160;the&#160;item&#160;to&#160;remove.

&#160;&#160;&#160;&#160;&#160;*&#160;@throws&#160;ItemNotFoundException&#160;if&#160;x&#160;is&#160;not&#160;found.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;void&#160;remove(&#160;Comparable&#160;x&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;deletedNode&#160;=&#160;nullNode;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root&#160;=&#160;remove(&#160;x,&#160;root&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Find&#160;the&#160;smallest&#160;item&#160;in&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;smallest&#160;item&#160;or&#160;null&#160;if&#160;empty.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;Comparable&#160;findMin(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;isEmpty(&#160;)&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;null;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;AANode&#160;ptr&#160;=&#160;root;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while(&#160;ptr.left&#160;!=&#160;nullNode&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ptr&#160;=&#160;ptr.left;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;ptr.element;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Find&#160;the&#160;largest&#160;item&#160;in&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;largest&#160;item&#160;or&#160;null&#160;if&#160;empty.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;Comparable&#160;findMax(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;isEmpty(&#160;)&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;null;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;AANode&#160;ptr&#160;=&#160;root;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while(&#160;ptr.right&#160;!=&#160;nullNode&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;ptr&#160;=&#160;ptr.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;ptr.element;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Find&#160;an&#160;item&#160;in&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;x&#160;the&#160;item&#160;to&#160;search&#160;for.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;matching&#160;item&#160;of&#160;null&#160;if&#160;not&#160;found.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;Comparable&#160;find(&#160;Comparable&#160;x&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;AANode&#160;current&#160;=&#160;root;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nullNode.element&#160;=&#160;x;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(&#160;;&#160;;&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;x.compareTo(&#160;current.element&#160;)&#160;&lt;&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;current&#160;=&#160;current.left;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;if(&#160;x.compareTo(&#160;current.element&#160;)&#160;&gt;&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;current&#160;=&#160;current.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;if(&#160;current&#160;!=&#160;nullNode&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;current.element;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;null;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Make&#160;the&#160;tree&#160;logically&#160;empty.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;void&#160;makeEmpty(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root&#160;=&#160;nullNode;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Test&#160;if&#160;the&#160;tree&#160;is&#160;logically&#160;empty.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;true&#160;if&#160;empty,&#160;false&#160;otherwise.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;boolean&#160;isEmpty(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;root&#160;==&#160;nullNode;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Internal&#160;method&#160;to&#160;insert&#160;into&#160;a&#160;subtree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;x&#160;the&#160;item&#160;to&#160;insert.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;t&#160;the&#160;node&#160;that&#160;roots&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;new&#160;root.

&#160;&#160;&#160;&#160;&#160;*&#160;@throws&#160;DuplicateItemException&#160;if&#160;x&#160;is&#160;already&#160;present.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;private&#160;AANode&#160;insert(&#160;Comparable&#160;x,&#160;AANode&#160;t&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t&#160;==&#160;nullNode&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t&#160;=&#160;new&#160;AANode(&#160;x&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;if(&#160;x.compareTo(&#160;t.element&#160;)&#160;&lt;&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.left&#160;=&#160;insert(&#160;x,&#160;t.left&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;if(&#160;x.compareTo(&#160;t.element&#160;)&#160;&gt;&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.right&#160;=&#160;insert(&#160;x,&#160;t.right&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw&#160;new&#160;DuplicateItemException(&#160;x.toString(&#160;)&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t&#160;=&#160;skew(&#160;t&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t&#160;=&#160;split(&#160;t&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;t;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Internal&#160;method&#160;to&#160;remove&#160;from&#160;a&#160;subtree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;x&#160;the&#160;item&#160;to&#160;remove.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;t&#160;the&#160;node&#160;that&#160;roots&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;new&#160;root.

&#160;&#160;&#160;&#160;&#160;*&#160;@throws&#160;ItemNotFoundException&#160;if&#160;x&#160;is&#160;not&#160;found.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;private&#160;AANode&#160;remove(&#160;Comparable&#160;x,&#160;AANode&#160;t&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t&#160;!=&#160;nullNode&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Step&#160;1:&#160;Search&#160;down&#160;the&#160;tree&#160;and&#160;set&#160;lastNode&#160;and&#160;deletedNode

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;lastNode&#160;=&#160;t;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;x.compareTo(&#160;t.element&#160;)&#160;&lt;&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.left&#160;=&#160;remove(&#160;x,&#160;t.left&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;deletedNode&#160;=&#160;t;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.right&#160;=&#160;remove(&#160;x,&#160;t.right&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Step&#160;2:&#160;If&#160;at&#160;the&#160;bottom&#160;of&#160;the&#160;tree&#160;and

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;x&#160;is&#160;present,&#160;we&#160;remove&#160;it

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t&#160;==&#160;lastNode&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;deletedNode&#160;==&#160;nullNode&#160;||&#160;x.compareTo(&#160;deletedNode.element&#160;)&#160;!=&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw&#160;new&#160;ItemNotFoundException(&#160;x.toString(&#160;)&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;deletedNode.element&#160;=&#160;t.element;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t&#160;=&#160;t.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Step&#160;3:&#160;Otherwise,&#160;we&#160;are&#160;not&#160;at&#160;the&#160;bottom;&#160;rebalance

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t.left.level&#160;&lt;&#160;t.level&#160;-&#160;1&#160;||&#160;t.right.level&#160;&lt;&#160;t.level&#160;-&#160;1&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t.right.level&#160;&gt;&#160;--t.level&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.right.level&#160;=&#160;t.level;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t&#160;=&#160;skew(&#160;t&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.right&#160;=&#160;skew(&#160;t.right&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.right.right&#160;=&#160;skew(&#160;t.right.right&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t&#160;=&#160;split(&#160;t&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.right&#160;=&#160;split(&#160;t.right&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;t;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Skew&#160;primitive&#160;for&#160;AA-trees.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;t&#160;the&#160;node&#160;that&#160;roots&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;new&#160;root&#160;after&#160;the&#160;rotation.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;private&#160;static&#160;AANode&#160;skew(&#160;AANode&#160;t&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t.left.level&#160;==&#160;t.level&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t&#160;=&#160;rotateWithLeftChild(&#160;t&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;t;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Split&#160;primitive&#160;for&#160;AA-trees.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;t&#160;the&#160;node&#160;that&#160;roots&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;new&#160;root&#160;after&#160;the&#160;rotation.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;private&#160;static&#160;AANode&#160;split(&#160;AANode&#160;t&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t.right.right.level&#160;==&#160;t.level&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t&#160;=&#160;rotateWithRightChild(&#160;t&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.level++;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;t;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Rotate&#160;binary&#160;tree&#160;node&#160;with&#160;left&#160;child.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;private&#160;static&#160;AANode&#160;rotateWithLeftChild(&#160;AANode&#160;k2&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;AANode&#160;k1&#160;=&#160;k2.left;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;k2.left&#160;=&#160;k1.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;k1.right&#160;=&#160;k2;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;k1;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Rotate&#160;binary&#160;tree&#160;node&#160;with&#160;right&#160;child.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;private&#160;static&#160;AANode&#160;rotateWithRightChild(&#160;AANode&#160;k1&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;AANode&#160;k2&#160;=&#160;k1.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;k1.right&#160;=&#160;k2.left;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;k2.left&#160;=&#160;k1;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;k2;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;private&#160;static&#160;class&#160;AANode&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Constructors

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;AANode(&#160;Comparable&#160;theElement&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;element&#160;=&#160;theElement;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;left&#160;&#160;&#160;&#160;=&#160;right&#160;=&#160;nullNode;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;level&#160;&#160;&#160;=&#160;1;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Comparable&#160;element;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;The&#160;data&#160;in&#160;the&#160;node

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;AANode&#160;&#160;&#160;&#160;&#160;left;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Left&#160;child

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;AANode&#160;&#160;&#160;&#160;&#160;right;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Right&#160;child

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;level;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Level

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;private&#160;AANode&#160;root;

&#160;&#160;&#160;&#160;private&#160;static&#160;AANode&#160;nullNode;

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;static&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;static&#160;initializer&#160;for&#160;nullNode

&#160;&#160;&#160;&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nullNode&#160;=&#160;new&#160;AANode(&#160;null&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nullNode.left&#160;=&#160;nullNode.right&#160;=&#160;nullNode;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nullNode.level&#160;=&#160;0;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;private&#160;static&#160;AANode&#160;deletedNode;

&#160;&#160;&#160;&#160;private&#160;static&#160;AANode&#160;lastNode;

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;//&#160;Test&#160;program;&#160;should&#160;print&#160;min&#160;and&#160;max&#160;and&#160;nothing&#160;else

&#160;&#160;&#160;&#160;public&#160;static&#160;void&#160;main(&#160;String&#160;[&#160;]&#160;args&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;AATree&#160;t&#160;=&#160;new&#160;AATree(&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;final&#160;int&#160;NUMS&#160;=&#160;40000;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;final&#160;int&#160;GAP&#160;&#160;=&#160;&#160;&#160;307;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;System.out.println(&#160;&quot;Checking...&#160;(no&#160;bad&#160;output&#160;means&#160;success)&quot;&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.insert(&#160;new&#160;Integer(&#160;NUMS&#160;*&#160;2&#160;)&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.insert(&#160;new&#160;Integer(&#160;NUMS&#160;*&#160;3&#160;)&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(&#160;int&#160;i&#160;=&#160;GAP;&#160;i&#160;!=&#160;0;&#160;i&#160;=&#160;(&#160;i&#160;+&#160;GAP&#160;)&#160;%&#160;NUMS&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.insert(&#160;new&#160;Integer(&#160;i&#160;)&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;System.out.println(&#160;&quot;Inserts&#160;complete&quot;&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.remove(&#160;t.findMax(&#160;)&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(&#160;int&#160;i&#160;=&#160;1;&#160;i&#160;&lt;&#160;NUMS;&#160;i+=&#160;2&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.remove(&#160;new&#160;Integer(&#160;i&#160;)&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.remove(&#160;t.findMax(&#160;)&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;System.out.println(&#160;&quot;Removes&#160;complete&quot;&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;((Integer)(t.findMin(&#160;))).intValue(&#160;)&#160;!=&#160;2&#160;||

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;((Integer)(t.findMax(&#160;))).intValue(&#160;)&#160;!=&#160;NUMS&#160;-&#160;2&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;System.out.println(&#160;&quot;FindMin&#160;or&#160;FindMax&#160;error!&quot;&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(&#160;int&#160;i&#160;=&#160;2;&#160;i&#160;&lt;&#160;NUMS;&#160;i+=2&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;((Integer)t.find(&#160;new&#160;Integer(&#160;i&#160;)&#160;)).intValue(&#160;)&#160;!=&#160;i&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;System.out.println(&#160;&quot;Error:&#160;find&#160;fails&#160;for&#160;&quot;&#160;+&#160;i&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(&#160;int&#160;i&#160;=&#160;1;&#160;i&#160;&lt;&#160;NUMS;&#160;i+=2&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t.find(&#160;new&#160;Integer(&#160;i&#160;)&#160;)&#160;&#160;!=&#160;null&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;System.out.println(&#160;&quot;Error:&#160;Found&#160;deleted&#160;item&#160;&quot;&#160;+&#160;i&#160;);

&#160;&#160;&#160;&#160;}

}





/**

&#160;*&#160;Exception&#160;class&#160;for&#160;duplicate&#160;item&#160;errors

&#160;*&#160;in&#160;search&#160;tree&#160;insertions.

&#160;*&#160;@author&#160;Mark&#160;Allen&#160;Weiss

&#160;*/

public&#160;class&#160;DuplicateItemException&#160;extends&#160;RuntimeException&#160;{

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Construct&#160;this&#160;exception&#160;object.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;DuplicateItemException(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;super(&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Construct&#160;this&#160;exception&#160;object.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;message&#160;the&#160;error&#160;message.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;DuplicateItemException(&#160;String&#160;message&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;super(&#160;message&#160;);

&#160;&#160;&#160;&#160;}

}





/**

&#160;*&#160;Exception&#160;class&#160;for&#160;failed&#160;finds/removes&#160;in&#160;search

&#160;*&#160;trees,&#160;hash&#160;tables,&#160;and&#160;list&#160;and&#160;tree&#160;iterators.

&#160;*&#160;@author&#160;Mark&#160;Allen&#160;Weiss

&#160;*/

public&#160;class&#160;ItemNotFoundException&#160;extends&#160;RuntimeException&#160;{

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Construct&#160;this&#160;exception&#160;object.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;ItemNotFoundException(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;super(&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Construct&#160;this&#160;exception&#160;object.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;message&#160;the&#160;error&#160;message.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;ItemNotFoundException(&#160;String&#160;message&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;super(&#160;message&#160;);

&#160;&#160;&#160;&#160;}

}
</CODE>
<TEXT orderid="2" >
&#160;Related Tips 
A custom combobox editor for use with the EditableComboBox class
A demonstration of Java2D transformations
A game of Tic-Tac-Toe that can be played between two client applets
A Label that uses inline HTML to format its text
A program to print limits of the primitive types
A sample of inline DTD definition
A sample of linked DTD definition
A sample XML file

			
		
				

		&#160;

		

			
									
						
							&lt; Prev
					
										&#160;

					
										
						
							Next &gt;
					
								
			
			                







 
Page 1 of 0 ( 0 comments )


       You can share your information about this topic using the form below! 

Please do not post your questions with this form! Thanks.

 

  
    
      
                
          
          

          
          Name (required)

          
          

                    
          

          E-Mail (required)          
                    

          
          
          

          Your email will not be displayed on the site - only to our administrator          
          

          Homepage(optional)







          
          

          Comment          
                    Enable HTML code :
          
          Yes
          
          No 

          
          
          
          

          

 
          

          
          
        
      
    
  





&#160;
      
      
        &#160;
        &#160;
        &#160;
        
        &#160;
      
      
        &#160;
        &#160;
        &#160;
        &#160;
        &#160;
      
    
    
      
        
          &#160;
          &#160;
          &#160;
        
        
          &#160;
          
              &#160;            
          &#160;
        
        
          &#160;
          &#160;
          &#160;
        
      
    
    
      
        
            
            
            
        
      
    
	
	


		
				
			
				
			
		
		
		








Home


-


About Us


-


Privacy Policy






Copyright 2005 - 2008 www.java-tips.org
Java is a trademark of Sun Microsystems, Inc.
</TEXT>
</result>
