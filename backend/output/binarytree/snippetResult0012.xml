<?xml version="1.0" encoding="UTF-8"?>
<result>
<description>
<docid>21147</docid>
<orderid>0</orderid>
<type>TEXT</type>
<url>http://www.java-tips.org/java-se-tips/java.lang/red-black-tree-implementation-in-java-3.html</url>
</description>
<TEXT orderid="0" >
&#160;
            
	      





              Home    Java SE Tips               

              


            &#160;
          


        
      
  





  
    &#160;
    
    
      
        
          
              
                		
				
			
							
		
		
				
					
				
					Main Menu				
			
					
			
				

Home
Java Tutorials
Book Reviews
Java SE Tips
Java ME Tips
Java EE Tips
Other API Tips
Java Applications
Java Libraries
Java Games
Sitemap
			
		
		
				
					
				
					Java Network				
			
					
			
				






 Java Forums












			
		
		
				
				
			
				
 



 
 










 


			
		
		
				
					
				
					Most Visited Tips				
			
					
			
				

Java SE Tips
Java ME Tips
Java EE Tips
Other API Tips
Java Applications
Java Libraries
Java Games
Book Reviews
			
		
		
				
					
				
					Top Rated Tips				
			
					
			
				

Java SE Tips
Java ME Tips
Java EE Tips
Other API Tips
Java Applications
Java Libraries
Java Games
Book Reviews
			
		
		
				
				
			
				











			
		
		
				
					
				
					Statistics				
			
					
			
				Registered Users: 770Java SE Tips: 614Java ME Tips: 201Java EE Tips: 184Other API Tips: 779Java Applications: 298Java Libraries: 209Java Games: 16Book Reviews: 			
		
		
		                
              
              
                &#160;
              
            
        
        
          &#160;
        
      
      

      &#160;
        
								
			
								
					Red-Black Tree Implementation in Java									
							
				
					
			
						
			
			User Rating:&#160;/&#160;55


PoorBest&#160;
		
				
			
				A red-black tree is a type of self-balancing binary search tree, a data structure used in computer science, typically used to implement associative arrays. The original structure was invented in 1972 by Rudolf Bayer who called them &quot;symmetric binary B-trees&quot;, but acquired its modern name in a paper in 1978 by Leo J. Guibas and Robert Sedgewick. It is complex, but has good worst-case running time for its operations and is efficient in practice: it can search, insert, and delete in O(log n) time, where n is the number of elements in the tree.

A red-black tree is a special type of binary tree, which is a structure used in computer science to organize pieces of comparable data, such as numbers. Each piece of data is stored in a node. One of the nodes always functions as our starting place, and is not the child of any node; we call this the root node or root. It has up to two &quot;children&quot;, other nodes to which it connects. Each of these children can have children of its own, and so on. The root node thus has a path connecting it to any other node in the tree.

If a node has no children, we call it a leaf node, since intuitively it is at the periphery of the tree. A subtree is the portion of the tree that can be reached from a certain node, considered as a tree itself. In red-black trees, the leaves are assumed to be null or empty.

As red-black trees are also binary search trees, they must satisfy the constraint that every node contains a value greater than or equal to all nodes in its left subtree, and less than or equal to all nodes in its right subtree. This makes it quick to search the tree for a given value.

The following code shows how to implement a red-black tree in Java:
</TEXT>
<CODE orderid="1" >
//&#160;RedBlackTree&#160;class

//

//&#160;CONSTRUCTION:&#160;with&#160;a&#160;negative&#160;infinity&#160;sentinel

//

//&#160;******************PUBLIC&#160;OPERATIONS*********************

//&#160;void&#160;insert(&#160;x&#160;)&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&gt;&#160;Insert&#160;x

//&#160;void&#160;remove(&#160;x&#160;)&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&gt;&#160;Remove&#160;x&#160;(unimplemented)

//&#160;Comparable&#160;find(&#160;x&#160;)&#160;&#160;&#160;--&gt;&#160;Return&#160;item&#160;that&#160;matches&#160;x

//&#160;Comparable&#160;findMin(&#160;)&#160;&#160;--&gt;&#160;Return&#160;smallest&#160;item

//&#160;Comparable&#160;findMax(&#160;)&#160;&#160;--&gt;&#160;Return&#160;largest&#160;item

//&#160;boolean&#160;isEmpty(&#160;)&#160;&#160;&#160;&#160;&#160;--&gt;&#160;Return&#160;true&#160;if&#160;empty;&#160;else&#160;false

//&#160;void&#160;makeEmpty(&#160;)&#160;&#160;&#160;&#160;&#160;&#160;--&gt;&#160;Remove&#160;all&#160;items

//&#160;void&#160;printTree(&#160;)&#160;&#160;&#160;&#160;&#160;&#160;--&gt;&#160;Print&#160;all&#160;items

//&#160;******************ERRORS********************************

//&#160;Exceptions&#160;are&#160;thrown&#160;by&#160;insert&#160;if&#160;warranted&#160;and&#160;remove.



/**

&#160;*&#160;Implements&#160;a&#160;red-black&#160;tree.

&#160;*&#160;Note&#160;that&#160;all&#160;&quot;matching&quot;&#160;is&#160;based&#160;on&#160;the&#160;compareTo&#160;method.

&#160;*&#160;@author&#160;Mark&#160;Allen&#160;Weiss

&#160;*/

public&#160;class&#160;RedBlackTree&#160;{

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Construct&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;RedBlackTree(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;header&#160;&#160;&#160;&#160;&#160;&#160;=&#160;new&#160;RedBlackNode(&#160;null&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;header.left&#160;=&#160;header.right&#160;=&#160;nullNode;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Compare&#160;item&#160;and&#160;t.element,&#160;using&#160;compareTo,&#160;with

&#160;&#160;&#160;&#160;&#160;*&#160;caveat&#160;that&#160;if&#160;t&#160;is&#160;header,&#160;then&#160;item&#160;is&#160;always&#160;larger.

&#160;&#160;&#160;&#160;&#160;*&#160;This&#160;routine&#160;is&#160;called&#160;if&#160;is&#160;possible&#160;that&#160;t&#160;is&#160;header.

&#160;&#160;&#160;&#160;&#160;*&#160;If&#160;it&#160;is&#160;not&#160;possible&#160;for&#160;t&#160;to&#160;be&#160;header,&#160;use&#160;compareTo&#160;directly.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;private&#160;final&#160;int&#160;compare(&#160;Comparable&#160;item,&#160;RedBlackNode&#160;t&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t&#160;==&#160;header&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;1;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;item.compareTo(&#160;t.element&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Insert&#160;into&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;item&#160;the&#160;item&#160;to&#160;insert.

&#160;&#160;&#160;&#160;&#160;*&#160;@throws&#160;DuplicateItemException&#160;if&#160;item&#160;is&#160;already&#160;present.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;void&#160;insert(&#160;Comparable&#160;item&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;current&#160;=&#160;parent&#160;=&#160;grand&#160;=&#160;header;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nullNode.element&#160;=&#160;item;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while(&#160;compare(&#160;item,&#160;current&#160;)&#160;!=&#160;0&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;great&#160;=&#160;grand;&#160;grand&#160;=&#160;parent;&#160;parent&#160;=&#160;current;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;current&#160;=&#160;compare(&#160;item,&#160;current&#160;)&#160;&lt;&#160;0&#160;?

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;current.left&#160;:&#160;current.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Check&#160;if&#160;two&#160;red&#160;children;&#160;fix&#160;if&#160;so

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;current.left.color&#160;==&#160;RED&#160;&amp;&amp;&#160;current.right.color&#160;==&#160;RED&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;handleReorient(&#160;item&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Insertion&#160;fails&#160;if&#160;already&#160;present

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;current&#160;!=&#160;nullNode&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw&#160;new&#160;DuplicateItemException(&#160;item.toString(&#160;)&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;current&#160;=&#160;new&#160;RedBlackNode(&#160;item,&#160;nullNode,&#160;nullNode&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Attach&#160;to&#160;parent

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;compare(&#160;item,&#160;parent&#160;)&#160;&lt;&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;parent.left&#160;=&#160;current;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;parent.right&#160;=&#160;current;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;handleReorient(&#160;item&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Remove&#160;from&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;x&#160;the&#160;item&#160;to&#160;remove.

&#160;&#160;&#160;&#160;&#160;*&#160;@throws&#160;UnsupportedOperationException&#160;if&#160;called.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;void&#160;remove(&#160;Comparable&#160;x&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw&#160;new&#160;UnsupportedOperationException(&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Find&#160;the&#160;smallest&#160;item&#160;&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;smallest&#160;item&#160;or&#160;null&#160;if&#160;empty.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;Comparable&#160;findMin(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;isEmpty(&#160;)&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;null;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RedBlackNode&#160;itr&#160;=&#160;header.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while(&#160;itr.left&#160;!=&#160;nullNode&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;itr&#160;=&#160;itr.left;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;itr.element;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Find&#160;the&#160;largest&#160;item&#160;in&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;largest&#160;item&#160;or&#160;null&#160;if&#160;empty.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;Comparable&#160;findMax(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;isEmpty(&#160;)&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;null;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RedBlackNode&#160;itr&#160;=&#160;header.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while(&#160;itr.right&#160;!=&#160;nullNode&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;itr&#160;=&#160;itr.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;itr.element;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Find&#160;an&#160;item&#160;in&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;x&#160;the&#160;item&#160;to&#160;search&#160;for.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;matching&#160;item&#160;or&#160;null&#160;if&#160;not&#160;found.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;Comparable&#160;find(&#160;Comparable&#160;x&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nullNode.element&#160;=&#160;x;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;current&#160;=&#160;header.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(&#160;;&#160;;&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;x.compareTo(&#160;current.element&#160;)&#160;&lt;&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;current&#160;=&#160;current.left;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;if(&#160;x.compareTo(&#160;current.element&#160;)&#160;&gt;&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;current&#160;=&#160;current.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;if(&#160;current&#160;!=&#160;nullNode&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;current.element;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;null;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Make&#160;the&#160;tree&#160;logically&#160;empty.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;void&#160;makeEmpty(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;header.right&#160;=&#160;nullNode;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Print&#160;all&#160;items.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;void&#160;printTree(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printTree(&#160;header.right&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Internal&#160;method&#160;to&#160;print&#160;a&#160;subtree&#160;in&#160;sorted&#160;order.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;t&#160;the&#160;node&#160;that&#160;roots&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;private&#160;void&#160;printTree(&#160;RedBlackNode&#160;t&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t&#160;!=&#160;nullNode&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printTree(&#160;t.left&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;System.out.println(&#160;t.element&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;printTree(&#160;t.right&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Test&#160;if&#160;the&#160;tree&#160;is&#160;logically&#160;empty.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;true&#160;if&#160;empty,&#160;false&#160;otherwise.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;boolean&#160;isEmpty(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;header.right&#160;==&#160;nullNode;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Internal&#160;routine&#160;that&#160;is&#160;called&#160;during&#160;an&#160;insertion

&#160;&#160;&#160;&#160;&#160;*&#160;if&#160;a&#160;node&#160;has&#160;two&#160;red&#160;children.&#160;Performs&#160;flip&#160;and&#160;rotations.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;item&#160;the&#160;item&#160;being&#160;inserted.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;private&#160;void&#160;handleReorient(&#160;Comparable&#160;item&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Do&#160;the&#160;color&#160;flip

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;current.color&#160;=&#160;RED;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;current.left.color&#160;=&#160;BLACK;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;current.right.color&#160;=&#160;BLACK;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;parent.color&#160;==&#160;RED&#160;)&#160;&#160;&#160;//&#160;Have&#160;to&#160;rotate

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;grand.color&#160;=&#160;RED;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;(&#160;compare(&#160;item,&#160;grand&#160;)&#160;&lt;&#160;0&#160;)&#160;!=

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;(&#160;compare(&#160;item,&#160;parent&#160;)&#160;&lt;&#160;0&#160;)&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;parent&#160;=&#160;rotate(&#160;item,&#160;grand&#160;);&#160;&#160;//&#160;Start&#160;dbl&#160;rotate

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;current&#160;=&#160;rotate(&#160;item,&#160;great&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;current.color&#160;=&#160;BLACK;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;header.right.color&#160;=&#160;BLACK;&#160;//&#160;Make&#160;root&#160;black

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Internal&#160;routine&#160;that&#160;performs&#160;a&#160;single&#160;or&#160;double&#160;rotation.

&#160;&#160;&#160;&#160;&#160;*&#160;Because&#160;the&#160;result&#160;is&#160;attached&#160;to&#160;the&#160;parent,&#160;there&#160;are&#160;four&#160;cases.

&#160;&#160;&#160;&#160;&#160;*&#160;Called&#160;by&#160;handleReorient.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;item&#160;the&#160;item&#160;in&#160;handleReorient.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;parent&#160;the&#160;parent&#160;of&#160;the&#160;root&#160;of&#160;the&#160;rotated&#160;subtree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;root&#160;of&#160;the&#160;rotated&#160;subtree.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;private&#160;RedBlackNode&#160;rotate(&#160;Comparable&#160;item,&#160;RedBlackNode&#160;parent&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;compare(&#160;item,&#160;parent&#160;)&#160;&lt;&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;parent.left&#160;=&#160;compare(&#160;item,&#160;parent.left&#160;)&#160;&lt;&#160;0&#160;?

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rotateWithLeftChild(&#160;parent.left&#160;)&#160;&#160;:&#160;&#160;//&#160;LL

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rotateWithRightChild(&#160;parent.left&#160;)&#160;;&#160;&#160;//&#160;LR

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;parent.right&#160;=&#160;compare(&#160;item,&#160;parent.right&#160;)&#160;&lt;&#160;0&#160;?

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rotateWithLeftChild(&#160;parent.right&#160;)&#160;:&#160;&#160;//&#160;RL

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;rotateWithRightChild(&#160;parent.right&#160;);&#160;&#160;//&#160;RR

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Rotate&#160;binary&#160;tree&#160;node&#160;with&#160;left&#160;child.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;private&#160;static&#160;RedBlackNode&#160;rotateWithLeftChild(&#160;RedBlackNode&#160;k2&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RedBlackNode&#160;k1&#160;=&#160;k2.left;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;k2.left&#160;=&#160;k1.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;k1.right&#160;=&#160;k2;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;k1;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Rotate&#160;binary&#160;tree&#160;node&#160;with&#160;right&#160;child.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;private&#160;static&#160;RedBlackNode&#160;rotateWithRightChild(&#160;RedBlackNode&#160;k1&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RedBlackNode&#160;k2&#160;=&#160;k1.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;k1.right&#160;=&#160;k2.left;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;k2.left&#160;=&#160;k1;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;k2;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;private&#160;static&#160;class&#160;RedBlackNode&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Constructors

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RedBlackNode(&#160;Comparable&#160;theElement&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;this(&#160;theElement,&#160;null,&#160;null&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RedBlackNode(&#160;Comparable&#160;theElement,&#160;RedBlackNode&#160;lt,&#160;RedBlackNode&#160;rt&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;element&#160;&#160;=&#160;theElement;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;left&#160;&#160;&#160;&#160;&#160;=&#160;lt;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;right&#160;&#160;&#160;&#160;=&#160;rt;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;color&#160;&#160;&#160;&#160;=&#160;RedBlackTree.BLACK;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;Comparable&#160;&#160;&#160;element;&#160;&#160;&#160;&#160;//&#160;The&#160;data&#160;in&#160;the&#160;node

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RedBlackNode&#160;left;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Left&#160;child

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RedBlackNode&#160;right;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Right&#160;child

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;int&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;color;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Color

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;private&#160;RedBlackNode&#160;header;

&#160;&#160;&#160;&#160;private&#160;static&#160;RedBlackNode&#160;nullNode;

&#160;&#160;&#160;&#160;static&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Static&#160;initializer&#160;for&#160;nullNode

&#160;&#160;&#160;&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nullNode&#160;=&#160;new&#160;RedBlackNode(&#160;null&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;nullNode.left&#160;=&#160;nullNode.right&#160;=&#160;nullNode;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;private&#160;static&#160;final&#160;int&#160;BLACK&#160;=&#160;1;&#160;&#160;&#160;&#160;//&#160;Black&#160;must&#160;be&#160;1

&#160;&#160;&#160;&#160;private&#160;static&#160;final&#160;int&#160;RED&#160;&#160;&#160;=&#160;0;

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;//&#160;Used&#160;in&#160;insert&#160;routine&#160;and&#160;its&#160;helpers

&#160;&#160;&#160;&#160;private&#160;static&#160;RedBlackNode&#160;current;

&#160;&#160;&#160;&#160;private&#160;static&#160;RedBlackNode&#160;parent;

&#160;&#160;&#160;&#160;private&#160;static&#160;RedBlackNode&#160;grand;

&#160;&#160;&#160;&#160;private&#160;static&#160;RedBlackNode&#160;great;

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;//&#160;Test&#160;program

&#160;&#160;&#160;&#160;public&#160;static&#160;void&#160;main(&#160;String&#160;[&#160;]&#160;args&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;RedBlackTree&#160;t&#160;=&#160;new&#160;RedBlackTree(&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;final&#160;int&#160;NUMS&#160;=&#160;400000;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;final&#160;int&#160;GAP&#160;&#160;=&#160;&#160;35461;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;System.out.println(&#160;&quot;Checking...&#160;(no&#160;more&#160;output&#160;means&#160;success)&quot;&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(&#160;int&#160;i&#160;=&#160;GAP;&#160;i&#160;!=&#160;0;&#160;i&#160;=&#160;(&#160;i&#160;+&#160;GAP&#160;)&#160;%&#160;NUMS&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.insert(&#160;new&#160;Integer(&#160;i&#160;)&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;((Integer)(t.findMin(&#160;))).intValue(&#160;)&#160;!=&#160;1&#160;||

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;((Integer)(t.findMax(&#160;))).intValue(&#160;)&#160;!=&#160;NUMS&#160;-&#160;1&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;System.out.println(&#160;&quot;FindMin&#160;or&#160;FindMax&#160;error!&quot;&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(&#160;int&#160;i&#160;=&#160;1;&#160;i&#160;&lt;&#160;NUMS;&#160;i++&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;((Integer)(t.find(&#160;new&#160;Integer(&#160;i&#160;)&#160;))).intValue(&#160;)&#160;!=&#160;i&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;System.out.println(&#160;&quot;Find&#160;error1!&quot;&#160;);

&#160;&#160;&#160;&#160;}

}





/**

&#160;*&#160;Exception&#160;class&#160;for&#160;duplicate&#160;item&#160;errors

&#160;*&#160;in&#160;search&#160;tree&#160;insertions.

&#160;*&#160;@author&#160;Mark&#160;Allen&#160;Weiss

&#160;*/

public&#160;class&#160;DuplicateItemException&#160;extends&#160;RuntimeException

{

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Construct&#160;this&#160;exception&#160;object.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;DuplicateItemException(&#160;)

&#160;&#160;&#160;&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;super(&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Construct&#160;this&#160;exception&#160;object.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;message&#160;the&#160;error&#160;message.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;DuplicateItemException(&#160;String&#160;message&#160;)

&#160;&#160;&#160;&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;super(&#160;message&#160;);

&#160;&#160;&#160;&#160;}

}
</CODE>
<TEXT orderid="2" >
&#160;Related Tips 
A custom combobox editor for use with the EditableComboBox class
A demonstration of Java2D transformations
A game of Tic-Tac-Toe that can be played between two client applets
A Label that uses inline HTML to format its text
A program to print limits of the primitive types
A sample of inline DTD definition
A sample of linked DTD definition
A sample XML file

			
		
				

		&#160;

		

			
									
						
							&lt; Prev
					
										&#160;

					
										
						
							Next &gt;
					
								
			
			                







 
Page 1 of 0 ( 0 comments )


       You can share your information about this topic using the form below! 

Please do not post your questions with this form! Thanks.

 

  
    
      
                
          
          

          
          Name (required)

          
          

                    
          

          E-Mail (required)          
                    

          
          
          

          Your email will not be displayed on the site - only to our administrator          
          

          Homepage(optional)







          
          

          Comment          
                    Enable HTML code :
          
          Yes
          
          No 

          
          
          
          

          

 
          

          
          
        
      
    
  





&#160;
      
      
        &#160;
        &#160;
        &#160;
        
        &#160;
      
      
        &#160;
        &#160;
        &#160;
        &#160;
        &#160;
      
    
    
      
        
          &#160;
          &#160;
          &#160;
        
        
          &#160;
          
              &#160;            
          &#160;
        
        
          &#160;
          &#160;
          &#160;
        
      
    
    
      
        
            
            
            
        
      
    
	
	


		
				
			
				
			
		
		
		








Home


-


About Us


-


Privacy Policy






Copyright 2005 - 2008 www.java-tips.org
Java is a trademark of Sun Microsystems, Inc.
</TEXT>
</result>
