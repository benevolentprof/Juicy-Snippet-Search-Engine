<?xml version="1.0" encoding="UTF-8"?>
<result>
<description>
<docid>15846</docid>
<orderid>0</orderid>
<type>TEXT</type>
<url>http://www.java-tips.org/java-se-tips/java.lang/binary-search-tree-implementation-in-java-2.html</url>
</description>
<TEXT orderid="0" >
&#160;
            
	      





              Home    Java SE Tips               

              


            &#160;
          


        
      
  





  
    &#160;
    
    
      
        
          
              
                		
				
			
							
		
		
				
					
				
					Main Menu				
			
					
			
				

Home
Java Tutorials
Book Reviews
Java SE Tips
Java ME Tips
Java EE Tips
Other API Tips
Java Applications
Java Libraries
Java Games
Sitemap
			
		
		
				
					
				
					Java Network				
			
					
			
				






 Java Forums












			
		
		
				
				
			
				
 



 
 










 


			
		
		
				
					
				
					Most Visited Tips				
			
					
			
				

Java SE Tips
Java ME Tips
Java EE Tips
Other API Tips
Java Applications
Java Libraries
Java Games
Book Reviews
			
		
		
				
					
				
					Top Rated Tips				
			
					
			
				

Java SE Tips
Java ME Tips
Java EE Tips
Other API Tips
Java Applications
Java Libraries
Java Games
Book Reviews
			
		
		
				
				
			
				











			
		
		
				
					
				
					Statistics				
			
					
			
				Registered Users: 770Java SE Tips: 614Java ME Tips: 201Java EE Tips: 184Other API Tips: 779Java Applications: 298Java Libraries: 209Java Games: 16Book Reviews: 			
		
		
		                
              
              
                &#160;
              
            
        
        
          &#160;
        
      
      

      &#160;
        
								
			
								
					Binary Search Tree Implementation in Java									
							
				
					
			
						
			
			User Rating:&#160;/&#160;233


PoorBest&#160;
		
				
			
				In computer science, a binary search tree (BST) is a binary tree which has the following properties:


Each node has a value.
A total order is defined on these values.
The left subtree of a node contains only values less than or equal to the node&apos;s value.
The right subtree of a node contains only values greater than or equal to the node&apos;s value.


The major advantage of binary search trees is that the related sorting algorithms and search algorithms such as in-order traversal can be very efficient.

Binary search trees are a fundamental data structure used to construct more abstract data structures such as sets, multisets, and associative arrays.

Following code shows how to implement a binary search tree in Java:
</TEXT>
<CODE orderid="1" >
//&#160;BinarySearchTree&#160;class

//

//&#160;CONSTRUCTION:&#160;with&#160;no&#160;initializer

//

//&#160;******************PUBLIC&#160;OPERATIONS*********************

//&#160;void&#160;insert(&#160;x&#160;)&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&gt;&#160;Insert&#160;x

//&#160;void&#160;remove(&#160;x&#160;)&#160;&#160;&#160;&#160;&#160;&#160;&#160;--&gt;&#160;Remove&#160;x

//&#160;void&#160;removeMin(&#160;)&#160;&#160;&#160;&#160;&#160;&#160;--&gt;&#160;Remove&#160;minimum&#160;item

//&#160;Comparable&#160;find(&#160;x&#160;)&#160;&#160;&#160;--&gt;&#160;Return&#160;item&#160;that&#160;matches&#160;x

//&#160;Comparable&#160;findMin(&#160;)&#160;&#160;--&gt;&#160;Return&#160;smallest&#160;item

//&#160;Comparable&#160;findMax(&#160;)&#160;&#160;--&gt;&#160;Return&#160;largest&#160;item

//&#160;boolean&#160;isEmpty(&#160;)&#160;&#160;&#160;&#160;&#160;--&gt;&#160;Return&#160;true&#160;if&#160;empty;&#160;else&#160;false

//&#160;void&#160;makeEmpty(&#160;)&#160;&#160;&#160;&#160;&#160;&#160;--&gt;&#160;Remove&#160;all&#160;items

//&#160;******************ERRORS********************************

//&#160;Exceptions&#160;are&#160;thrown&#160;by&#160;insert,&#160;remove,&#160;and&#160;removeMin&#160;if&#160;warranted



/**

&#160;*&#160;Implements&#160;an&#160;unbalanced&#160;binary&#160;search&#160;tree.

&#160;*&#160;Note&#160;that&#160;all&#160;&quot;matching&quot;&#160;is&#160;based&#160;on&#160;the&#160;compareTo&#160;method.

&#160;*&#160;@author&#160;Mark&#160;Allen&#160;Weiss

&#160;*/

public&#160;class&#160;BinarySearchTree&#160;{

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Construct&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;BinarySearchTree(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root&#160;=&#160;null;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Insert&#160;into&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;x&#160;the&#160;item&#160;to&#160;insert.

&#160;&#160;&#160;&#160;&#160;*&#160;@throws&#160;DuplicateItemException&#160;if&#160;x&#160;is&#160;already&#160;present.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;void&#160;insert(&#160;Comparable&#160;x&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root&#160;=&#160;insert(&#160;x,&#160;root&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Remove&#160;from&#160;the&#160;tree..

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;x&#160;the&#160;item&#160;to&#160;remove.

&#160;&#160;&#160;&#160;&#160;*&#160;@throws&#160;ItemNotFoundException&#160;if&#160;x&#160;is&#160;not&#160;found.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;void&#160;remove(&#160;Comparable&#160;x&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root&#160;=&#160;remove(&#160;x,&#160;root&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Remove&#160;minimum&#160;item&#160;from&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@throws&#160;ItemNotFoundException&#160;if&#160;tree&#160;is&#160;empty.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;void&#160;removeMin(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root&#160;=&#160;removeMin(&#160;root&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Find&#160;the&#160;smallest&#160;item&#160;in&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;smallest&#160;item&#160;or&#160;null&#160;if&#160;empty.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;Comparable&#160;findMin(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;elementAt(&#160;findMin(&#160;root&#160;)&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Find&#160;the&#160;largest&#160;item&#160;in&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;largest&#160;item&#160;or&#160;null&#160;if&#160;empty.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;Comparable&#160;findMax(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;elementAt(&#160;findMax(&#160;root&#160;)&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Find&#160;an&#160;item&#160;in&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;x&#160;the&#160;item&#160;to&#160;search&#160;for.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;matching&#160;item&#160;or&#160;null&#160;if&#160;not&#160;found.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;Comparable&#160;find(&#160;Comparable&#160;x&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;elementAt(&#160;find(&#160;x,&#160;root&#160;)&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Make&#160;the&#160;tree&#160;logically&#160;empty.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;void&#160;makeEmpty(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;root&#160;=&#160;null;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Test&#160;if&#160;the&#160;tree&#160;is&#160;logically&#160;empty.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;true&#160;if&#160;empty,&#160;false&#160;otherwise.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;boolean&#160;isEmpty(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;root&#160;==&#160;null;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Internal&#160;method&#160;to&#160;get&#160;element&#160;field.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;t&#160;the&#160;node.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;element&#160;field&#160;or&#160;null&#160;if&#160;t&#160;is&#160;null.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;private&#160;Comparable&#160;elementAt(&#160;BinaryNode&#160;t&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;t&#160;==&#160;null&#160;?&#160;null&#160;:&#160;t.element;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Internal&#160;method&#160;to&#160;insert&#160;into&#160;a&#160;subtree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;x&#160;the&#160;item&#160;to&#160;insert.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;t&#160;the&#160;node&#160;that&#160;roots&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;new&#160;root.

&#160;&#160;&#160;&#160;&#160;*&#160;@throws&#160;DuplicateItemException&#160;if&#160;x&#160;is&#160;already&#160;present.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;protected&#160;BinaryNode&#160;insert(&#160;Comparable&#160;x,&#160;BinaryNode&#160;t&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t&#160;==&#160;null&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t&#160;=&#160;new&#160;BinaryNode(&#160;x&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;if(&#160;x.compareTo(&#160;t.element&#160;)&#160;&lt;&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.left&#160;=&#160;insert(&#160;x,&#160;t.left&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;if(&#160;x.compareTo(&#160;t.element&#160;)&#160;&gt;&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.right&#160;=&#160;insert(&#160;x,&#160;t.right&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw&#160;new&#160;DuplicateItemException(&#160;x.toString(&#160;)&#160;);&#160;&#160;//&#160;Duplicate

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;t;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Internal&#160;method&#160;to&#160;remove&#160;from&#160;a&#160;subtree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;x&#160;the&#160;item&#160;to&#160;remove.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;t&#160;the&#160;node&#160;that&#160;roots&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;new&#160;root.

&#160;&#160;&#160;&#160;&#160;*&#160;@throws&#160;ItemNotFoundException&#160;if&#160;x&#160;is&#160;not&#160;found.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;protected&#160;BinaryNode&#160;remove(&#160;Comparable&#160;x,&#160;BinaryNode&#160;t&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t&#160;==&#160;null&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw&#160;new&#160;ItemNotFoundException(&#160;x.toString(&#160;)&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;x.compareTo(&#160;t.element&#160;)&#160;&lt;&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.left&#160;=&#160;remove(&#160;x,&#160;t.left&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;if(&#160;x.compareTo(&#160;t.element&#160;)&#160;&gt;&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.right&#160;=&#160;remove(&#160;x,&#160;t.right&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;if(&#160;t.left&#160;!=&#160;null&#160;&amp;&amp;&#160;t.right&#160;!=&#160;null&#160;)&#160;//&#160;Two&#160;children

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.element&#160;=&#160;findMin(&#160;t.right&#160;).element;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.right&#160;=&#160;removeMin(&#160;t.right&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;else

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t&#160;=&#160;(&#160;t.left&#160;!=&#160;null&#160;)&#160;?&#160;t.left&#160;:&#160;t.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;t;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Internal&#160;method&#160;to&#160;remove&#160;minimum&#160;item&#160;from&#160;a&#160;subtree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;t&#160;the&#160;node&#160;that&#160;roots&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;the&#160;new&#160;root.

&#160;&#160;&#160;&#160;&#160;*&#160;@throws&#160;ItemNotFoundException&#160;if&#160;x&#160;is&#160;not&#160;found.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;protected&#160;BinaryNode&#160;removeMin(&#160;BinaryNode&#160;t&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t&#160;==&#160;null&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;throw&#160;new&#160;ItemNotFoundException(&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;if(&#160;t.left&#160;!=&#160;null&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.left&#160;=&#160;removeMin(&#160;t.left&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;t;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}&#160;else

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;t.right;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Internal&#160;method&#160;to&#160;find&#160;the&#160;smallest&#160;item&#160;in&#160;a&#160;subtree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;t&#160;the&#160;node&#160;that&#160;roots&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;node&#160;containing&#160;the&#160;smallest&#160;item.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;protected&#160;BinaryNode&#160;findMin(&#160;BinaryNode&#160;t&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t&#160;!=&#160;null&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while(&#160;t.left&#160;!=&#160;null&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t&#160;=&#160;t.left;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;t;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Internal&#160;method&#160;to&#160;find&#160;the&#160;largest&#160;item&#160;in&#160;a&#160;subtree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;t&#160;the&#160;node&#160;that&#160;roots&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;node&#160;containing&#160;the&#160;largest&#160;item.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;private&#160;BinaryNode&#160;findMax(&#160;BinaryNode&#160;t&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t&#160;!=&#160;null&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while(&#160;t.right&#160;!=&#160;null&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t&#160;=&#160;t.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;t;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Internal&#160;method&#160;to&#160;find&#160;an&#160;item&#160;in&#160;a&#160;subtree.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;x&#160;is&#160;item&#160;to&#160;search&#160;for.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;t&#160;the&#160;node&#160;that&#160;roots&#160;the&#160;tree.

&#160;&#160;&#160;&#160;&#160;*&#160;@return&#160;node&#160;containing&#160;the&#160;matched&#160;item.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;private&#160;BinaryNode&#160;find(&#160;Comparable&#160;x,&#160;BinaryNode&#160;t&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;while(&#160;t&#160;!=&#160;null&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;x.compareTo(&#160;t.element&#160;)&#160;&lt;&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t&#160;=&#160;t.left;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else&#160;if(&#160;x.compareTo(&#160;t.element&#160;)&#160;&gt;&#160;0&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t&#160;=&#160;t.right;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;t;&#160;&#160;&#160;&#160;//&#160;Match

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;return&#160;null;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Not&#160;found

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**&#160;The&#160;tree&#160;root.&#160;*/

&#160;&#160;&#160;&#160;protected&#160;BinaryNode&#160;root;

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;//&#160;Test&#160;program

&#160;&#160;&#160;&#160;public&#160;static&#160;void&#160;main(&#160;String&#160;[&#160;]&#160;args&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;BinarySearchTree&#160;t&#160;=&#160;new&#160;BinarySearchTree(&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;final&#160;int&#160;NUMS&#160;=&#160;4000;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;final&#160;int&#160;GAP&#160;&#160;=&#160;&#160;&#160;37;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;System.out.println(&#160;&quot;Checking...&#160;(no&#160;more&#160;output&#160;means&#160;success)&quot;&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(&#160;int&#160;i&#160;=&#160;GAP;&#160;i&#160;!=&#160;0;&#160;i&#160;=&#160;(&#160;i&#160;+&#160;GAP&#160;)&#160;%&#160;NUMS&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.insert(&#160;new&#160;Integer(&#160;i&#160;)&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(&#160;int&#160;i&#160;=&#160;1;&#160;i&#160;&lt;&#160;NUMS;&#160;i+=&#160;2&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;t.remove(&#160;new&#160;Integer(&#160;i&#160;)&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;((Integer)(t.findMin(&#160;))).intValue(&#160;)&#160;!=&#160;2&#160;||

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;((Integer)(t.findMax(&#160;))).intValue(&#160;)&#160;!=&#160;NUMS&#160;-&#160;2&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;System.out.println(&#160;&quot;FindMin&#160;or&#160;FindMax&#160;error!&quot;&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(&#160;int&#160;i&#160;=&#160;2;&#160;i&#160;&lt;&#160;NUMS;&#160;i+=2&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;((Integer)(t.find(&#160;new&#160;Integer(&#160;i&#160;)&#160;))).intValue(&#160;)&#160;!=&#160;i&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;System.out.println(&#160;&quot;Find&#160;error1!&quot;&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;for(&#160;int&#160;i&#160;=&#160;1;&#160;i&#160;&lt;&#160;NUMS;&#160;i+=2&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if(&#160;t.find(&#160;new&#160;Integer(&#160;i&#160;)&#160;)&#160;!=&#160;null&#160;)

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;System.out.println(&#160;&quot;Find&#160;error2!&quot;&#160;);

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;}

}





//&#160;Basic&#160;node&#160;stored&#160;in&#160;unbalanced&#160;binary&#160;search&#160;trees

//&#160;Note&#160;that&#160;this&#160;class&#160;is&#160;not&#160;accessible&#160;outside

//&#160;of&#160;this&#160;package.



class&#160;BinaryNode&#160;{

&#160;&#160;&#160;&#160;//&#160;Constructors

&#160;&#160;&#160;&#160;BinaryNode(&#160;Comparable&#160;theElement&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;element&#160;=&#160;theElement;

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;left&#160;=&#160;right&#160;=&#160;null;

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;//&#160;Friendly&#160;data;&#160;accessible&#160;by&#160;other&#160;package&#160;routines

&#160;&#160;&#160;&#160;Comparable&#160;element;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;The&#160;data&#160;in&#160;the&#160;node

&#160;&#160;&#160;&#160;BinaryNode&#160;left;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Left&#160;child

&#160;&#160;&#160;&#160;BinaryNode&#160;right;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;//&#160;Right&#160;child

}





/**

&#160;*&#160;Exception&#160;class&#160;for&#160;duplicate&#160;item&#160;errors

&#160;*&#160;in&#160;search&#160;tree&#160;insertions.

&#160;*&#160;@author&#160;Mark&#160;Allen&#160;Weiss

&#160;*/

public&#160;class&#160;DuplicateItemException&#160;extends&#160;RuntimeException&#160;{

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Construct&#160;this&#160;exception&#160;object.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;DuplicateItemException(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;super(&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Construct&#160;this&#160;exception&#160;object.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;message&#160;the&#160;error&#160;message.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;DuplicateItemException(&#160;String&#160;message&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;super(&#160;message&#160;);

&#160;&#160;&#160;&#160;}

}





/**

&#160;*&#160;Exception&#160;class&#160;for&#160;failed&#160;finds/removes&#160;in&#160;search

&#160;*&#160;trees,&#160;hash&#160;tables,&#160;and&#160;list&#160;and&#160;tree&#160;iterators.

&#160;*&#160;@author&#160;Mark&#160;Allen&#160;Weiss

&#160;*/

public&#160;class&#160;ItemNotFoundException&#160;extends&#160;RuntimeException&#160;{

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Construct&#160;this&#160;exception&#160;object.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;ItemNotFoundException(&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;super(&#160;);

&#160;&#160;&#160;&#160;}

&#160;&#160;&#160;&#160;

&#160;&#160;&#160;&#160;/**

&#160;&#160;&#160;&#160;&#160;*&#160;Construct&#160;this&#160;exception&#160;object.

&#160;&#160;&#160;&#160;&#160;*&#160;@param&#160;message&#160;the&#160;error&#160;message.

&#160;&#160;&#160;&#160;&#160;*/

&#160;&#160;&#160;&#160;public&#160;ItemNotFoundException(&#160;String&#160;message&#160;)&#160;{

&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;super(&#160;message&#160;);

&#160;&#160;&#160;&#160;}

}
</CODE>
<TEXT orderid="2" >
&#160;Related Tips 
A custom combobox editor for use with the EditableComboBox class
A demonstration of Java2D transformations
A game of Tic-Tac-Toe that can be played between two client applets
A Label that uses inline HTML to format its text
A program to print limits of the primitive types
A sample of inline DTD definition
A sample of linked DTD definition
A sample XML file

			
		
				

		&#160;

		

			
									
						
							&lt; Prev
					
										&#160;

					
										
						
							Next &gt;
					
								
			
			                







 
Page 1 of 0 ( 0 comments )


       You can share your information about this topic using the form below! 

Please do not post your questions with this form! Thanks.

 

  
    
      
                
          
          

          
          Name (required)

          
          

                    
          

          E-Mail (required)          
                    

          
          
          

          Your email will not be displayed on the site - only to our administrator          
          

          Homepage(optional)







          
          

          Comment          
                    Enable HTML code :
          
          Yes
          
          No 

          
          
          
          

          

 
          

          
          
        
      
    
  





&#160;
      
      
        &#160;
        &#160;
        &#160;
        
        &#160;
      
      
        &#160;
        &#160;
        &#160;
        &#160;
        &#160;
      
    
    
      
        
          &#160;
          &#160;
          &#160;
        
        
          &#160;
          
              &#160;            
          &#160;
        
        
          &#160;
          &#160;
          &#160;
        
      
    
    
      
        
            
            
            
        
      
    
	
	


		
				
			
				
			
		
		
		








Home


-


About Us


-


Privacy Policy






Copyright 2005 - 2008 www.java-tips.org
Java is a trademark of Sun Microsystems, Inc.
</TEXT>
</result>
